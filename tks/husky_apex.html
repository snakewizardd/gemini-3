<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AURORA APEX | THE LIVING HUSKY</title>
<style>
*{margin:0;padding:0}
body{background:#030303;height:100vh;display:flex;justify-content:center;align-items:center;overflow:hidden;cursor:crosshair}
canvas{box-shadow:0 0 100px rgba(80,150,220,0.08)}
#info{position:fixed;bottom:15px;left:50%;transform:translateX(-50%);color:rgba(255,255,255,0.15);font:9px monospace;letter-spacing:2px}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="info">MOVE MOUSE TO INTERACT</div>
<script>
const C = document.getElementById('c');
const X = C.getContext('2d');

const DPR = Math.min(window.devicePixelRatio || 1, 2);
const S = Math.min(innerWidth, innerHeight) * 0.92;
C.width = S * DPR; C.height = S * DPR;
C.style.width = S + 'px'; C.style.height = S + 'px';
X.scale(DPR, DPR);
X.translate(S/2, S/2);
const SC = 0.78;
X.scale(SC, SC);

// Input state with smoothing
const MOUSE = { x: 0, y: 0, sx: 0, sy: 0 };
window.addEventListener('mousemove', e => {
    const r = C.getBoundingClientRect();
    MOUSE.x = (e.clientX - r.left) / r.width * 2 - 1;
    MOUSE.y = (e.clientY - r.top) / r.height * 2 - 1;
});

// Noise
const P = [];
let seed = 42;
for (let i = 0; i < 256; i++) P[i] = i;
for (let i = 255; i > 0; i--) { seed = (seed * 16807) % 2147483647; [P[i], P[seed % (i+1)]] = [P[seed % (i+1)], P[i]]; }
for (let i = 0; i < 256; i++) P[256+i] = P[i];

function noise(x, y) {
    const xi = Math.floor(x) & 255, yi = Math.floor(y) & 255;
    const xf = x - Math.floor(x), yf = y - Math.floor(y);
    const u = xf * xf * xf * (xf * (xf * 6 - 15) + 10);
    const v = yf * yf * yf * (yf * (yf * 6 - 15) + 10);
    const g = (h, a, b) => ((h & 1) ? -a : a) + ((h & 2) ? -b : b);
    const l = (a, b, t) => a + t * (b - a);
    return 0.5 + 0.5 * l(l(g(P[P[xi]+yi], xf, yf), g(P[P[xi+1]+yi], xf-1, yf), u), 
                         l(g(P[P[xi]+yi+1], xf, yf-1), g(P[P[xi+1]+yi+1], xf-1, yf-1), u), v);
}

// Geometry
function inFace(x, y) {
    return (x*x)/(140*140) + ((y+20)*(y+20))/(158*158) < 1 ||
           (x*x)/(50*50) + ((y-92)*(y-92))/(55*55) < 1 ||
           ((x+108)*(x+108))/(58*58) + ((y+8)*(y+8))/(68*68) < 1 ||
           ((x-108)*(x-108))/(58*58) + ((y+8)*(y+8))/(68*68) < 1;
}

function inEar(x, y) {
    for (const [cx, side] of [[-92, 'L'], [92, 'R']]) {
        if (x >= cx-38 && x <= cx+38 && y >= -285 && y <= -82) {
            const t = (y + 82) / (-285 + 82);
            if (Math.abs(x - cx) <= 38 * (1 - t * 0.9)) return side;
        }
    }
    return false;
}

function inside(x, y) { return inFace(x, y) || inEar(x, y); }

// Mask pattern
function getMask(x, y) {
    const n = (noise(x * 0.007, y * 0.007) - 0.5) * 0.07;
    const ear = inEar(x, y);
    
    if (ear) {
        const cx = ear === 'L' ? -92 : 92;
        if (Math.abs(x - cx) < 16 && y > -248 && y < -105) return 0.08 + n; // Inner ear light
        if (Math.abs(x - cx) > 26) return 0.72 + n; // Edge
        return 0.88 + n; // Dark back
    }
    
    let dark = 0;
    
    // Cap
    if (y < -8) {
        const cap = Math.min(1, (-y - 8) / 95);
        const blaze = 14 + Math.max(0, y + 85) * 0.2;
        if (Math.abs(x) > blaze) {
            dark = cap * Math.min(1, (Math.abs(x) - blaze) / 20) * 0.9;
        }
    }
    
    // Eye mask - connected to cap
    for (const eye of [{x:-54, y:-18}, {x:54, y:-18}]) {
        const dx = x - eye.x, dy = y - eye.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d > 24 && d < 62) {
            const above = dy < 0 ? 0.32 : 0;
            const outer = (eye.x < 0 ? dx < 0 : dx > 0) ? 0.18 : 0;
            dark = Math.max(dark, (1 - (d - 24) / 38) * (0.48 + above + outer) * 0.88);
        }
    }
    
    // White zones
    if (y > 28 && Math.abs(x) < 54) dark = Math.min(dark, 0.02);
    if (Math.abs(x) > 58 && y > -28 && y < 58) dark = Math.min(dark, 0.03);
    if (y > 2 && y < 42 && Math.abs(x) < 68) dark = Math.min(dark, 0.04);
    
    return Math.max(0, Math.min(1, dark + n));
}

// Fur direction
function getAngle(x, y) {
    const n = (noise(x * 0.01, y * 0.01) - 0.5) * 0.22;
    if (inEar(x, y)) return -Math.PI/2 + n * 0.25;
    if (y < -32 && Math.abs(x) < 105) return -Math.PI/2 + x * 0.0018 + n;
    if (Math.abs(x) < 32 && y > -32 && y < 52) return Math.PI/2 + n * 0.4;
    for (const ex of [-54, 54]) {
        const d = Math.sqrt((x-ex)**2 + (y+18)**2);
        if (d < 52 && d > 22) return Math.atan2(y+18, x-ex) + n * 0.35;
    }
    if (Math.abs(x) > 48 && y > -38) return Math.PI/2 + (x > 0 ? 0.52 : -0.52) + n;
    return Math.PI/2 + n;
}

// Fur length
function getLen(x, y, guard) {
    const b = guard ? 30 : 11;
    const n = noise(x * 0.014, y * 0.014);
    if (inEar(x, y)) return b * 0.48 + n * 5;
    if (y > 58 && Math.abs(x) < 48) return b * 0.26 + n * 3;
    if (y < -32) return b * 0.68 + n * 7;
    if (Math.abs(x) > 72 || y > 78) return b * 1.45 + n * 16;
    return b + n * 11;
}

// Color
function getColor(m) {
    if (m > 0.62) { const v = 32 - (m-0.62)*75; return `rgb(${~~v},${~~v},${~~(v+2)})`; }
    if (m > 0.28) { const v = 165 - (m-0.28)*390; return `rgb(${~~v},${~~v},${~~(v+3)})`; }
    const v = 252 - m*310; return `rgb(${~~v},${~~v},${~~Math.min(255,v+5)})`;
}

// Create cached layer
function createLayer(filterFn, density) {
    const cv = document.createElement('canvas');
    cv.width = C.width; cv.height = C.height;
    const cx = cv.getContext('2d');
    cx.scale(DPR, DPR);
    cx.translate(S/2, S/2);
    cx.scale(SC, SC);
    
    const pts = [];
    for (let i = 0; i < density * 1.5; i++) {
        const x = (Math.random() - 0.5) * 520;
        const y = (Math.random() - 0.5) * 680;
        if (inside(x, y) && filterFn(x, y)) pts.push({x, y});
    }
    pts.sort((a, b) => a.y - b.y);
    
    for (let i = 0; i < Math.min(density, pts.length); i++) {
        const {x, y} = pts[i];
        const ang = getAngle(x, y);
        const len = getLen(x, y, false);
        const col = getColor(getMask(x, y));
        const curve = (noise(x * 0.028, y * 0.028) - 0.5) * 0.28;
        const ex = x + Math.cos(ang + curve) * len;
        const ey = y + Math.sin(ang + curve) * len;
        
        cx.beginPath();
        cx.moveTo(x, y);
        cx.quadraticCurveTo((x+ex)/2 + (noise(x*0.04,y*0.04)-0.5)*len*0.16, 
                            (y+ey)/2 + (noise(x*0.04+50,y*0.04)-0.5)*len*0.16, ex, ey);
        cx.strokeStyle = col;
        cx.lineWidth = 1.5;
        cx.globalAlpha = 0.4;
        cx.stroke();
        
        // Guard hair
        if (Math.random() > 0.45) {
            const glen = getLen(x, y, true);
            const gex = x + Math.cos(ang + curve * 0.4) * glen;
            const gey = y + Math.sin(ang + curve * 0.4) * glen;
            cx.beginPath();
            cx.moveTo(x, y);
            cx.quadraticCurveTo((x+gex)/2, (y+gey)/2, gex, gey);
            cx.lineWidth = 0.72;
            cx.globalAlpha = 0.76;
            cx.stroke();
        }
    }
    return cv;
}

// Create layers
const LAYER_EARS = createLayer((x,y) => inEar(x,y), 18000);
const LAYER_BACK = createLayer((x,y) => !inEar(x,y) && (Math.abs(x) > 75 || y < -90 || y > 85), 28000);
const LAYER_FACE = createLayer((x,y) => !inEar(x,y) && Math.abs(x) <= 75 && y >= -90 && y <= 85, 35000);

// Animation state
let T = 0;
let blink = 0;
let earTwitch = { L: 0, R: 0 };

// Draw eye with full animation
function drawEye(cx, cy, isLeft) {
    X.save();
    
    const look = { x: MOUSE.sx * 14, y: MOUSE.sy * 9 };
    X.translate(cx + look.x * 0.18, cy + look.y * 0.18);
    X.rotate(isLeft ? 0.14 : -0.14);
    
    // Socket
    X.fillStyle = '#000';
    X.shadowColor = '#000';
    X.shadowBlur = 12;
    X.beginPath();
    X.ellipse(0, 0, 25, 15, 0, 0, Math.PI*2);
    X.fill();
    X.shadowBlur = 0;
    
    // Sclera
    X.fillStyle = '#c6cad0';
    X.beginPath();
    X.ellipse(0, 0, 23, 13, 0, 0, Math.PI*2);
    X.fill();
    
    // Clip for iris
    X.save();
    X.beginPath();
    X.ellipse(0, 0, 23, 13, 0, 0, Math.PI*2);
    X.clip();
    
    // Iris moves with gaze
    X.translate(look.x * 0.7, look.y * 0.7);
    
    const ig = X.createRadialGradient(0, 0, 0, 0, 0, 13);
    ig.addColorStop(0, '#fff');
    ig.addColorStop(0.08, '#eafcff');
    ig.addColorStop(0.22, '#5cd0f8');
    ig.addColorStop(0.45, '#28a0d8');
    ig.addColorStop(0.68, '#1668a0');
    ig.addColorStop(0.85, '#0c4268');
    ig.addColorStop(1, '#061828');
    X.fillStyle = ig;
    X.beginPath();
    X.arc(0, 0, 13, 0, Math.PI*2);
    X.fill();
    
    // Iris fibers
    X.strokeStyle = 'rgba(255,255,255,0.06)';
    X.lineWidth = 0.28;
    for (let i = 0; i < 28; i++) {
        const a = i / 28 * Math.PI * 2;
        X.beginPath();
        X.moveTo(Math.cos(a) * 3.2, Math.sin(a) * 3.2);
        X.lineTo(Math.cos(a) * 12, Math.sin(a) * 12);
        X.stroke();
    }
    
    // Pupil - dilates based on "attention"
    const att = Math.sqrt(MOUSE.sx**2 + MOUSE.sy**2);
    const pupilR = 4.2 + (1 - Math.min(1, att)) * 1.2;
    X.fillStyle = '#000';
    X.beginPath();
    X.arc(0, 0, pupilR, 0, Math.PI*2);
    X.fill();
    
    // Catchlights (fixed to world)
    X.translate(-look.x * 0.7, -look.y * 0.7);
    X.fillStyle = '#fff';
    X.beginPath();
    X.arc(3.8, -3.8, 2.8, 0, Math.PI*2);
    X.fill();
    X.beginPath();
    X.arc(5.5, 0.5, 1.1, 0, Math.PI*2);
    X.fill();
    
    X.restore(); // End clip
    
    // Eyelid shadow
    const lg = X.createLinearGradient(0, -16, 0, 4);
    lg.addColorStop(0, 'rgba(0,0,0,0.5)');
    lg.addColorStop(0.5, 'rgba(0,0,0,0.1)');
    lg.addColorStop(1, 'rgba(0,0,0,0)');
    X.fillStyle = lg;
    X.beginPath();
    X.ellipse(0, -4, 19, 11, 0, 0, Math.PI*2);
    X.fill();
    
    // Blink
    if (blink > 0) {
        const lidY = Math.sin(blink / 10 * Math.PI) * 22;
        X.fillStyle = '#080808';
        X.beginPath();
        X.ellipse(0, -15 + lidY, 28, 18, 0, 0, Math.PI*2);
        X.fill();
    }
    
    X.restore();
}

// Draw nose with breathing
function drawNose() {
    const ny = 102;
    const px = MOUSE.sx * 4;
    const py = MOUSE.sy * 4;
    const breath = Math.sin(T * 0.055) * 1.8;
    
    X.save();
    X.translate(px, py);
    
    X.fillStyle = '#070707';
    X.beginPath();
    X.moveTo(-27, ny - 9);
    X.bezierCurveTo(-31, ny + 15, -15, ny + 35, 0, ny + 37);
    X.bezierCurveTo(15, ny + 35, 31, ny + 15, 27, ny - 9);
    X.bezierCurveTo(11, ny - 14, -11, ny - 14, -27, ny - 9);
    X.fill();
    
    // Texture
    X.fillStyle = 'rgba(28,28,32,0.35)';
    for (let i = 0; i < 100; i++) {
        const tx = (Math.random() - 0.5) * 46;
        const ty = ny + 4 + Math.random() * 26;
        if (tx*tx/480 + (ty-ny-13)**2/320 < 1) {
            X.beginPath();
            X.arc(tx, ty, 0.55, 0, Math.PI*2);
            X.fill();
        }
    }
    
    // Shine
    const sg = X.createRadialGradient(-7, ny + 4, 0, -7, ny + 4, 13);
    sg.addColorStop(0, 'rgba(255,255,255,0.16)');
    sg.addColorStop(1, 'rgba(255,255,255,0)');
    X.fillStyle = sg;
    X.beginPath();
    X.ellipse(-7, ny + 4, 11, 7, -0.22, 0, Math.PI*2);
    X.fill();
    
    // Nostrils - breathing animation
    X.fillStyle = '#000';
    X.beginPath();
    X.ellipse(-11 - breath*0.4, ny + 13, 5.8 + breath*0.18, 3.8 + breath*0.15, -0.32, 0, Math.PI*2);
    X.fill();
    X.beginPath();
    X.ellipse(11 + breath*0.4, ny + 13, 5.8 + breath*0.18, 3.8 + breath*0.15, 0.32, 0, Math.PI*2);
    X.fill();
    
    // Philtrum
    X.strokeStyle = 'rgba(0,0,0,0.18)';
    X.lineWidth = 1.6;
    X.beginPath();
    X.moveTo(0, ny + 37);
    X.lineTo(0, ny + 52);
    X.stroke();
    
    X.restore();
}

// Draw whiskers
function drawWhiskers() {
    const px = MOUSE.sx * 4;
    const py = MOUSE.sy * 4;
    const breath = Math.sin(T * 0.055);
    
    X.save();
    X.translate(px, py);
    X.strokeStyle = 'rgba(255,255,255,0.38)';
    X.lineWidth = 0.85;
    
    for (const side of [-1, 1]) {
        for (let i = 0; i < 10; i++) {
            const rx = side * (23 + (i % 3) * 5);
            const ry = 103 + (i % 4) * 4;
            const len = 42 + Math.random() * 38;
            const ang = (side === 1 ? 0 : Math.PI) + (i - 5) * 0.08;
            const wave = Math.sin(T * 0.04 + i) * 2 + breath * 2;
            
            X.globalAlpha = 0.2 + Math.random() * 0.22;
            X.beginPath();
            X.moveTo(rx, ry);
            X.bezierCurveTo(
                rx + side * len * 0.35, ry + wave,
                rx + side * len * 0.68, ry + 18 + wave,
                rx + Math.cos(ang) * len, ry + 28 + wave
            );
            X.stroke();
        }
    }
    X.globalAlpha = 1;
    X.restore();
}

// Main animation loop
function animate() {
    T++;
    
    // Smooth mouse
    MOUSE.sx += (MOUSE.x - MOUSE.sx) * 0.08;
    MOUSE.sy += (MOUSE.y - MOUSE.sy) * 0.08;
    
    // Random blink
    if (blink > 0) blink--;
    else if (Math.random() < 0.004) blink = 10;
    
    // Random ear twitch
    if (earTwitch.L > 0) earTwitch.L--;
    else if (Math.random() < 0.002) earTwitch.L = 8;
    if (earTwitch.R > 0) earTwitch.R--;
    else if (Math.random() < 0.002) earTwitch.R = 8;
    
    // Background
    const bg = X.createRadialGradient(0, -35, 12, 0, 25, 400);
    bg.addColorStop(0, '#080b0f');
    bg.addColorStop(0.4, '#040608');
    bg.addColorStop(1, '#000');
    X.fillStyle = bg;
    X.fillRect(-500, -500, 1000, 1000);
    
    const mx = MOUSE.sx * 18;
    const my = MOUSE.sy * 18;
    
    // Ears layer (deepest, inverse parallax + twitch)
    X.save();
    X.setTransform(1, 0, 0, 1, 0, 0);
    const earOffsetL = Math.sin(earTwitch.L / 8 * Math.PI) * 3;
    const earOffsetR = Math.sin(earTwitch.R / 8 * Math.PI) * 3;
    X.drawImage(LAYER_EARS, (-mx * 0.6 + earOffsetL * 0.5) * DPR, (-my * 0.6 - Math.abs(earOffsetL)) * DPR);
    X.restore();
    
    // Back layer (medium depth)
    X.save();
    X.setTransform(1, 0, 0, 1, 0, 0);
    X.drawImage(LAYER_BACK, -mx * 0.35 * DPR, -my * 0.35 * DPR);
    X.restore();
    
    // Face layer (closest, moves with mouse)
    X.save();
    X.setTransform(1, 0, 0, 1, 0, 0);
    X.drawImage(LAYER_FACE, mx * 0.15 * DPR, my * 0.15 * DPR);
    X.restore();
    
    // Dynamic features
    drawNose();
    drawEye(-54, -18, true);
    drawEye(54, -18, false);
    drawWhiskers();
    
    // Rim lights
    X.globalCompositeOperation = 'screen';
    const rl = X.createLinearGradient(-185, 0, -115, 0);
    rl.addColorStop(0, 'rgba(60,120,170,0.07)');
    rl.addColorStop(1, 'rgba(60,120,170,0)');
    X.fillStyle = rl;
    X.beginPath();
    X.ellipse(-150, -5, 40, 185, 0.025, 0, Math.PI*2);
    X.fill();
    
    const rr = X.createLinearGradient(185, 0, 115, 0);
    rr.addColorStop(0, 'rgba(170,140,105,0.04)');
    rr.addColorStop(1, 'rgba(170,140,105,0)');
    X.fillStyle = rr;
    X.beginPath();
    X.ellipse(150, -5, 40, 185, -0.025, 0, Math.PI*2);
    X.fill();
    X.globalCompositeOperation = 'source-over';
    
    // Vignette
    const vg = X.createRadialGradient(0, 0, S * 0.18, 0, 0, S * 0.48);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.55)');
    X.fillStyle = vg;
    X.fillRect(-S, -S, S*2, S*2);
    
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
