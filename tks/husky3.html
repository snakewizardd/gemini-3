<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PHYSIO_PAINTER | BIOLOGICAL RENDERING</title>
<style>
    body { margin: 0; background: #050505; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
    canvas { box-shadow: 0 0 50px rgba(0,0,0,0.5); }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
/**
 * PHYSIO_PAINTER v1.0
 * -------------------
 * A progressive rendering engine that layers "threads" based on biological depth.
 * * LAYERS:
 * 1. OSTEOLOGICAL MESH (Invisible Guide)
 * 2. THERMAL UNDERCOAT (Dense, Short, "Velvet")
 * 3. BOUNDARY LAYER (Long, Guard Hairs)
 * 4. SENSORY & OPTICAL (Vibrissae, Tapetum)
 */

const CONFIG = {
    // Increase for higher fidelity (may slow down render)
    DENSITY_MULTIPLIER: 1.5, 
    SCALE: 0.8
};

const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');

// High-DPI setup for "Thread" precision
const dpr = window.devicePixelRatio || 1;
const size = Math.min(window.innerWidth, window.innerHeight) * 0.95;
cvs.width = size * dpr;
cvs.height = size * dpr;
cvs.style.width = size + 'px';
cvs.style.height = size + 'px';
ctx.scale(dpr, dpr);
ctx.translate(size/2, size/2); // Center origin
ctx.scale(CONFIG.SCALE, CONFIG.SCALE);

// PALETTE (Thermodynamic & Optical)
const P = {
    VOID: '#0b0b0b',
    BONE_GUIDE: 'rgba(255,255,255,0.05)',
    UNDERCOAT_DARK: '#1a1c24', // Insulating base
    UNDERCOAT_LIGHT: '#e0e6ed', // Reflective base
    GUARD_TIP: '#ffffff',       // Snow camouflage
    NOSE_COLD: '#8c7b75',       // Tyrosinase inactive (Pinkish/Brown)
    NOSE_DARK: '#1a1a1a',       // Tyrosinase active
    TAPETUM: '#4ff',            // Retroreflector
    GLOW: 'rgba(0, 247, 255, 0.1)'
};

// ═══════════════════════════════════════════════════════════════
// THE THREAD ENGINE (Brush)
// ═══════════════════════════════════════════════════════════════
function paintThread(x, y, length, angle, width, color, opacity = 1.0) {
    ctx.beginPath();
    // Simulate hair taper (Root -> Tip)
    const tipX = x + Math.cos(angle) * length;
    const tipY = y + Math.sin(angle) * length;
    
    // Quadratic curve for natural "droop" or "curl"
    const cx = (x + tipX) / 2 + (Math.random() - 0.5) * (length * 0.2);
    const cy = (y + tipY) / 2 + (Math.random() - 0.5) * (length * 0.2);

    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(cx, cy, tipX, tipY);
    
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.globalAlpha = opacity;
    ctx.lineCap = 'round';
    ctx.stroke();
    ctx.globalAlpha = 1.0;
}

// ═══════════════════════════════════════════════════════════════
// THE RENDER QUEUE (Progressive Layering)
// ═══════════════════════════════════════════════════════════════
const QUEUE = [];

function queueTask(taskFn, count) {
    for(let i=0; i<count; i++) QUEUE.push(taskFn);
}

// Process the queue in chunks to allow the browser to paint
function processQueue() {
    const start = performance.now();
    while (QUEUE.length > 0 && performance.now() - start < 16) { // 16ms budget per frame
        const task = QUEUE.shift();
        task();
    }
    if (QUEUE.length > 0) requestAnimationFrame(processQueue);
}

// ═══════════════════════════════════════════════════════════════
// 1. OSTEOLOGICAL MAPPING (The Skull)
// ═══════════════════════════════════════════════════════════════
// We define "Zones" based on the Mesocephalic Skull
const ZONES = {
    EAR_L:  { x: -70, y: -160, r: 40, dir: -Math.PI/2 },
    EAR_R:  { x: 70,  y: -160, r: 40, dir: -Math.PI/2 },
    FOREHEAD: { x: 0, y: -80, r: 90, dir: -Math.PI/2 },
    CHEEK_L: { x: -80, y: 0, r: 60, dir: Math.PI },
    CHEEK_R: { x: 80, y: 0, r: 60, dir: 0 },
    MUZZLE: { x: 0, y: 50, r: 55, dir: Math.PI/2 }, // The Fulcrum
    CHIN:   { x: 0, y: 120, r: 40, dir: Math.PI/2 }
};

// ═══════════════════════════════════════════════════════════════
// 2. PAINTING ROUTINES (The Layers)
// ═══════════════════════════════════════════════════════════════

// LAYER A: THERMAL UNDERCOAT (Dense, Short, Velvet)
function paintUndercoat() {
    // Dark base (Skin/Shadow)
    queueTask(() => {
        ctx.fillStyle = P.UNDERCOAT_DARK;
        ctx.beginPath(); ctx.ellipse(0, 0, 160, 150, 0, 0, Math.PI*2); ctx.fill();
        // Ears
        ctx.beginPath(); ctx.moveTo(-50,-80); ctx.lineTo(-90,-200); ctx.lineTo(-10,-80); ctx.fill();
        ctx.beginPath(); ctx.moveTo(50,-80); ctx.lineTo(90,-200); ctx.lineTo(10,-80); ctx.fill();
    }, 1);

    // Thousands of short, dense hairs
    const count = 15000 * CONFIG.DENSITY_MULTIPLIER;
    queueTask(() => {
        // Stochastic sampling of the skull shape
        let x, y, dist;
        do {
            x = (Math.random() - 0.5) * 400;
            y = (Math.random() - 0.5) * 400;
            dist = Math.sqrt(x*x + y*y);
        } while (dist > 160); // Clip to head radius

        // Color logic (The "Mask" pattern)
        let color = P.UNDERCOAT_LIGHT;
        // Widow's peak / Cap logic
        if (y < -30 && Math.abs(x) < 50 + (y*-0.5)) color = P.UNDERCOAT_DARK; 
        if (y < -80) color = P.UNDERCOAT_DARK;

        const len = 10 + Math.random() * 10;
        const angle = Math.atan2(y - (-50), x) + (Math.random()-0.5); // Radiate from center face

        paintThread(x, y, len, angle, 2.5, color, 0.8);
    }, count);
}

// LAYER B: BOUNDARY LAYER (Guard Hairs)
function paintGuardHairs() {
    const count = 8000 * CONFIG.DENSITY_MULTIPLIER;
    queueTask(() => {
        let x = (Math.random() - 0.5) * 360;
        let y = (Math.random() - 0.5) * 360;
        
        // Define flow maps based on Myology
        let angle = Math.PI / 2; // Default down
        let color = P.GUARD_TIP;
        let valid = false;

        // Ear Tufts (Auricular)
        if (y < -120 && Math.abs(x) > 30 && Math.abs(x) < 100) {
            angle = -Math.PI / 2 + (x > 0 ? 0.2 : -0.2);
            color = P.UNDERCOAT_DARK;
            valid = true;
        }
        // Cheek Ruffs (Zygomatic)
        else if (y > 0 && Math.abs(x) > 60 && Math.abs(x) < 170) {
            angle = Math.atan2(y, x); // Radial outward
            valid = true;
        }
        // Muzzle Velvet (Short, dense)
        else if (y > 20 && y < 100 && Math.abs(x) < 50) {
            angle = Math.PI/2 + (x * 0.01);
            // Muzzle is cleaner/shorter
            if (Math.random() > 0.8) valid = true; // Less guard hair here
        }
        // Forehead
        else if (y < 0 && Math.abs(x) < 150) {
             angle = Math.PI * 1.5;
             if (Math.abs(x) < 40 && y < -50) color = '#2a2a2a'; // Dark cap
             valid = true;
        }

        if (valid) {
            const len = 25 + Math.random() * 30; // Longer guard hairs
            paintThread(x, y, len, angle, 0.8, color, 0.6);
        }
    }, count);
}

// LAYER C: THERMODYNAMICS (The Snow Nose)
function paintSnowNose() {
    queueTask(() => {
        const nx = 0, ny = 110;
        
        // Base pad
        ctx.fillStyle = P.NOSE_DARK;
        ctx.beginPath();
        ctx.moveTo(-25, ny); 
        ctx.quadraticCurveTo(0, ny-10, 25, ny);
        ctx.quadraticCurveTo(0, ny+35, -25, ny);
        ctx.fill();

        // Tyrosinase Effect (Hypopigmentation stripe)
        // Stippling texture
        for(let i=0; i<300; i++) {
            const r = Math.random() * 15;
            const theta = Math.random() * Math.PI * 2;
            const px = nx + Math.cos(theta) * r;
            const py = ny + 10 + Math.sin(theta) * r * 0.6;
            
            ctx.fillStyle = P.NOSE_COLD;
            ctx.globalAlpha = 0.6;
            ctx.beginPath(); ctx.arc(px, py, 1.5, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1.0;
    }, 1);
}

// LAYER D: OPTICS (The Eyes & Tapetum)
function paintEyes() {
    queueTask(() => {
        const drawEye = (x, y) => {
            // 1. Orbicularis Oculi (The Shutter/Eyelids)
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(x < 0 ? 0.15 : -0.15); // Slant

            // 2. Sclera/Shadow
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.ellipse(0, 0, 28, 16, 0, 0, Math.PI*2); ctx.fill();

            // 3. Iris (Blue)
            const grad = ctx.createRadialGradient(0,0, 5, 0,0, 12);
            grad.addColorStop(0, '#8ff');
            grad.addColorStop(1, '#009');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); ctx.fill();

            // 4. Tapetum Lucidum (The Glow)
            ctx.shadowBlur = 15;
            ctx.shadowColor = P.TAPETUM;
            ctx.fillStyle = '#fff'; // Pupil reflection
            ctx.beginPath(); ctx.ellipse(0, 0, 4, 12, 0, 0, Math.PI*2); // Slit-like pupil focus
            ctx.fill();
            ctx.shadowBlur = 0;

            // 5. Cornea Reflection (Wetness)
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath(); ctx.arc(4, -4, 3, 0, Math.PI*2); ctx.fill();

            ctx.restore();
        }
        drawEye(-55, -10);
        drawEye(55, -10);
    }, 1);
}

// LAYER E: SENSORY (Vibrissae)
function paintVibrissae() {
    queueTask(() => {
        // Mystacial Vibrissae (Muzzle)
        for(let side of [-1, 1]) {
            for(let i=0; i<15; i++) {
                const ox = side * (35 + Math.random()*10);
                const oy = 100 + (Math.random()*20);
                const len = 80 + Math.random()*40;
                const angle = (side === 1 ? 0 : Math.PI) + (Math.random()-0.5)*0.5;
                
                // Whiskers are thick at root, taper to nothing
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.quadraticCurveTo(ox + side*len*0.5, oy + 20, ox + Math.cos(angle)*len, oy + Math.sin(angle)*len);
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 1.5; // Thicker root
                ctx.stroke();
            }
        }
        // Superciliary Vibrissae (Above eyes)
        for(let side of [-1, 1]) {
            for(let i=0; i<3; i++) {
                const ox = side * 40;
                const oy = -60;
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.lineTo(ox + side*30, oy - 40);
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
    }, 1);
}

// ═══════════════════════════════════════════════════════════════
// INITIALIZATION
// ═══════════════════════════════════════════════════════════════
// Clear void
ctx.fillStyle = P.VOID;
ctx.fillRect(-size, -size, size*2, size*2);

// Background Atmosphere (Zen Glow)
const bg = ctx.createRadialGradient(0, 0, 100, 0, 0, size/1.5);
bg.addColorStop(0, '#1a202c');
bg.addColorStop(1, '#000000');
ctx.fillStyle = bg;
ctx.fillRect(-size, -size, size*2, size*2);

// Schedule the painting
paintUndercoat();
paintGuardHairs();
paintSnowNose();
paintEyes();
paintVibrissae();

// Start the engine
processQueue();

</script>
</body>
</html>