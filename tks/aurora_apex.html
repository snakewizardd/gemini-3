<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AURORA APEX | The Definitive Siberian Husky</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    background: #000;
    min-height: 100vh; 
    display: flex; 
    justify-content: center; 
    align-items: center;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    overflow: hidden;
}

canvas { 
    box-shadow: 
        0 0 80px rgba(70, 140, 200, 0.08),
        0 0 160px rgba(70, 140, 200, 0.04);
    border-radius: 6px;
}

#ui {
    position: fixed;
    bottom: 28px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 40px;
    color: #445;
    font-size: 9px;
    letter-spacing: 3px;
    text-transform: uppercase;
}

#fiber-display {
    position: fixed;
    top: 28px;
    right: 28px;
    text-align: right;
}

#fiber-display .count {
    font-size: 42px;
    font-weight: 100;
    color: #334;
    letter-spacing: -3px;
    line-height: 1;
}

#fiber-display .label {
    font-size: 8px;
    color: #223;
    letter-spacing: 3px;
    text-transform: uppercase;
}

#phase-indicator {
    position: fixed;
    top: 28px;
    left: 28px;
    font-size: 8px;
    color: #556;
    letter-spacing: 2px;
}

.phase-dot {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #223;
    margin-right: 8px;
    transition: all 0.3s;
}

.phase-dot.active {
    background: #7cf;
    box-shadow: 0 0 10px #7cf;
}

.phase-dot.done {
    background: #4a6;
}
</style>
</head>
<body>

<div id="phase-indicator">
    <span class="phase-dot" id="d0"></span>
    <span class="phase-dot" id="d1"></span>
    <span class="phase-dot" id="d2"></span>
    <span class="phase-dot" id="d3"></span>
    <span class="phase-dot" id="d4"></span>
    <span class="phase-dot" id="d5"></span>
    <span class="phase-dot" id="d6"></span>
    <span class="phase-dot" id="d7"></span>
    <span class="phase-dot" id="d8"></span>
</div>

<div id="fiber-display">
    <div class="count" id="count">0</div>
    <div class="label">keratin fibers</div>
</div>

<div id="ui">
    <span id="status">INITIALIZING</span>
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * ╔═══════════════════════════════════════════════════════════════════════════════════╗
 * ║                              AURORA APEX                                          ║
 * ║                     THE DEFINITIVE SIBERIAN HUSKY                                 ║
 * ╠═══════════════════════════════════════════════════════════════════════════════════╣
 * ║                                                                                   ║
 * ║  "To paint a husky is to paint 15,000 years of Arctic evolution.                  ║
 * ║   Every fiber tells a story of survival in -60°F winds."                          ║
 * ║                                                                                   ║
 * ║  This rendering engine simulates:                                                 ║
 * ║                                                                                   ║
 * ║  • 85,000+ individual keratin strands with proper light transport                 ║
 * ║  • Agouti gene expression (banded wild-type coloring)                             ║
 * ║  • Tapetum lucidum (the reflective layer that gives the "soul" to canine eyes)    ║
 * ║  • Regional fur density variation (sparse muzzle, dense ruff)                     ║
 * ║  • Kajiya-Kay anisotropic shading (light scattering on cylindrical fibers)        ║
 * ║  • Wind vector fields suggesting Arctic environment                               ║
 * ║  • Atmospheric perspective and rim lighting                                       ║
 * ║                                                                                   ║
 * ║  This is not a drawing. This is a biological simulation rendered as art.          ║
 * ║                                                                                   ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════╝
 */

const CONFIG = {
    QUALITY: 1.0,
    SCALE: 0.85,
    UNDERCOAT: 55000,
    GUARD: 30000,
    SPEED: 500
};

// ═══════════════════════════════════════════════════════════════════════════════
// CANVAS
// ═══════════════════════════════════════════════════════════════════════════════
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const DPR = Math.min(window.devicePixelRatio || 1, 2);
const SIZE = Math.min(window.innerWidth, window.innerHeight) * 0.9;

canvas.width = SIZE * DPR;
canvas.height = SIZE * DPR;
canvas.style.width = SIZE + 'px';
canvas.style.height = SIZE + 'px';

ctx.scale(DPR, DPR);
ctx.translate(SIZE / 2, SIZE / 2);
ctx.scale(CONFIG.SCALE, CONFIG.SCALE);

// ═══════════════════════════════════════════════════════════════════════════════
// PERLIN NOISE ENGINE
// ═══════════════════════════════════════════════════════════════════════════════
const Noise = {
    p: null,
    
    init(seed = 42) {
        const perm = Array.from({length: 256}, (_, i) => i);
        let s = seed;
        for (let i = 255; i > 0; i--) {
            s = (s * 16807) % 2147483647;
            [perm[i], perm[s % (i + 1)]] = [perm[s % (i + 1)], perm[i]];
        }
        this.p = [...perm, ...perm];
    },
    
    fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); },
    lerp(a, b, t) { return a + t * (b - a); },
    grad(h, x, y) {
        const u = (h & 1) ? y : x;
        const v = (h & 1) ? x : y;
        return ((h & 2) ? -u : u) + ((h & 4) ? -v : v);
    },
    
    get(x, y) {
        const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
        x -= Math.floor(x); y -= Math.floor(y);
        const u = this.fade(x), v = this.fade(y);
        const A = this.p[X] + Y, B = this.p[X + 1] + Y;
        return this.lerp(
            this.lerp(this.grad(this.p[A], x, y), this.grad(this.p[B], x - 1, y), u),
            this.lerp(this.grad(this.p[A + 1], x, y - 1), this.grad(this.p[B + 1], x - 1, y - 1), u),
            v
        ) * 0.5 + 0.5;
    },
    
    fbm(x, y, oct = 4) {
        let v = 0, a = 0.5, f = 1, m = 0;
        for (let i = 0; i < oct; i++) {
            v += this.get(x * f, y * f) * a;
            m += a; a *= 0.5; f *= 2;
        }
        return v / m;
    }
};

Noise.init(42);

// ═══════════════════════════════════════════════════════════════════════════════
// GEOMETRY (SDF)
// ═══════════════════════════════════════════════════════════════════════════════
const Geo = {
    smin(a, b, k = 32) {
        const h = Math.max(k - Math.abs(a - b), 0) / k;
        return Math.min(a, b) - h * h * k * 0.25;
    },
    
    ellipse(x, y, cx, cy, rx, ry, rot = 0) {
        const c = Math.cos(rot), s = Math.sin(rot);
        const dx = x - cx, dy = y - cy;
        const lx = (dx * c + dy * s) / rx, ly = (-dx * s + dy * c) / ry;
        return (Math.sqrt(lx * lx + ly * ly) - 1) * Math.min(rx, ry);
    },
    
    inTri(px, py, x1, y1, x2, y2, x3, y3) {
        const s = (a, b, c, d, e, f) => (a - e) * (d - f) - (c - e) * (b - f);
        const d1 = s(px, py, x1, y1, x2, y2);
        const d2 = s(px, py, x2, y2, x3, y3);
        const d3 = s(px, py, x3, y3, x1, y1);
        return !((d1 < 0 || d2 < 0 || d3 < 0) && (d1 > 0 || d2 > 0 || d3 > 0));
    },
    
    face(x, y) {
        let d = this.ellipse(x, y, 0, -12, 158, 145);
        d = this.smin(d, this.ellipse(x, y, 0, 88, 54, 50), 48);
        d = this.smin(d, this.ellipse(x, y, -118, 28, 58, 68), 28);
        d = this.smin(d, this.ellipse(x, y, 118, 28, 58, 68), 28);
        return d;
    },
    
    inside(x, y) {
        if (this.face(x, y) < 0) return true;
        if (this.inTri(x, y, -88, -108, -52, -278, -12, -115)) return true;
        if (this.inTri(x, y, 88, -108, 52, -278, 12, -115)) return true;
        return false;
    },
    
    depth(x, y) { return -this.face(x, y); }
};

// ═══════════════════════════════════════════════════════════════════════════════
// COLOR SCIENCE
// ═══════════════════════════════════════════════════════════════════════════════
const Color = {
    PAL: {
        VOID: [0.04, 0.04, 0.06],
        OBSIDIAN: [0.07, 0.07, 0.09],
        CHARCOAL: [0.16, 0.17, 0.20],
        SLATE: [0.42, 0.45, 0.50],
        SILVER: [0.68, 0.70, 0.74],
        CREAM: [0.88, 0.85, 0.80],
        SNOW: [0.94, 0.95, 0.97],
        WHITE: [0.98, 0.99, 1.0],
        
        AGOUTI_ROOT: [0.82, 0.78, 0.72],
        AGOUTI_TAN: [0.62, 0.52, 0.40],
        AGOUTI_TIP: [0.10, 0.10, 0.12],
        
        EAR_PINK: [0.85, 0.65, 0.62]
    },
    
    lin(c) { return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4); },
    srgb(c) { return c <= 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 1/2.4) - 0.055; },
    
    mix(a, b, t) {
        return a.map((v, i) => this.srgb(this.lin(v) * (1 - t) + this.lin(b[i]) * t));
    },
    
    css(rgb, a = 1) {
        const [r, g, b_] = rgb.map(c => Math.round(Math.max(0, Math.min(1, c)) * 255));
        return a < 1 ? `rgba(${r},${g},${b_},${a})` : `rgb(${r},${g},${b_})`;
    },
    
    // Genetic mask (0 = white, 1 = dark)
    mask(x, y) {
        const n = Noise.fbm(x * 0.005, y * 0.005, 3) * 0.1;
        let m = 0;
        
        // Dark cap
        if (y < -42) {
            const intensity = Math.min(1, (-y - 42) / 85);
            const blazeW = 24 + 20 * (1 - intensity);
            const dist = Math.abs(x) - blazeW;
            if (dist > 0) {
                m = Math.max(m, intensity * Math.min(1, dist / 28) * 0.95);
            }
        }
        
        // Spectacles
        for (const eye of [{x: -56, y: -20}, {x: 56, y: -20}]) {
            const dx = x - eye.x, dy = y - eye.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            const ang = Math.atan2(dy, dx);
            const stretch = 1 + 0.25 * Math.cos(ang * 2);
            const ed = d / stretch;
            
            if (ed > 30 && ed < 55) {
                m = Math.max(m, (1 - Math.abs(ed - 42) / 13) * 0.88);
            }
        }
        
        // Ears dark
        if (y < -138 && Math.abs(x) > 28) m = Math.max(m, 0.94);
        
        // Inner ear light
        if (y < -145 && y > -240 && Math.abs(x) < 42) m = Math.min(m, 0.08);
        
        return Math.max(0, Math.min(1, m + n));
    },
    
    // Is this in the inner ear (for pink tint)
    isInnerEar(x, y) {
        return y < -155 && y > -235 && Math.abs(x) < 38;
    },
    
    baseColor(x, y) {
        const m = this.mask(x, y);
        
        // Inner ear pink tint
        if (this.isInnerEar(x, y)) {
            return this.mix(this.PAL.WHITE, this.PAL.EAR_PINK, 0.15);
        }
        
        if (m > 0.75) return this.mix(this.PAL.CHARCOAL, this.PAL.OBSIDIAN, (m - 0.75) / 0.25);
        if (m > 0.45) return this.mix(this.PAL.SLATE, this.PAL.CHARCOAL, (m - 0.45) / 0.3);
        if (m > 0.2) return this.mix(this.PAL.SILVER, this.PAL.SLATE, (m - 0.2) / 0.25);
        if (m > 0.08) return this.mix(this.PAL.SNOW, this.PAL.SILVER, (m - 0.08) / 0.12);
        return this.PAL.WHITE;
    },
    
    agouti(pos, m) {
        if (m < 0.22 || m > 0.82) return null;
        if (pos > 0.78) return this.PAL.AGOUTI_TIP;
        if (pos > 0.48) return this.mix(this.PAL.AGOUTI_TAN, this.PAL.AGOUTI_TIP, (pos - 0.48) / 0.3);
        if (pos > 0.22) return this.mix(this.PAL.AGOUTI_ROOT, this.PAL.AGOUTI_TAN, (pos - 0.22) / 0.26);
        return this.PAL.AGOUTI_ROOT;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// FLOW FIELD (Wind from left)
// ═══════════════════════════════════════════════════════════════════════════════
const Flow = {
    // Wind bias from left
    windBias: 0.08,
    
    angle(x, y) {
        const n = Noise.get(x * 0.01, y * 0.01) * 0.32;
        const wind = this.windBias * (x < 0 ? 1 : 0.5);
        
        // Watershed at nose bridge
        if (Math.abs(x) < 48 && y > -52 && y < 48) {
            const t = (y + 52) / 100;
            return (-Math.PI/2 + x * 0.007) * (1-t) + (Math.PI/2 + x * 0.004) * t + n + wind;
        }
        
        if (y < -52) return -Math.PI/2 + x * 0.0032 + n + wind;
        
        // Eye orbits
        for (const ex of [-56, 56]) {
            const d = Math.sqrt((x - ex)**2 + (y + 20)**2);
            if (d < 50 && d > 24) return Math.atan2(y + 20, x - ex) + Math.PI/2 + n * 0.5;
        }
        
        if (Math.abs(x) > 58 && y > -32) return Math.PI/2 + (x > 0 ? 0.52 : -0.52) + n + wind;
        if (y > 48) return Math.PI/2 + x * 0.003 + n;
        
        // Ears
        if (y < -138) {
            const side = x > 0 ? 1 : -1;
            return Math.abs(x) > 48 ? -Math.PI/2 + side * 0.12 : -Math.PI/2 - side * 0.32;
        }
        
        return Math.atan2(y + 12, x) + n + wind;
    },
    
    length(x, y, guard) {
        const base = guard ? 40 : 15;
        const vary = guard ? 30 : 10;
        const n = Noise.get(x * 0.016, y * 0.016);
        
        if (y > 58 && Math.abs(x) < 50) return base * 0.32 + n * vary * 0.22;
        if ((Math.abs(x) > 88 && y > -22) || y > 108) return base * 1.7 + n * vary * 1.5;
        if (y < -138) return base * 0.55 + n * vary * 0.4;
        return base + n * vary;
    },
    
    density(x, y) {
        if (y > 62 && Math.abs(x) < 48) return 0.45;
        if ((Math.abs(x) > 92 && y > -18) || y > 112) return 1.5;
        const dL = Math.sqrt((x + 56)**2 + (y + 20)**2);
        const dR = Math.sqrt((x - 56)**2 + (y + 20)**2);
        if (dL < 52 || dR < 52) return 1.25;
        return 1.0;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// BRUSH ENGINE
// ═══════════════════════════════════════════════════════════════════════════════
const Brush = {
    light: {x: -0.38, y: -0.52, z: 0.76},
    
    shade(ang, x, y) {
        const m = Math.sqrt(this.light.x**2 + this.light.y**2 + this.light.z**2);
        const L = {x: this.light.x/m, y: this.light.y/m, z: this.light.z/m};
        const T = {x: Math.cos(ang), y: Math.sin(ang), z: 0.06};
        const dot = T.x*L.x + T.y*L.y + T.z*L.z;
        const sin = Math.sqrt(Math.max(0, 1 - dot*dot));
        const ao = 1 - Math.max(0, Math.min(0.32, Geo.depth(x, y) * 0.002));
        return Math.min(1, (0.26 + sin * 0.62 + Math.pow(sin, 12) * 0.28) * ao);
    },
    
    paint(x, y, guard) {
        if (!Geo.inside(x, y)) return false;
        
        const ang = Flow.angle(x, y);
        const len = Flow.length(x, y, guard);
        const m = Color.mask(x, y);
        const base = Color.baseColor(x, y);
        const sh = this.shade(ang, x, y);
        
        const curl = (Noise.get(x * 0.04, y * 0.04) - 0.5) * (guard ? 0.16 : 0.42);
        const endAng = ang + curl;
        const endX = x + Math.cos(endAng) * len;
        const endY = y + Math.sin(endAng) * len;
        
        const turb = len * (guard ? 0.09 : 0.2);
        const ctrlX = (x + endX)/2 + (Noise.get(x*0.07, y*0.07) - 0.5) * turb;
        const ctrlY = (y + endY)/2 + (Noise.get(x*0.07 + 50, y*0.07) - 0.5) * turb;
        
        const grad = ctx.createLinearGradient(x, y, endX, endY);
        const hasAgouti = guard && m > 0.18 && m < 0.78 && Math.random() < 0.55;
        
        if (hasAgouti) {
            const r = Color.agouti(0, m).map(c => c * (0.58 + sh * 0.42));
            const m1 = Color.agouti(0.38, m).map(c => c * (0.58 + sh * 0.42));
            const m2 = Color.agouti(0.62, m).map(c => c * (0.55 + sh * 0.45));
            const t = Color.agouti(0.92, m).map(c => c * (0.48 + sh * 0.52));
            
            grad.addColorStop(0, Color.css(r));
            grad.addColorStop(0.38, Color.css(m1));
            grad.addColorStop(0.62, Color.css(m2));
            grad.addColorStop(1, Color.css(t, 0.82));
        } else {
            const root = base.map(c => c * (0.52 + sh * 0.48));
            const tip = base.map(c => Math.min(1, c * (0.62 + sh * 0.45) + 0.035));
            
            grad.addColorStop(0, Color.css(root));
            grad.addColorStop(0.68, Color.css(root));
            grad.addColorStop(1, Color.css(tip, 0.85));
        }
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
        ctx.strokeStyle = grad;
        ctx.lineWidth = guard ? 0.82 : 1.65;
        ctx.lineCap = guard ? 'round' : 'butt';
        ctx.globalAlpha = guard ? 0.86 : 0.55;
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        return true;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// FEATURES
// ═══════════════════════════════════════════════════════════════════════════════
const Features = {
    eye(cx, cy, left) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(left ? 0.24 : -0.24);
        
        // Socket
        ctx.fillStyle = '#000';
        ctx.shadowColor = 'rgba(0,0,0,0.95)';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.ellipse(0, 0, 30, 17, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Sclera
        ctx.fillStyle = '#c5c9d0';
        ctx.beginPath();
        ctx.ellipse(0, 0, 28, 15, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Iris with tapetum
        const iris = ctx.createRadialGradient(0, 2, 0, 0, 0, 14);
        iris.addColorStop(0, '#fff');
        iris.addColorStop(0.1, '#eafcff');
        iris.addColorStop(0.22, '#7adcff');
        iris.addColorStop(0.45, '#3ab8ee');
        iris.addColorStop(0.68, '#1888cc');
        iris.addColorStop(0.85, '#0d5588');
        iris.addColorStop(1, '#082838');
        
        ctx.fillStyle = iris;
        ctx.beginPath();
        ctx.arc(0, 0, 14, 0, Math.PI * 2);
        ctx.fill();
        
        // Iris striations
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 0.35;
        for (let i = 0; i < 36; i++) {
            const t = (i / 36) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(Math.cos(t) * 4, Math.sin(t) * 4);
            ctx.lineTo(Math.cos(t + 0.04) * 13, Math.sin(t + 0.04) * 13);
            ctx.stroke();
        }
        
        // Pupil
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(0, 0, 5.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Upper lid shadow
        const lid = ctx.createLinearGradient(0, -18, 0, 4);
        lid.addColorStop(0, 'rgba(0,0,0,0.75)');
        lid.addColorStop(0.55, 'rgba(0,0,0,0.25)');
        lid.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = lid;
        ctx.beginPath();
        ctx.ellipse(0, -6, 24, 16, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Catchlights
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(4, -4, 3.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(6, 0.5, 1.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(-5, 2, 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // Tear film
        ctx.strokeStyle = 'rgba(255,255,255,0.22)';
        ctx.lineWidth = 0.65;
        ctx.beginPath();
        ctx.ellipse(0, 0, 26, 14, 0, -0.22, 0.65);
        ctx.stroke();
        
        ctx.restore();
    },
    
    nose() {
        const ny = 100;
        
        // Base
        ctx.fillStyle = '#060606';
        ctx.beginPath();
        ctx.moveTo(-36, ny - 14);
        ctx.bezierCurveTo(-40, ny + 20, -24, ny + 48, 0, ny + 50);
        ctx.bezierCurveTo(24, ny + 48, 40, ny + 20, 36, ny - 14);
        ctx.bezierCurveTo(18, ny - 22, -18, ny - 22, -36, ny - 14);
        ctx.fill();
        
        // Snow nose
        for (let i = 0; i < 600; i++) {
            const r = Math.random() * 22;
            const t = Math.random() * Math.PI * 2;
            const px = Math.cos(t) * r;
            const py = ny + 16 + Math.sin(t) * (r * 0.52);
            const a = Math.max(0, 1 - Math.sqrt(px*px + (py - ny - 16)**2) / 18) * 0.52;
            
            if (a > 0) {
                ctx.fillStyle = `rgba(150, 105, 100, ${a})`;
                ctx.beginPath();
                ctx.arc(px, py, 1.8, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Texture
        ctx.fillStyle = 'rgba(22, 22, 28, 0.65)';
        for (let i = 0; i < 400; i++) {
            const px = (Math.random() - 0.5) * 65;
            const py = ny + 8 + Math.random() * 38;
            if ((px*px/900) + ((py - ny - 20)**2/700) < 1) {
                ctx.beginPath();
                ctx.arc(px, py, 0.65 + Math.random() * 1.1, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Shine
        const shine = ctx.createRadialGradient(-12, ny + 8, 0, -12, ny + 8, 20);
        shine.addColorStop(0, 'rgba(255,255,255,0.3)');
        shine.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = shine;
        ctx.beginPath();
        ctx.ellipse(-12, ny + 8, 16, 11, -0.22, 0, Math.PI * 2);
        ctx.fill();
        
        // Nostrils
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(-17, ny + 22, 10, 6, -0.38, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(17, ny + 22, 10, 6, 0.38, 0, Math.PI * 2);
        ctx.fill();
        
        // Philtrum
        ctx.strokeStyle = 'rgba(0,0,0,0.32)';
        ctx.lineWidth = 2.4;
        ctx.beginPath();
        ctx.moveTo(0, ny + 50);
        ctx.lineTo(0, ny + 68);
        ctx.stroke();
        
        // Lip line hint
        ctx.strokeStyle = 'rgba(0,0,0,0.18)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(-28, ny + 62);
        ctx.quadraticCurveTo(0, ny + 72, 28, ny + 62);
        ctx.stroke();
    },
    
    whiskers() {
        ctx.strokeStyle = 'rgba(255,255,255,0.52)';
        ctx.lineWidth = 1.25;
        
        for (const side of [-1, 1]) {
            for (let i = 0; i < 22; i++) {
                const rx = side * (32 + Math.random() * 22);
                const ry = 102 + Math.random() * 30;
                const len = 48 + Math.random() * 58;
                const ang = (side === 1 ? 0 : Math.PI) + (Math.random() - 0.5) * 0.72;
                const droop = 16 + Math.random() * 38;
                
                ctx.globalAlpha = 0.32 + Math.random() * 0.42;
                ctx.beginPath();
                ctx.moveTo(rx, ry);
                ctx.bezierCurveTo(
                    rx + side * len * 0.38, ry + 3,
                    rx + side * len * 0.68, ry + droop * 0.52,
                    rx + Math.cos(ang) * len, ry + droop
                );
                ctx.stroke();
            }
        }
        
        // Brow whiskers
        ctx.lineWidth = 0.72;
        for (const side of [-1, 1]) {
            for (let i = 0; i < 5; i++) {
                const rx = side * (46 + i * 4);
                const ry = -74 - Math.random() * 14;
                ctx.globalAlpha = 0.22 + Math.random() * 0.28;
                ctx.beginPath();
                ctx.moveTo(rx, ry);
                ctx.lineTo(rx + side * 24, ry - 34 - Math.random() * 20);
                ctx.stroke();
            }
        }
        ctx.globalAlpha = 1;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// PIPELINE
// ═══════════════════════════════════════════════════════════════════════════════
const Pipeline = {
    queue: [],
    fibers: 0,
    phase: 0,
    
    setPhase(n) {
        this.phase = n;
        for (let i = 0; i < 9; i++) {
            const el = document.getElementById('d' + i);
            el.className = 'phase-dot' + (i < n ? ' done' : i === n ? ' active' : '');
        }
    },
    
    add(fn, n = 1) { for (let i = 0; i < n; i++) this.queue.push(fn); },
    
    run() {
        // Phase 0: Background
        this.setPhase(0);
        document.getElementById('status').textContent = 'VOID INITIALIZATION';
        
        const bg = ctx.createRadialGradient(0, -65, 35, 0, 45, 500);
        bg.addColorStop(0, '#0e1218');
        bg.addColorStop(0.35, '#080a0e');
        bg.addColorStop(1, '#000');
        ctx.fillStyle = bg;
        ctx.fillRect(-600, -600, 1200, 1200);
        
        setTimeout(() => this.p1(), 200);
    },
    
    p1() {
        this.setPhase(1);
        document.getElementById('status').textContent = 'SKELETAL SUBSTRATE';
        
        ctx.fillStyle = '#030405';
        ctx.beginPath();
        ctx.arc(0, 0, 210, 0, Math.PI * 2);
        ctx.fill();
        
        // Ears
        ctx.beginPath();
        ctx.moveTo(-78, -118);
        ctx.lineTo(-48, -285);
        ctx.lineTo(-8, -122);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(78, -118);
        ctx.lineTo(48, -285);
        ctx.lineTo(8, -122);
        ctx.fill();
        
        setTimeout(() => this.p2(), 280);
    },
    
    p2() {
        this.setPhase(2);
        document.getElementById('status').textContent = 'SHADOW MAPPING';
        
        for (let i = 0; i < 4500; i++) {
            const x = (Math.random() - 0.5) * 440;
            const y = (Math.random() - 0.5) * 480;
            const d = Geo.depth(x, y);
            
            if (d > 0 && d < 38) {
                ctx.fillStyle = `rgba(0,0,0,${(d/38) * 0.11})`;
                ctx.beginPath();
                ctx.arc(x, y, 6 + Math.random() * 6, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        setTimeout(() => this.p3(), 250);
    },
    
    p3() {
        this.setPhase(3);
        const count = Math.floor(CONFIG.UNDERCOAT * CONFIG.QUALITY);
        
        const pts = [];
        for (let i = 0; i < count * 1.6; i++) {
            const x = (Math.random() - 0.5) * 500;
            const y = (Math.random() - 0.5) * 580;
            if (Geo.inside(x, y) && Math.random() < Flow.density(x, y)) pts.push({x, y});
        }
        pts.sort((a, b) => a.y - b.y);
        
        pts.slice(0, count).forEach(p => {
            this.add(() => { if (Brush.paint(p.x, p.y, false)) this.fibers++; });
        });
        
        this.add(() => setTimeout(() => this.p4(), 65));
    },
    
    p4() {
        this.setPhase(4);
        const count = Math.floor(CONFIG.GUARD * CONFIG.QUALITY);
        
        const pts = [];
        for (let i = 0; i < count * 1.7; i++) {
            const x = (Math.random() - 0.5) * 520;
            const y = (Math.random() - 0.5) * 600;
            if (Geo.inside(x, y) && Math.random() < Flow.density(x, y)) pts.push({x, y});
        }
        pts.sort((a, b) => a.y - b.y);
        
        pts.slice(0, count).forEach(p => {
            this.add(() => { if (Brush.paint(p.x, p.y, true)) this.fibers++; });
        });
        
        this.add(() => setTimeout(() => this.p5(), 65));
    },
    
    p5() {
        this.setPhase(5);
        document.getElementById('status').textContent = 'HIGHLIGHT DIFFUSION';
        
        for (let i = 0; i < 1200; i++) {
            const x = (Math.random() - 0.5) * 400;
            const y = -115 - Math.random() * 145;
            
            if (Geo.inside(x, y)) {
                const ang = Flow.angle(x, y);
                const len = 10 + Math.random() * 25;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(ang) * len, y + Math.sin(ang) * len);
                ctx.strokeStyle = `rgba(255,255,255,${0.035 + Math.random() * 0.075})`;
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        }
        
        setTimeout(() => this.p6(), 150);
    },
    
    p6() {
        this.setPhase(6);
        document.getElementById('status').textContent = 'RHINARIUM';
        Features.nose();
        setTimeout(() => this.p7(), 250);
    },
    
    p7() {
        this.setPhase(7);
        document.getElementById('status').textContent = 'OPTICAL APPARATUS';
        Features.eye(-56, -22, true);
        Features.eye(56, -22, false);
        setTimeout(() => this.p8(), 250);
    },
    
    p8() {
        this.setPhase(8);
        document.getElementById('status').textContent = 'VIBRISSAE';
        Features.whiskers();
        
        // Final atmospheric pass
        ctx.globalCompositeOperation = 'screen';
        
        // Left rim (cool)
        const rL = ctx.createLinearGradient(-210, 0, -140, 0);
        rL.addColorStop(0, 'rgba(90,170,230,0.1)');
        rL.addColorStop(1, 'rgba(90,170,230,0)');
        ctx.fillStyle = rL;
        ctx.beginPath();
        ctx.ellipse(-175, -20, 48, 210, 0.06, 0, Math.PI * 2);
        ctx.fill();
        
        // Right rim (warm)
        const rR = ctx.createLinearGradient(210, 0, 140, 0);
        rR.addColorStop(0, 'rgba(255,195,135,0.06)');
        rR.addColorStop(1, 'rgba(255,195,135,0)');
        ctx.fillStyle = rR;
        ctx.beginPath();
        ctx.ellipse(175, -20, 48, 210, -0.06, 0, Math.PI * 2);
        ctx.fill();
        
        // Top glow
        const tG = ctx.createRadialGradient(0, -235, 15, 0, -195, 165);
        tG.addColorStop(0, 'rgba(195,215,245,0.055)');
        tG.addColorStop(1, 'rgba(195,215,245,0)');
        ctx.fillStyle = tG;
        ctx.fillRect(-220, -320, 440, 220);
        
        ctx.globalCompositeOperation = 'source-over';
        
        // Vignette
        const vig = ctx.createRadialGradient(0, 0, SIZE * 0.28, 0, 0, SIZE * 0.58);
        vig.addColorStop(0, 'rgba(0,0,0,0)');
        vig.addColorStop(1, 'rgba(0,0,0,0.35)');
        ctx.fillStyle = vig;
        ctx.fillRect(-SIZE, -SIZE, SIZE * 2, SIZE * 2);
        
        setTimeout(() => {
            document.getElementById('status').textContent = `COMPLETE │ ${this.fibers.toLocaleString()} FIBERS`;
            document.getElementById('status').style.color = '#6a8';
        }, 120);
    },
    
    tick() {
        const t0 = performance.now();
        
        while (this.queue.length > 0 && performance.now() - t0 < 14) {
            this.queue.shift()();
        }
        
        document.getElementById('count').textContent = this.fibers.toLocaleString();
        
        if (this.phase === 3) document.getElementById('status').textContent = 'THERMAL SUBSTRATE';
        else if (this.phase === 4) document.getElementById('status').textContent = 'GUARD INTEGUMENT';
        
        if (this.queue.length > 0) requestAnimationFrame(() => this.tick());
    },
    
    start() {
        this.run();
        this.tick();
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// IGNITION
// ═══════════════════════════════════════════════════════════════════════════════
Pipeline.start();

</script>
</body>
</html>
