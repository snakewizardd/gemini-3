<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SODA POP // K-POP ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Modak&family=Varela+Round&display=swap');

    :root {
        --bg: #ffecf2; /* Pastel Pink */
        --bubble: #00f0ff; /* Cyan */
        --pop: #ff0055; /* Hot Pink */
        --fizz: #ccff00; /* Lime */
        --text: #2d3436;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Modak', cursive;
        color: var(--text);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(255, 236, 242, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 6rem;
        margin: 0;
        color: var(--pop);
        text-shadow: 4px 4px 0px var(--bubble);
        letter-spacing: 2px;
        text-align: center;
        line-height: 0.9;
        transform: rotate(-3deg);
    }

    p {
        font-family: 'Varela Round', sans-serif;
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.5rem;
        color: var(--text);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 30px;
        left: 30px;
        font-family: 'Varela Round', sans-serif;
        font-size: 16px;
        pointer-events: none;
        z-index: 5;
        color: var(--pop);
        background: rgba(255,255,255,0.8);
        padding: 10px;
        border-radius: 20px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    
    .bubble-decoration {
        position: absolute;
        border-radius: 50%;
        background: var(--bubble);
        opacity: 0.5;
        z-index: 0;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>SODA POP<br><span style="font-size: 3rem; color: var(--fizz);">K-POP ENGINE</span></h1>
    <p>Click to Open!</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = FIZZ (FILTER) // SPACE = PAUSE</p>
</div>

<div id="hud">
    GENRE: K-POP / FUTURE BASS<br>
    BPM: 128
</div>

<!-- Decor -->
<div class="bubble-decoration" style="top:10%; left:10%; width:100px; height:100px;"></div>
<div class="bubble-decoration" style="bottom:20%; right:10%; width:150px; height:150px; background:var(--fizz);"></div>

<canvas id="canvas"></canvas>

<script>
/**
 * K-POP SODA ENGINE
 * Polished Production + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 128, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    filter: null,
    drumBus: null,
    synthBus: null,
    bassBus: null,
    
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.6; 

        // Global "Fizz" Filter (Highpass/Lowpass sweep)
        AudioEngine.filter = AudioEngine.ctx.createBiquadFilter();
        AudioEngine.filter.type = 'lowpass';
        AudioEngine.filter.frequency.value = 20000;
        AudioEngine.filter.Q.value = 1.0;

        // Busses
        AudioEngine.drumBus = AudioEngine.ctx.createGain();
        AudioEngine.synthBus = AudioEngine.ctx.createGain();
        AudioEngine.bassBus = AudioEngine.ctx.createGain();

        // Master Chain
        AudioEngine.drumBus.connect(AudioEngine.master);
        AudioEngine.synthBus.connect(AudioEngine.filter);
        AudioEngine.bassBus.connect(AudioEngine.filter);
        AudioEngine.filter.connect(AudioEngine.master);
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        
        // K-Pop Polish (Reverb)
        const verb = AudioEngine.ctx.createConvolver();
        verb.buffer = await AudioEngine.createImpulse(1.5, 2.0); // Tight, bright room
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.2;
        AudioEngine.synthBus.connect(verbMix);
        verbMix.connect(verb);
        verb.connect(AudioEngine.master);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = length - i;
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // --- INSTRUMENTS ---

    playKick: (time) => {
        const t = time;
        // Punchy K-Pop Kick
        const osc = AudioEngine.ctx.createOscillator();
        const gain = AudioEngine.ctx.createGain();
        
        osc.frequency.setValueAtTime(180, t);
        osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
        
        gain.gain.setValueAtTime(1.0, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        
        osc.connect(gain);
        gain.connect(AudioEngine.drumBus);
        
        osc.start(t);
        osc.stop(t + 0.3);

        // Sidechain
        AudioEngine.synthBus.gain.cancelScheduledValues(t);
        AudioEngine.synthBus.gain.setValueAtTime(0.3, t); 
        AudioEngine.synthBus.gain.linearRampToValueAtTime(1.0, t + 0.1);
        
        AudioEngine.bassBus.gain.cancelScheduledValues(t);
        AudioEngine.bassBus.gain.setValueAtTime(0.0, t); 
        AudioEngine.bassBus.gain.linearRampToValueAtTime(0.8, t + 0.15);
        
        visualKick();
    },

    playSnare: (time, type='snap') => {
        const t = time;
        // K-Pop Snare is often a layered Snap/Clap/Snare
        
        // Noise (Crisp)
        const bufSize = AudioEngine.ctx.sampleRate * 0.1;
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = AudioEngine.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 2000; // High snap
        
        const noiseEnv = AudioEngine.ctx.createGain();
        noiseEnv.gain.setValueAtTime(0.6, t);
        noiseEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseEnv);
        noiseEnv.connect(AudioEngine.drumBus);
        noise.start(t);
        
        if (type === 'snare') {
            // Add body for snare sections
            const osc = AudioEngine.ctx.createOscillator();
            osc.frequency.setValueAtTime(250, t);
            osc.frequency.exponentialRampToValueAtTime(150, t + 0.1);
            const oscEnv = AudioEngine.ctx.createGain();
            oscEnv.gain.setValueAtTime(0.5, t);
            oscEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            osc.connect(oscEnv);
            oscEnv.connect(AudioEngine.drumBus);
            osc.start(t);
        }
    },

    playHat: (time) => {
        // Trap Hi-Hat (Tight)
        const t = time;
        const bufSize = AudioEngine.ctx.sampleRate * 0.05;
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = AudioEngine.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 10000; // Sizzle
        
        const env = AudioEngine.ctx.createGain();
        env.gain.setValueAtTime(0.3, t);
        env.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(env);
        env.connect(AudioEngine.drumBus);
        
        noise.start(t);
    },

    playBass: (freq, time, duration) => {
        const t = time;
        // 808 Style Bass
        const osc = AudioEngine.ctx.createOscillator();
        osc.type = 'sine'; // Pure sub
        osc.frequency.value = freq;
        
        // Add a bit of square for texture
        const osc2 = AudioEngine.ctx.createOscillator();
        osc2.type = 'square';
        osc2.frequency.value = freq;
        
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.8, t + 0.01);
        amp.gain.setValueAtTime(0.8, t + duration - 0.05);
        amp.gain.linearRampToValueAtTime(0, t + duration);
        
        const amp2 = AudioEngine.ctx.createGain();
        amp2.gain.value = 0.2; // Lower vol for square
        
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;

        osc.connect(amp);
        osc2.connect(filter); filter.connect(amp2); amp2.connect(amp);
        
        amp.connect(AudioEngine.bassBus);
        
        osc.start(t); osc.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    // Glassy Synth Pluck (Guitar Tab Simulation)
    playString: (stringIdx, fret, time, duration = 0.5, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // K-Pop Tone: Bright, Clean, Digital
        osc1.type = 'square'; 
        osc2.type = 'sine'; 
        
        // Pitch Logic
        let targetFreq = freq;
        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Envelope (Pluck)
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.5, t + 0.005); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Filter (FM-ish)
        const nFilter = AudioEngine.ctx.createBiquadFilter();
        nFilter.type = 'lowpass';
        nFilter.frequency.setValueAtTime(4000, t);
        nFilter.frequency.exponentialRampToValueAtTime(500, t + 0.2); 
        nFilter.Q.value = 3; // Resonance for "Pop" sound

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.3;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.7;

        osc1.connect(osc1Gain); osc1Gain.connect(nFilter);
        osc2.connect(osc2Gain); osc2Gain.connect(nFilter);
        nFilter.connect(amp);
        amp.connect(AudioEngine.synthBus);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setFilter: (val) => {
        if(AudioEngine.filter) {
            // Fizz control
            const freq = 200 + (val * 19800);
            AudioEngine.filter.frequency.setTargetAtTime(freq, AudioEngine.ctx.currentTime, 0.1);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
const DRUMS = [];
const BASS = [];

function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}
function addChord(beat, notes) {
    notes.forEach(n => addNote(beat, n[0], n[1]));
}
function addDrum(beat, type) {
    DRUMS.push({ beat, type });
}
function addBass(beat, freq, dur) {
    BASS.push({ beat, freq, dur });
}

// -- BUILD THE SONG --
let b = 0.0;
const E = 0.5; // 8th note
const S = 0.25; // 16th note

// === INTRO ===
// C G F G F
// C (x3555x) G (355433) F (133211)
// Rhythm: Stabs / Pop feel
// [Intro] C G F C G F C G F
// e:---------
// B:---------
// G:---------
// D:---------
// A:---3-----
// E:-------3-
// Let's use power chords for the synths
function addIntro() {
    // C
    addChord(b, [[4,3], [3,5]]); b+=1.0;
    // G
    addChord(b, [[5,3], [4,5]]); b+=1.0;
    // F
    addChord(b, [[5,1], [4,3]]); b+=1.0;
    // C
    addChord(b, [[4,3], [3,5]]); b+=1.0;
    
    // Hey hey part (Drum hits)
    addDrum(b-1.0, 'snare'); // Snap
    addDrum(b-0.5, 'snare'); // Snap
}

addIntro();
addIntro(); // x2

// === VERSE 1 ===
// C G F C
// Bass pulse
// Rhythm: 1 . 2 . 3 . 4 .
// Kick on 1, 3
// Melody on Synth
b += 1.0;

function addVerseLine(rootBass) {
    // Bass 8ths
    for(let i=0; i<8; i++) {
        addBass(b + i*E, rootBass, S);
    }
    // Drums (Soft)
    addDrum(b, 'kick');
    addDrum(b+1.0, 'snare'); // snap
    addDrum(b+2.0, 'kick');
    addDrum(b+3.0, 'snare'); // snap
    // Hats
    for(let i=0; i<8; i++) addDrum(b + i*E, 'hat');
    
    b += 4.0;
}

// C (130.81 Hz - C3, let's go lower C2 65.41)
addVerseLine(65.41);
// G (49.00 Hz - G1)
addVerseLine(49.00);
// F (43.65 Hz - F1)
addVerseLine(43.65);
// C
addVerseLine(65.41);

// "Got a feeling..." (Repeat progression)
addVerseLine(65.41);
addVerseLine(49.00);
addVerseLine(43.65);
addVerseLine(65.41);

// === PRE-CHORUS (BUILD) ===
// F Am G
// Snare roll build up
// Melody chords
// F
addChord(b, [[5,1], [4,3], [3,2]]); 
addBass(b, 43.65, 2.0);
addDrum(b, 'kick'); addDrum(b+1.0, 'kick');
b += 2.0;

// Am (A-0 D-2 G-2)
addChord(b, [[4,0], [3,2], [2,2]]);
addBass(b, 55.00, 1.0); // A1
addDrum(b, 'kick'); 
b += 1.0;

// G
addChord(b, [[5,3], [4,5], [3,4]]);
addBass(b, 49.00, 1.0);
addDrum(b, 'kick');
b += 1.0;

// F again
addChord(b, [[5,1], [4,3], [3,2]]); 
addBass(b, 43.65, 2.0);
addDrum(b, 'kick'); addDrum(b+0.5, 'kick'); addDrum(b+1.0, 'kick'); addDrum(b+1.5, 'kick');
b += 2.0;

// "So refreshing... My little soda pop" (Silence/Fill)
addDrum(b, 'snare'); addDrum(b+0.25, 'snare'); addDrum(b+0.5, 'snare');
b += 2.0;

// === CHORUS (DROP) ===
// C G F
// Full K-Pop Energy
// Melody: High C-0 (E string 8th fret) G-2 (G-string 12)
// Let's play chords rhythmically
// Rhythm: 1 & (2) & 3 & (4) &

function addChorusBar(chord, bassFreq) {
    const start = b;
    // Chords (Syncopated)
    addChord(start, chord);
    addChord(start+0.75, chord);
    addChord(start+1.5, chord);
    addChord(start+2.25, chord);
    addChord(start+3.0, chord);
    
    // Bass (Sidechain pulse)
    addBass(start, bassFreq, 0.2);
    addBass(start+0.5, bassFreq, 0.2);
    addBass(start+1.0, bassFreq, 0.2);
    addBass(start+1.5, bassFreq, 0.2);
    addBass(start+2.0, bassFreq, 0.2);
    addBass(start+2.5, bassFreq, 0.2);
    addBass(start+3.0, bassFreq, 0.2);
    addBass(start+3.5, bassFreq, 0.2);
    
    // Drums (4 on floor)
    for(let i=0; i<4; i++) {
        addDrum(start + i*1.0, 'kick');
        addDrum(start + i*1.0 + 0.5, 'hat');
    }
    addDrum(start+1.0, 'snare'); // Snare
    addDrum(start+3.0, 'snare');
    
    b += 4.0;
}

const C_Major = [[4,3], [3,5], [2,5]];
const G_Major = [[5,3], [4,5], [3,4]];
const F_Major = [[5,1], [4,3], [3,2]];

// C
addChorusBar(C_Major, 65.41);
// G / F Split? Tab says G F
// Let's do 2 beats G, 2 beats F
// Manual split for drop variation
// G part
addChord(b, G_Major); 
addBass(b, 49.00, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, G_Major); 
addDrum(b, 'snare');
b += 1.0;

// F part
addChord(b, F_Major);
addBass(b, 43.65, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, F_Major);
addDrum(b, 'snare');
b += 1.0;

// C
addChorusBar(C_Major, 65.41);

// G / F split
addChord(b, G_Major); 
addBass(b, 49.00, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, G_Major); 
addDrum(b, 'snare');
b += 1.0;

addChord(b, F_Major);
addBass(b, 43.65, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, F_Major);
addDrum(b, 'snare');
b += 1.0;

// === KEY CHANGE OUTRO (C#) ===
// "Gotta drink every drop"
// Shift everything up 1 semitone
// C# (x4666x) G# (466544) F# (244322)
b += 1.0; // Pause

const Cs_Major = [[4,4], [3,6], [2,6]];
const Gs_Major = [[5,4], [4,6], [3,5]];
const Fs_Major = [[5,2], [4,4], [3,3]];

addChorusBar(Cs_Major, 69.30); // C#2
// G# F# Split
addChord(b, Gs_Major); addDrum(b, 'kick'); b+=1.0;
addChord(b, Gs_Major); addDrum(b, 'snare'); b+=1.0;
addChord(b, Fs_Major); addDrum(b, 'kick'); b+=1.0;
addChord(b, Fs_Major); addDrum(b, 'snare'); b+=1.0;

// Final chord C#
addChord(b, Cs_Major);
b += 4.0;

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;
let nextDrumIdx = 0;
let nextBassIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
        nextDrumIdx = 0;
        nextBassIdx = 0;
    }

    // Schedule Melody
    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 0.4, note.target, note.type);
            triggerVisual(note);
            nextNoteIdx++;
        } else { break; }
    }
    
    // Schedule Drums
    while (nextDrumIdx < DRUMS.length) {
        const drum = DRUMS[nextDrumIdx];
        if (drum.beat <= currentBeat + 0.1) {
            const playTime = startTime + (drum.beat * (60 / CONFIG.BPM));
            if(drum.type === 'kick') AudioEngine.playKick(playTime);
            if(drum.type === 'snare') AudioEngine.playSnare(playTime, 'snare');
            if(drum.type === 'hat') AudioEngine.playHat(playTime, false);
            nextDrumIdx++;
        } else { break; }
    }
    
    // Schedule Bass
    while (nextBassIdx < BASS.length) {
        const bass = BASS[nextBassIdx];
        if (bass.beat <= currentBeat + 0.1) {
            const playTime = startTime + (bass.beat * (60 / CONFIG.BPM));
            AudioEngine.playBass(bass.freq, playTime, bass.dur * (60/CONFIG.BPM));
            nextBassIdx++;
        } else { break; }
    }

    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
let kickPulse = 0;
const activeNotes = [];
const bubbles = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function visualKick() {
    kickPulse = 1.0;
    // Spawn bubbles on kick
    for(let i=0; i<5; i++) {
        bubbles.push({
            x: Math.random() * w,
            y: h + 50,
            vy: 2 + Math.random() * 5,
            size: 5 + Math.random() * 20,
            color: Math.random() > 0.5 ? '#00f0ff' : '#ccff00'
        });
    }
}

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 
    
    // Fizz Bubbles
    for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
        ctx.fillStyle = b.color;
        ctx.fill();
        b.y -= b.vy;
        if (b.y < -50) bubbles.splice(i, 1);
    }
    
    // Shake screen on kick
    const shake = kickPulse * 5;
    const dx = (Math.random() - 0.5) * shake;
    const dy = (Math.random() - 0.5) * shake;
    
    ctx.save();
    ctx.translate(dx, dy);

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#ff0055';
    ctx.font = "16px 'Varela Round'";
    ctx.fillStyle = '#00f0ff';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = `rgba(0, 240, 255, ${0.5 + kickPulse*0.5})`;
    ctx.lineWidth = 4 + kickPulse * 4;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 180; 
    
    ctx.font = "20px 'Modak'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ccff00'; 
            let txt = note.fret;
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14 + kickPulse*2, 0, Math.PI*2);
            ctx.fillStyle = '#ffecf2';
            ctx.fill();
            ctx.strokeStyle = '#ff0055'; 
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.fillStyle = '#2d3436'; 
            ctx.fillText(txt, x - 6, y + 6);
        }
    });

    // Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 80);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 0, 85, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.08;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }
    
    ctx.restore();
    
    // Decay Kick
    kickPulse *= 0.9;

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.filter.frequency.setTargetAtTime(200 + ((1-y) * 19800), AudioEngine.ctx.currentTime, 0.1);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>