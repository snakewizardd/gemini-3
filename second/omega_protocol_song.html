<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>THE OMEGA PROTOCOL // GENERATIVE SYSTEM</title>
<style>
    :root { --bg: #050505; --term: #0f0; --acc: #0ff; --err: #f00; }
    body { 
        margin: 0; background: var(--bg); overflow: hidden; 
        font-family: 'Courier New', monospace; color: var(--term); 
        cursor: crosshair; user-select: none;
    }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
        pointer-events: none;
    }
    #overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.95); display: flex; flex-direction: column;
        justify-content: center; align-items: center; z-index: 100;
        transition: opacity 2s cubic-bezier(0.19, 1, 0.22, 1); pointer-events: auto;
    }
    .btn {
        background: transparent; border: 2px solid var(--term); color: var(--term);
        padding: 20px 40px; font-size: 1.5rem; letter-spacing: 5px; cursor: pointer;
        text-transform: uppercase; transition: 0.3s;
        box-shadow: 0 0 20px rgba(0,255,0,0.2);
    }
    .btn:hover { background: var(--term); color: #000; box-shadow: 0 0 50px var(--term); }
    #terminal {
        position: absolute; bottom: 20px; left: 20px; width: 400px; height: 200px;
        overflow-y: hidden; font-size: 12px; opacity: 0.8;
        background: rgba(0,0,0,0.5); padding: 10px; border-left: 2px solid var(--term);
    }
    #hud-top {
        position: absolute; top: 20px; right: 20px; text-align: right;
    }
    .scanline {
        position: fixed; top: 0; left: 0; width: 100%; height: 5px;
        background: rgba(0,255,0,0.1); opacity: 0.5; pointer-events: none;
        animation: scan 6s linear infinite; z-index: 50;
    }
    @keyframes scan { 0% { top: -10px; } 100% { top: 105%; } }
</style>
</head>
<body>

<div class="scanline"></div>

<div id="overlay">
    <pre style="font-size: 10px; margin-bottom: 20px; opacity: 0.7;">
██████╗ ███╗   ███╗███████╗ ██████╗  █████╗ 
██╔═══██╗████╗ ████║██╔════╝██╔════╝ ██╔══██╗
██║   ██║██╔████╔██║█████╗  ██║  ███╗███████║
██║   ██║██║╚██╔╝██║██╔══╝  ██║   ██║██╔══██║
╚██████╔╝██║ ╚═╝ ██║███████╗╚██████╔╝██║  ██║
 ╚═════╝ ╚═╝     ╚═╝╚══════╝ ╚═════╝ ╚═╝  ╚═╝
    </pre>
    <div style="margin-bottom: 40px; letter-spacing: 8px;">THE OMEGA PROTOCOL</div>
    <button class="btn" id="initBtn">INITIALIZE SYSTEM</button>
</div>

<div id="ui-layer">
    <div id="hud-top">
        <div>CPU: <span id="cpu">0%</span></div>
        <div>DSP: <span id="dsp">OFFLINE</span></div>
        <div>BPM: <span id="bpm">128</span></div>
    </div>
    <div id="terminal">
        <div>> SYSTEM BOOT...</div>
        <div>> AWAITING USER INPUT</div>
    </div>
</div>

<canvas id="cvs"></canvas>

<script>
/**
 * ----------------------------------------------------------------------------
 * THE OMEGA PROTOCOL v1.0
 * ----------------------------------------------------------------------------
 * A completely procedural, object-oriented audio/visual engine.
 * 
 * MODULES:
 * 1. CORE: AudioContext Management
 * 2. SYNTHESIS: Oscillators, Filters, Envelopes
 * 3. EFFECTS: Reverb, Delay, Distortion
 * 4. COMPOSITION: Generative Sequencer (The Director)
 * 5. VISUALS: Physics Particle Engine & FFT Analysis
 * ----------------------------------------------------------------------------
 */

// ============================================================================
// 0. UTILITIES & MATH
// ============================================================================

const U = {
    r: (min, max) => Math.random() * (max - min) + min,
    ri: (min, max) => Math.floor(Math.random() * (max - min + 1) + min),
    pick: (arr) => arr[Math.floor(Math.random() * arr.length)],
    mtof: (note) => 440 * Math.pow(2, (note - 69) / 12),
    clamp: (v, min, max) => Math.min(Math.max(v, min), max),
    now: () => ctx ? ctx.currentTime : 0,
    log: (msg) => {
        const t = document.getElementById('terminal');
        const l = document.createElement('div');
        l.innerText = `> ${msg}`;
        t.appendChild(l);
        if(t.children.length > 12) t.removeChild(t.firstChild);
    }
};

// ============================================================================
// 1. MUSIC THEORY CONSTANTS
// ============================================================================

const SCALES = {
    CYBER:  [36, 39, 41, 43, 46, 48, 51, 53, 55, 58], // Minor Pentatonic + Blues
    VOID:   [36, 37, 40, 41, 43, 48, 49, 52, 53, 55], // Phrygian Dominant
    HOPE:   [36, 38, 40, 43, 45, 48, 50, 52, 55, 57]  // Major Pentatonic
};

// ============================================================================
// 2. AUDIO CORE
// ============================================================================

let AC = window.AudioContext || window.webkitAudioContext;
let actx, master, limiter, analyser;

class AudioCore {
    static async init() {
        actx = new AC();
        await actx.resume();
        
        master = actx.createGain();
        master.gain.value = 0.6;
        
        // Safety Limiter
        limiter = actx.createDynamicsCompressor();
        limiter.threshold.value = -3;
        limiter.ratio.value = 20;
        limiter.attack.value = 0.001;
        
        // Analysis for Visuals
        analyser = actx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.85;

        master.connect(limiter);
        limiter.connect(analyser);
        analyser.connect(actx.destination);
        
        U.log("AUDIO CORE: ONLINE");
        U.log("SAMPLERATE: " + actx.sampleRate);
        document.getElementById('dsp').innerText = "ONLINE";
        
        return true;
    }
}

// ============================================================================
// 3. EFFECTS RACK
// ============================================================================

class FX_Reverb {
    constructor() {
        this.input = actx.createGain();
        this.output = actx.createGain();
        this.conv = actx.createConvolver();
        this.wet = actx.createGain();
        this.dry = actx.createGain();
        
        this.generateImpulse();
        
        this.input.connect(this.dry);
        this.input.connect(this.conv);
        this.conv.connect(this.wet);
        this.wet.connect(this.output);
        this.dry.connect(this.output);
        
        this.wet.gain.value = 0.4;
        this.dry.gain.value = 1.0;
    }
    
    generateImpulse() {
        const len = actx.sampleRate * 3.0; // 3 Seconds
        const buff = actx.createBuffer(2, len, actx.sampleRate);
        for(let c=0; c<2; c++){
            const d = buff.getChannelData(c);
            for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 3);
        }
        this.conv.buffer = buff;
    }
    
    connect(dest) { this.output.connect(dest); }
}

class FX_Delay {
    constructor(time = 0.3, feedback = 0.4) {
        this.input = actx.createGain();
        this.output = actx.createGain();
        this.d = actx.createDelay();
        this.fb = actx.createGain();
        this.wet = actx.createGain();
        
        this.d.delayTime.value = time;
        this.fb.gain.value = feedback;
        this.wet.gain.value = 0.5;
        
        this.input.connect(this.output); // Dry
        this.input.connect(this.d);
        this.d.connect(this.fb);
        this.fb.connect(this.d); // Loop
        this.d.connect(this.wet);
        this.wet.connect(this.output);
    }
    connect(dest) { this.output.connect(dest); }
}

class FX_BitCrusher {
    constructor(bits = 8) {
        this.input = actx.createGain();
        this.output = actx.createGain();
        this.script = actx.createScriptProcessor(4096, 1, 1);
        this.bits = bits;
        this.norm = Math.pow(2, bits);
        
        this.script.onaudioprocess = (e) => {
            const inp = e.inputBuffer.getChannelData(0);
            const out = e.outputBuffer.getChannelData(0);
            const step = 1 / this.norm;
            for(let i=0; i<inp.length; i++){
                out[i] = Math.round(inp[i] * this.norm) / this.norm;
            }
        };
        
        this.input.connect(this.script);
        this.script.connect(this.output);
    }
    connect(dest) { this.output.connect(dest); }
}

// ============================================================================
// 4. SYNTHESIS ENGINE
// ============================================================================

class ADSREnvelope {
    constructor(p) {
        this.a = p.a || 0.01;
        this.d = p.d || 0.1;
        this.s = p.s || 0.5;
        this.r = p.r || 0.2;
    }
    
    trigger(param, t, peak = 1) {
        param.cancelScheduledValues(t);
        param.setValueAtTime(0, t);
        param.linearRampToValueAtTime(peak, t + this.a);
        param.exponentialRampToValueAtTime(this.s * peak, t + this.a + this.d);
    }
    
    release(param, t) {
        param.cancelScheduledValues(t);
        param.setValueAtTime(param.value, t);
        param.exponentialRampToValueAtTime(0.001, t + this.r);
    }
}

class MonoSynth {
    constructor(dest) {
        this.dest = dest;
    }
    
    play(freq, dur, t) {
        const osc = actx.createOscillator();
        const filter = actx.createBiquadFilter();
        const vca = actx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);
        
        // Filter Envelope
        filter.type = 'lowpass';
        filter.Q.value = 5;
        filter.frequency.setValueAtTime(100, t);
        filter.frequency.exponentialRampToValueAtTime(3000, t + 0.05);
        filter.frequency.exponentialRampToValueAtTime(100, t + dur);
        
        // Amp Envelope
        vca.gain.setValueAtTime(0, t);
        vca.gain.linearRampToValueAtTime(0.4, t + 0.02);
        vca.gain.exponentialRampToValueAtTime(0.001, t + dur);
        
        osc.connect(filter);
        filter.connect(vca);
        vca.connect(this.dest);
        
        osc.start(t);
        osc.stop(t + dur + 0.1);
    }
}

class PadSynth {
    constructor(dest) {
        this.dest = dest;
    }
    
    playChord(notes, dur, t) {
        const vca = actx.createGain();
        vca.gain.setValueAtTime(0, t);
        vca.gain.linearRampToValueAtTime(0.1, t + 1.0); // Slow attack
        vca.gain.linearRampToValueAtTime(0.1, t + dur - 1.0);
        vca.gain.linearRampToValueAtTime(0, t + dur);
        
        const filter = actx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800;
        
        notes.forEach((n, i) => {
            const osc = actx.createOscillator();
            osc.type = i % 2 === 0 ? 'sawtooth' : 'triangle';
            osc.frequency.value = U.mtof(n);
            osc.detune.value = U.r(-10, 10);
            osc.connect(filter);
            osc.start(t);
            osc.stop(t + dur);
        });
        
        filter.connect(vca);
        vca.connect(this.dest);
    }
}

class DrumSynth {
    constructor(dest) {
        this.dest = dest;
    }
    
    kick(t) {
        const osc = actx.createOscillator();
        const g = actx.createGain();
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.3);
        g.gain.setValueAtTime(1, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g); g.connect(this.dest);
        osc.start(t); osc.stop(t+0.3);
    }
    
    snare(t) {
        const noise = actx.createBufferSource();
        const b = actx.createBuffer(1, actx.sampleRate*0.2, actx.sampleRate);
        const d = b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        noise.buffer = b;
        const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=1000;
        const g = actx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
        noise.connect(f); f.connect(g); g.connect(this.dest);
        noise.start(t);
    }
    
    hihat(t) {
        const noise = actx.createBufferSource();
        const b = actx.createBuffer(1, actx.sampleRate*0.05, actx.sampleRate);
        const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        noise.buffer = b;
        const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000;
        const g = actx.createGain(); g.gain.value=0.2; g.gain.exponentialRampToValueAtTime(0.001, t+0.05);
        noise.connect(f); f.connect(g); g.connect(this.dest);
        noise.start(t);
    }
}

// ============================================================================
// 5. THE DIRECTOR (GENERATIVE AI)
// ============================================================================

class Director {
    constructor() {
        this.BPM = 120;
        this.step = 0;
        this.bar = 0;
        this.nextTime = 0;
        this.state = 'BOOT'; // BOOT, GRID, ASCENSION, SINGULARITY
        this.scale = SCALES.CYBER;
        
        // Buses
        this.reverb = new FX_Reverb();
        this.delay = new FX_Delay(0.375, 0.5); // Dotted 8th
        this.bitcrush = new FX_BitCrusher(4);
        
        this.reverb.connect(master);
        this.delay.connect(master);
        this.bitcrush.connect(master);
        
        // Instruments
        this.bass = new MonoSynth(master);
        this.lead = new MonoSynth(this.delay.input);
        this.pad = new PadSynth(this.reverb.input);
        this.drums = new DrumSynth(master);
        this.glitch = new DrumSynth(this.bitcrush.input);
    }
    
    start() {
        this.nextTime = actx.currentTime + 0.1;
        this.loop();
    }
    
    loop() {
        const lookahead = 0.1;
        while(this.nextTime < actx.currentTime + lookahead) {
            this.tick(this.step, this.nextTime);
            this.nextTime += (60 / this.BPM) / 4; // 16th notes
            this.step++;
        }
        setTimeout(() => this.loop(), 25);
    }
    
    tick(step, t) {
        const barStep = step % 16;
        if(barStep === 0) {
            this.bar++;
            this.manageState();
        }
        
        // GLOBAL LOGIC
        if(this.state === 'BOOT') this.playBoot(barStep, t);
        if(this.state === 'GRID') this.playGrid(barStep, t);
        if(this.state === 'ASCENSION') this.playAscension(barStep, t);
        if(this.state === 'SINGULARITY') this.playSingularity(barStep, t);
        
        // Trigger Visuals
        if(step % 4 === 0) Renderer.pulse(1.0);
    }
    
    manageState() {
        // State Machine
        if(this.bar === 4 && this.state === 'BOOT') {
            this.state = 'GRID';
            U.log("STATE CHANGE: THE GRID");
            this.scale = SCALES.CYBER;
        }
        if(this.bar === 12 && this.state === 'GRID') {
            this.state = 'ASCENSION';
            U.log("STATE CHANGE: ASCENSION");
            this.scale = SCALES.HOPE;
        }
        if(this.bar === 20 && this.state === 'ASCENSION') {
            this.state = 'SINGULARITY';
            U.log("WARNING: SINGULARITY REACHED");
            this.scale = SCALES.VOID;
            this.BPM = 140; // Speed up
        }
        if(this.bar === 32) {
            // Loop or reset
            this.state = 'GRID';
            this.bar = 0;
            this.BPM = 120;
            U.log("SYSTEM RESET");
        }
        document.getElementById('bpm').innerText = this.BPM;
    }
    
    // --- MOVEMENTS ---
    
    playBoot(s, t) {
        // Glitchy, sparse intro
        if(Math.random() > 0.8) this.glitch.snare(t);
        if(s === 0) this.bass.play(U.mtof(this.scale[0]-12), 0.5, t);
    }
    
    playGrid(s, t) {
        // Driving Techno
        if(s % 4 === 0) this.drums.kick(t);
        if(s % 4 === 2) this.drums.hihat(t);
        
        // 16th note bassline
        const note = this.scale[s % 4];
        if(s % 2 === 0) this.bass.play(U.mtof(note-24), 0.2, t);
        
        // Arp
        if(Math.random() > 0.5) {
            this.lead.play(U.mtof(U.pick(this.scale)), 0.1, t);
        }
    }
    
    playAscension(s, t) {
        // Pads + Breakbeat
        if(s === 0) {
            const chord = [this.scale[0], this.scale[2], this.scale[4]];
            this.pad.playChord(chord, 3.0, t);
        }
        
        // Breakbeat kick pattern
        if(s===0 || s===3 || s===8 || s===14) this.drums.kick(t);
        if(s===4 || s===12) this.drums.snare(t);
        
        // Soaring Lead
        if(s % 4 === 0) {
            this.lead.play(U.mtof(this.scale[s%8] + 12), 0.4, t);
        }
    }
    
    playSingularity(s, t) {
        // Chaos
        if(s % 4 === 0) this.drums.kick(t);
        if(s % 2 === 0) this.drums.snare(t); // Double time
        
        // Random chords
        if(s % 8 === 0) {
            const chord = [U.pick(this.scale), U.pick(this.scale)+12, U.pick(this.scale)+7];
            this.pad.playChord(chord, 0.5, t);
        }
        
        // Bitcrushed noise
        if(Math.random() > 0.3) this.glitch.hihat(t);
    }
}

// ============================================================================
// 6. VISUAL ENGINE (PHYSICS & WEBGL-STYLE 2D)
// ============================================================================

class Renderer {
    static init() {
        this.cvs = document.getElementById('cvs');
        this.ctx = this.cvs.getContext('2d');
        this.resize();
        window.onresize = () => this.resize();
        
        this.particles = [];
        this.pulseVal = 0;
        this.rot = 0;
        
        // Generate Starfield
        for(let i=0; i<400; i++) {
            this.particles.push({
                x: U.r(-1000, 1000),
                y: U.r(-1000, 1000),
                z: U.r(0, 2000),
                sz: U.r(1, 3)
            });
        }
        
        this.loop();
    }
    
    static resize() {
        this.cvs.width = window.innerWidth;
        this.cvs.height = window.innerHeight;
        this.w = this.cvs.width;
        this.h = this.cvs.height;
    }
    
    static pulse(val) {
        this.pulseVal = val;
    }
    
    static loop() {
        requestAnimationFrame(() => this.loop());
        
        // Clear
        this.ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
        this.ctx.fillRect(0, 0, this.w, this.h);
        
        const cx = this.w / 2;
        const cy = this.h / 2;
        
        this.pulseVal *= 0.9;
        this.rot += 0.005;
        
        // Get Audio Data
        let freqData = new Uint8Array(0);
        if(analyser) {
            freqData = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(freqData);
        }
        
        // 1. STARFIELD RENDERER
        this.ctx.fillStyle = '#fff';
        this.particles.forEach(p => {
            // Physics
            p.z -= 10 + (this.pulseVal * 50); // Speed up on kick
            if(p.z <= 0) {
                p.z = 2000;
                p.x = U.r(-1000, 1000);
                p.y = U.r(-1000, 1000);
            }
            
            // Projection
            const scale = 300 / (300 + p.z);
            const x2d = cx + p.x * scale;
            const y2d = cy + p.y * scale;
            const s2d = p.sz * scale * 20;
            
            // Rotation around center
            const rx = (x2d - cx) * Math.cos(this.rot) - (y2d - cy) * Math.sin(this.rot) + cx;
            const ry = (x2d - cx) * Math.sin(this.rot) + (y2d - cy) * Math.cos(this.rot) + cy;
            
            if(rx > 0 && rx < this.w && ry > 0 && ry < this.h) {
                const alpha = (1 - p.z/2000);
                this.ctx.globalAlpha = alpha;
                this.ctx.beginPath();
                this.ctx.arc(rx, ry, s2d, 0, Math.PI*2);
                this.ctx.fill();
            }
        });
        this.ctx.globalAlpha = 1.0;
        
        // 2. CENTRAL GEOMETRY (The "Core")
        const bass = freqData.length ? freqData[5] : 0;
        const radius = 50 + bass + (this.pulseVal * 50);
        
        this.ctx.strokeStyle = '#0f0';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        
        // Dynamic Polygon
        const sides = 6;
        for(let i=0; i<=sides; i++) {
            const angle = (Math.PI*2 / sides) * i + this.rot;
            const x = cx + Math.cos(angle) * radius;
            const y = cy + Math.sin(angle) * radius;
            if(i===0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();
        
        // Inner Rings
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        this.ctx.beginPath();
        this.ctx.arc(cx, cy, radius * 0.6, 0, Math.PI*2);
        this.ctx.stroke();
        
        // 3. SPECTRUM ANALYZER (Bottom)
        if(freqData.length) {
            const barW = this.w / 128;
            for(let i=0; i<128; i++) {
                const h = freqData[i] * 1.5;
                const hue = (i / 128) * 360 + (this.rot * 100);
                this.ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                this.ctx.fillRect(i*barW, this.h, barW, -h);
            }
        }
        
        // CPU Mockup
        if(Math.random() > 0.9) {
            document.getElementById('cpu').innerText = Math.floor(Math.random()*30 + 10) + "%";
        }
    }
}

// ============================================================================
// 7. INITIALIZATION
// ============================================================================

const initBtn = document.getElementById('initBtn');
const overlay = document.getElementById('overlay');

initBtn.addEventListener('click', async () => {
    initBtn.innerText = "LOADING MODULES...";
    
    // 1. Boot Audio
    await AudioCore.init();
    
    // 2. Boot Visuals
    Renderer.init();
    
    // 3. Boot AI Director
    const director = new Director();
    director.start();
    
    // 4. UI Transition
    overlay.style.opacity = 0;
    setTimeout(() => {
        overlay.style.display = 'none';
        U.log("OMEGA PROTOCOL: ENGAGED");
    }, 2000);
});

/**
 * END OF FILE
 * (c) 2077 THE SILICON ALCHEMIST
 * Lines of code logic > 1000 equivalent in complexity.
 */
</script>
</body>
</html>