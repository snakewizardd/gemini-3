<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HYPER_ORCHESTRA // 4D</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            cursor: crosshair;
        }
        canvas {
            display: block;
        }
        #hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-family: sans-serif;
            font-size: 10px;
            letter-spacing: 2px;
            pointer-events: none;
            animation: fadeOut 4s forwards;
            animation-delay: 2s;
        }
        @keyframes fadeOut { to { opacity: 0; } }
    </style>
</head>
<body>

    <div id="hint">CLICK TO SYNCHRONIZE AUDIO CORE</div>
    <canvas id="cosmos"></canvas>

    <script>
        const canvas = document.getElementById('cosmos');
        const ctx = canvas.getContext('2d');

        let width, height;
        let cx, cy;

        // 4D CONFIGURATION
        const PARTICLE_COUNT = 600;
        const HYPER_SCALE = 300;
        let particles = [];
        let t = 0; // Time

        // AUDIO STATE
        let audioCtx;
        let isAudioActive = false;
        let masterGain;
        let reverbNode;

        // 4D POINT CLASS
        class Point4D {
            constructor() {
                // Random point on a 3-sphere surface
                // Algorithm: Normal dist variables -> normalize
                const u = Math.random() * 2 - 1;
                const v = Math.random() * 2 - 1;
                const w = Math.random() * 2 - 1;
                const s = Math.random() * 2 - 1;
                const mag = Math.sqrt(u*u + v*v + w*w + s*s);
                
                this.x = u / mag;
                this.y = v / mag;
                this.z = w / mag;
                this.w = s / mag;
                
                this.baseCol = Math.random() > 0.5 ? 200 : 320; // Blue or Purple base
            }

            rotate(theta) {
                // 4D Rotation Matrices (XY, XZ, XW, YZ, YW, ZW)
                // We apply a complex rotation mixing dimensions
                
                // Rotate XW
                const cosT = Math.cos(theta);
                const sinT = Math.sin(theta);
                
                let tx = this.x * cosT - this.w * sinT;
                let tw = this.x * sinT + this.w * cosT;
                this.x = tx; this.w = tw;

                // Rotate YZ
                let ty = this.y * cosT - this.z * sinT;
                let tz = this.y * sinT + this.z * cosT;
                this.y = ty; this.z = tz;
                
                // Rotate XZ (Slower)
                const cosT2 = Math.cos(theta * 0.5);
                const sinT2 = Math.sin(theta * 0.5);
                tx = this.x * cosT2 - this.z * sinT2;
                tz = this.x * sinT2 + this.z * cosT2;
                this.x = tx; this.z = tz;
            }

            project() {
                // 4D to 3D
                // Perspective projection from 4D w onto 3D space
                const distance = 2;
                const wInv = 1 / (distance - this.w);
                
                const x3 = this.x * wInv;
                const y3 = this.y * wInv;
                const z3 = this.z * wInv;

                // 3D to 2D
                const zInv = 1 / (distance - z3);
                const x2 = x3 * zInv * HYPER_SCALE;
                const y2 = y3 * zInv * HYPER_SCALE;
                
                // Scale/Opacity based on 4th dimension (w)
                // Things "far away" in 4D space are dimmer
                const scale = (wInv * zInv) * 3;
                const alpha = (wInv * zInv) * 0.5;

                return { x: x2, y: y2, s: scale, a: alpha };
            }
        }

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            cx = width / 2;
            cy = height / 2;
            
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Point4D());
            }
        }

        /* ------------------------------------------------
           VISUAL ENGINE: THE 4D RENDERER
           ------------------------------------------------ */
        function animate() {
            requestAnimationFrame(animate);
            
            // Trail Effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
            ctx.fillRect(0, 0, width, height);
            
            ctx.globalCompositeOperation = 'lighter';
            
            t += 0.005; // Rotation speed

            // Center Origin
            ctx.save();
            ctx.translate(cx, cy);

            particles.forEach((p, i) => {
                p.rotate(0.005); // Constant rotation
                const proj = p.project();

                // Dynamic Color based on 4D depth and Time
                const hue = (p.baseCol + (t * 20) + (p.w * 100)) % 360;
                
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${proj.a})`;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.s, 0, Math.PI * 2);
                ctx.fill();

                // Connect lines randomly to form "Neural" connections
                // Only connect if close in 3D projection space
                /*
                if (i % 20 === 0) {
                    particles.forEach((p2, j) => {
                        if (i !== j && Math.random() > 0.995) {
                            const proj2 = p2.project();
                            const dist = Math.hypot(proj.x - proj2.x, proj.y - proj2.y);
                            if (dist < 50) {
                                ctx.strokeStyle = `hsla(${hue}, 50%, 50%, ${proj.a * 0.5})`;
                                ctx.lineWidth = 0.5;
                                ctx.beginPath();
                                ctx.moveTo(proj.x, proj.y);
                                ctx.lineTo(proj2.x, proj2.y);
                                ctx.stroke();
                            }
                        }
                    });
                }
                */
            });
            
            // Draw The Core (Singularity)
            // A glowing orb that pulses with the "Orchestra"
            const coreSize = 20 + Math.sin(t * 5) * 5;
            const grad = ctx.createRadialGradient(0, 0, 1, 0, 0, coreSize * 4);
            grad.addColorStop(0, 'white');
            grad.addColorStop(0.2, 'rgba(100, 200, 255, 0.2)');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, coreSize * 4, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }

        /* ------------------------------------------------
           AUDIO ENGINE: THE LYDIAN INTELLIGENCE
           ------------------------------------------------ */
        // C Lydian Mode frequencies (High Octaves)
        const SCALE = [523.25, 587.33, 659.25, 739.99, 783.99, 880.00, 987.77, 1046.50]; // C5 - C6
        const BASS_SCALE = [65.41, 73.42, 82.41, 98.00]; // C2 range

        function startAudio() {
            if (isAudioActive) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Master Setup
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.4;
            
            // Convolution Reverb (The "Space")
            const irDuration = 4.0;
            const sampleRate = audioCtx.sampleRate;
            const irLength = sampleRate * irDuration;
            const irBuffer = audioCtx.createBuffer(2, irLength, sampleRate);
            
            // Generate Impulse Response (White noise decay)
            for (let c = 0; c < 2; c++) {
                const channel = irBuffer.getChannelData(c);
                for (let i = 0; i < irLength; i++) {
                    channel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / irLength, 4);
                }
            }
            
            reverbNode = audioCtx.createConvolver();
            reverbNode.buffer = irBuffer;
            
            masterGain.connect(reverbNode);
            reverbNode.connect(audioCtx.destination);
            masterGain.connect(audioCtx.destination);

            isAudioActive = true;
            document.getElementById('hint').style.display = 'none';

            // Start Layers
            sequencer();
            droneLayer();
        }

        function playNote() {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const pan = audioCtx.createStereoPanner();

            // Choose Random Note from Lydian Scale
            const freq = SCALE[Math.floor(Math.random() * SCALE.length)];
            
            // Synthesis: Sine/Triangle mix for "Pure" intelligence
            osc.type = Math.random() > 0.5 ? 'sine' : 'triangle';
            osc.frequency.value = freq;

            // Envelope: Bell-like but soft
            const now = audioCtx.currentTime;
            const duration = 1.5 + Math.random(); // Long sustain
            
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.1, now + 0.1); // Soft attack
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            // Pan: Random stereo placement
            pan.pan.value = (Math.random() * 2) - 1;

            osc.connect(pan);
            pan.connect(gain);
            gain.connect(masterGain);

            osc.start(now);
            osc.stop(now + duration);
        }

        function sequencer() {
            // Stochastic Rhythm: Randomly play notes
            // Fast interval, but low probability = "Sparkling" effect
            if (Math.random() > 0.7) playNote();
            
            // Loop
            setTimeout(sequencer, 150); // 16th note-ish speed
        }

        function droneLayer() {
            // The "Orchestra" Swell
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc1.type = 'sawtooth';
            osc2.type = 'sawtooth';
            
            // Detuned Fifths (C and G)
            osc1.frequency.value = BASS_SCALE[0]; // C
            osc2.frequency.value = BASS_SCALE[0] * 1.5; // G (Fifth)
            osc2.detune.value = 10; // Slight detune for warmth

            // Lowpass filter sweeping slowly (Breathing)
            filter.type = 'lowpass';
            filter.frequency.value = 200;
            
            // Filter LFO
            const lfo = audioCtx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.1; // Very slow breath (10 seconds)
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 300; // Sweep range

            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);

            gain.gain.value = 0.2;

            osc1.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);

            osc1.start();
            osc2.start();
            lfo.start();
        }

        // INTERACTION HANDLERS
        window.addEventListener('resize', init);
        window.addEventListener('mousedown', startAudio);
        window.addEventListener('touchstart', startAudio);
        window.addEventListener('mousemove', (e) => {
            // Interaction: Rotate the universe slightly with mouse
            // We modify the 't' variable slightly or rotation logic?
            // Let's modify the global rotation speed
            // t += (e.clientX / width) * 0.01;
        });

        // BOOT
        init();
        animate();

    </script>
</body>
</html>