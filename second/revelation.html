<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE LAW OF LARGE NUMBERS</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto+Mono:wght@300&display=swap');

        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Cinzel', serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #e0e0e0;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
            filter: contrast(1.2) brightness(1.1);
        }

        #ui {
            position: absolute;
            z-index: 10;
            text-align: center;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, transparent 20%, #000 100%);
            pointer-events: none;
        }

        h1 {
            font-size: 2.5rem;
            letter-spacing: 10px;
            color: #ff4400; /* Burning Bush Fire */
            text-shadow: 0 0 30px #ff4400;
            opacity: 0;
            transition: opacity 2s;
        }

        #caption {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 20px;
            max-width: 600px;
            line-height: 1.5;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #333;
            opacity: 0;
            transition: opacity 1s;
        }

        button {
            pointer-events: auto;
            margin-top: 50px;
            padding: 20px 60px;
            background: transparent;
            color: #ff4400;
            border: 2px solid #ff4400;
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            cursor: pointer;
            letter-spacing: 5px;
            transition: 0.5s;
            opacity: 1;
        }

        button:hover {
            background: #ff4400;
            color: #000;
            box-shadow: 0 0 100px #ff4400;
        }

        #stats {
            position: absolute;
            bottom: 20px; left: 20px;
            font-family: 'Roboto Mono', monospace;
            font-size: 10px;
            color: #555;
            z-index: 20;
        }

    </style>
</head>
<body>

    <canvas id="mount-sinai"></canvas>

    <div id="ui">
        <h1 id="title">THE DISTRIBUTION</h1>
        <div id="caption"></div>
        <button id="btn-init" onclick="initiate()">RECEIVE THE LAW</button>
    </div>

    <div id="stats">
        POPULATION: <span id="pop-count">0</span><br>
        MEAN_EMOTION: <span id="mean-val">0</span><br>
        OUTLIERS: <span id="outlier-count">0</span>
    </div>

    <script>
        const canvas = document.getElementById('mount-sinai');
        const ctx = canvas.getContext('2d');
        const captionEl = document.getElementById('caption');
        
        let width, height, cx, cy;
        let time = 0;
        let isRunning = false;
        
        // DATA STATE
        let lives = [];
        const TOTAL_LIVES = 2000;
        let outlierCount = 0;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            cx = width / 2;
            cy = height / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        /* ------------------------------------------------
           MATH: GAUSSIAN GENERATOR (Box-Muller Transform)
           ------------------------------------------------ */
        function randomGaussian(mean, stdev) {
            const u = 1 - Math.random(); // Subtraction to flip [0, 1) to (0, 1]
            const v = Math.random();
            const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            // Transform to the desired mean and standard deviation:
            return z * stdev + mean;
        }

        /* ------------------------------------------------
           VISUALS: THE PARTICLE SYSTEM
           ------------------------------------------------ */
        class Life {
            constructor() {
                this.reset();
            }

            reset() {
                // X: Emotional Spectrum (The Bell Curve)
                // Most people are average (0). Saints/Devils are outliers.
                this.emotion = randomGaussian(0, 150); 
                
                // Y: Physical Traverse (Distance from birth)
                // We map this to vertical position
                this.y = height + 10;
                
                // Z: Depth (Time)
                this.z = Math.random() * 1000;
                
                this.speed = 2 + Math.random() * 2;
                this.isOutlier = Math.abs(this.emotion) > 300; // 2 Standard Deviations
                
                if (this.isOutlier) {
                    outlierCount++;
                    playOutlierTone(this.emotion);
                }
            }

            update() {
                this.y -= this.speed;
                
                // Converge towards the Mean (The Mountain Peak)
                // The further up they go, the closer they get to the center line
                const convergence = (this.y / height); 
                this.x = cx + (this.emotion * convergence); 

                if (this.y < 0) this.reset();
            }

            draw() {
                const alpha = (this.y / height);
                
                if (this.isOutlier) {
                    // THE PROPHETS / MADMEN
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.emotion > 0 ? '#00ffff' : '#ff0055'; // Blue (Saint) vs Red (Tyrant)
                    const size = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // THE MASSES
                    // Color maps to emotion: Grey -> Blue -> Gold
                    // But mostly they are dust.
                    ctx.fillStyle = `rgba(100, 100, 120, ${alpha * 0.5})`;
                    ctx.fillRect(this.x, this.y, 1.5, 1.5);
                }
            }
        }

        function initSim() {
            for(let i=0; i<TOTAL_LIVES; i++) {
                lives.push(new Life());
            }
        }

        function drawBellCurveOverlay() {
            ctx.strokeStyle = 'rgba(255, 68, 0, 0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // Draw the mathematical ideal bell curve
            for (let x = 0; x < width; x+=5) {
                const distFromMean = (x - cx);
                // Gaussian function: e^(-x^2 / 2sigma^2)
                const y = height - (Math.exp(-Math.pow(distFromMean, 2) / (2 * Math.pow(150, 2))) * (height * 0.8));
                
                if(x===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function render() {
            if (!isRunning) return;
            requestAnimationFrame(render);
            
            time += 0.01;

            // Clear with heavy trail (History)
            ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
            ctx.fillRect(0, 0, width, height);

            drawBellCurveOverlay();

            lives.forEach(l => {
                l.update();
                l.draw();
            });

            // Draw The Mean (The Pillar of Fire)
            ctx.globalCompositeOperation = 'lighter';
            const grad = ctx.createLinearGradient(cx, 0, cx, height);
            grad.addColorStop(0, 'rgba(255, 100, 0, 0)');
            grad.addColorStop(1, 'rgba(255, 68, 0, 0.2)');
            ctx.fillStyle = grad;
            ctx.fillRect(cx - 2, 0, 4, height);
            ctx.globalCompositeOperation = 'source-over';

            // Update Stats
            document.getElementById('pop-count').innerText = lives.length;
            document.getElementById('outlier-count').innerText = outlierCount;
        }

        /* ------------------------------------------------
           AUDIO ENGINE: THE SOUND OF STATISTICS
           ------------------------------------------------ */
        const AC = window.AudioContext || window.webkitAudioContext;
        let actx, master;
        let droneOsc;

        function initAudio() {
            actx = new AC();
            master = actx.createGain();
            master.gain.value = 0.5;

            // REVERB (The Valley)
            const conv = actx.createConvolver();
            const rate = actx.sampleRate;
            const len = rate * 4;
            const buff = actx.createBuffer(2, len, rate);
            for(let c=0; c<2; c++) {
                const d = buff.getChannelData(c);
                for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/len, 3);
            }
            conv.buffer = buff;
            master.connect(conv);
            conv.connect(actx.destination);
            master.connect(actx.destination);

            // THE MEAN DRONE (The sound of the average)
            droneOsc = actx.createOscillator();
            droneOsc.type = 'triangle';
            droneOsc.frequency.value = 110; // A2
            const dGain = actx.createGain();
            dGain.gain.value = 0.2;
            
            droneOsc.connect(dGain);
            dGain.connect(master);
            droneOsc.start();

            // LFO to pulsate the drone
            const lfo = actx.createOscillator();
            lfo.frequency.value = 0.1;
            const lfoG = actx.createGain();
            lfoG.gain.value = 10;
            lfo.connect(lfoG);
            lfoG.connect(droneOsc.frequency);
            lfo.start();
        }

        function playOutlierTone(emotion) {
            if (!actx) return;

            const osc = actx.createOscillator();
            const gain = actx.createGain();
            const pan = actx.createStereoPanner();
            
            osc.type = 'sine';
            
            // Map emotion (X position) to Pitch & Pan
            // Far Left (Negative) = Low Pitch, Left Ear
            // Far Right (Positive) = High Pitch, Right Ear
            
            let freq;
            if (emotion < 0) freq = 200 + (Math.abs(emotion)); // 200-500Hz
            else freq = 800 + emotion; // 800-1100Hz
            
            osc.frequency.value = freq;
            
            const panVal = Math.max(-1, Math.min(1, emotion / 300));
            pan.pan.value = panVal;

            gain.gain.setValueAtTime(0, actx.currentTime);
            gain.gain.linearRampToValueAtTime(0.1, actx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + 1.0);

            osc.connect(gain);
            gain.connect(pan);
            pan.connect(master);
            
            osc.start();
            osc.stop(actx.currentTime + 1);
        }

        /* ------------------------------------------------
           NARRATIVE ENGINE
           ------------------------------------------------ */
        const LINES = [
            "Behold the Curve.",
            "In the desert of chaos, the Pattern emerges.",
            "You are not special because you are unique.",
            "You are special because you are inevitable.",
            "The tails scream.",
            "The center hums.",
            "But the Integral...",
            "The Integral is One."
        ];

        function narrate(index) {
            if (index >= LINES.length) return;
            
            const text = LINES[index];
            captionEl.innerText = text;
            captionEl.style.opacity = 1;

            // Speak
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 0.8;
            u.pitch = 0.5; // God voice
            const voices = window.speechSynthesis.getVoices();
            // Try to find a deep voice
            const deep = voices.find(v => v.name.includes("Google US English") || v.name.includes("Daniel"));
            if(deep) u.voice = deep;

            u.onend = () => {
                setTimeout(() => {
                    captionEl.style.opacity = 0;
                    setTimeout(() => narrate(index+1), 1000);
                }, 2000);
            };
            
            window.speechSynthesis.speak(u);
        }

        function initiate() {
            const btn = document.getElementById('btn-init');
            const title = document.getElementById('title');
            
            btn.style.opacity = 0;
            title.style.opacity = 1;
            setTimeout(() => btn.style.display = 'none', 1000);

            // Init Systems
            initAudio();
            if(actx.state === 'suspended') actx.resume();
            
            // Load voices fix
            if (window.speechSynthesis.getVoices().length === 0) {
                window.speechSynthesis.addEventListener('voiceschanged', () => narrate(0));
            } else {
                narrate(0);
            }

            initSim();
            isRunning = true;
            render();
        }

    </script>
</body>
</html>