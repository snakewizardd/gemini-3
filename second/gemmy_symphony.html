<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SYMPHONY OF THE ABYSS | Redux</title>
<style>
    body { margin: 0; background: #000; overflow: hidden; color: #d00; font-family: 'Courier New', monospace; }
    #canvas { display: block; width: 100vw; height: 100vh; }
    #overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; 
               justify-content: center; align-items: center; z-index: 10; transition: opacity 0.5s; cursor: pointer; }
    .hidden { opacity: 0; pointer-events: none; }
    h1 { font-size: 4vh; text-shadow: 0 0 20px #f00; letter-spacing: 0.5em; text-transform: uppercase; margin: 0; }
    p { color: #888; font-size: 1.5vh; margin-top: 10px; }
    #status { margin-top: 20px; border: 1px solid #d00; padding: 10px 30px; color: #d00; font-weight: bold; }
    #status:hover { background: #d00; color: #000; }
</style>
</head>
<body>

<div id="overlay">
    <h1>Symphony of the Abyss</h1>
    <p>NEOCLASSICAL ENGINE // 195 BPM // A HARMONIC MINOR</p>
    <div id="status">CLICK TO INITIALIZE</div>
</div>
<canvas id="canvas"></canvas>

<script>
/* ═══════════════════════════════════════════════════════════════
   1. CORE CONFIG & CONSTANTS
   ═══════════════════════════════════════════════════════════════ */
const CONFIG = {
    BPM: 195,
    STRINGS: [64, 59, 55, 50, 45, 40], // E B G D A E
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41]
};

// Note Durations (ms calculated at runtime)
const S = 0.25; // 16th
const E = 0.5;  // 8th
const Q = 1.0;  // Quarter
const H = 2.0;  // Half
const W = 4.0;  // Whole

/* ═══════════════════════════════════════════════════════════════
   2. AUDIO ENGINE (ROBUST)
   ═══════════════════════════════════════════════════════════════ */
const AudioEngine = {
    ctx: null, master: null, drive: null, eq: null,
    ready: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        // Master Bus
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.4;

        // Effects Chain: Drive -> EQ -> Cabinet -> Reverb -> Master
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(1000); // High Gain
        AudioEngine.drive.oversample = '4x';

        AudioEngine.eq = AudioEngine.ctx.createBiquadFilter();
        AudioEngine.eq.type = 'peaking';
        AudioEngine.eq.frequency.value = 2500;
        AudioEngine.eq.Q.value = 1.0;
        AudioEngine.eq.gain.value = 6; // Mid Boost

        const cab = AudioEngine.ctx.createBiquadFilter();
        cab.type = 'lowpass';
        cab.frequency.value = 4500; // Cab Sim

        // Stereo Delay
        const delay = AudioEngine.ctx.createDelay();
        delay.delayTime.value = 0.18;
        const delayGain = AudioEngine.ctx.createGain();
        delayGain.gain.value = 0.3;

        // Routing
        AudioEngine.drive.connect(AudioEngine.eq);
        AudioEngine.eq.connect(cab);
        cab.connect(AudioEngine.master);
        cab.connect(delay);
        delay.connect(delayGain);
        delayGain.connect(AudioEngine.master);
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        
        AudioEngine.ready = true;
    },

    makeDistortionCurve: (k) => {
        const n = 44100, curve = new Float32Array(n), deg = Math.PI / 180;
        for (let i = 0; i < n; i++) {
            let x = i * 2 / n - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    play: (stringIdx, fret, time, dur, type) => {
        if (!AudioEngine.ready) return;
        const ctx = AudioEngine.ctx;
        const freq = CONFIG.BASE_FREQS[stringIdx] * Math.pow(2, fret / 12);
        
        // Double Oscillator (Fat Tone)
        const osc1 = ctx.createOscillator(); osc1.type = 'sawtooth';
        const osc2 = ctx.createOscillator(); osc2.type = 'square';
        osc1.frequency.value = freq;
        osc2.frequency.value = freq;
        osc2.detune.value = 5; // Detune thickness

        // Palm Mute Logic
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        if (type === 'pm') {
            filter.frequency.setValueAtTime(400, time);
            filter.Q.value = 3; 
        } else {
            filter.frequency.setValueAtTime(6000, time);
            filter.Q.value = 0.7;
        }

        const amp = ctx.createGain();
        amp.gain.setValueAtTime(0, time);
        amp.gain.linearRampToValueAtTime(0.5, time + 0.005);
        amp.gain.exponentialRampToValueAtTime(0.001, time + dur);

        // Routing
        osc1.connect(filter); osc2.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.drive);

        osc1.start(time); osc2.start(time);
        osc1.stop(time + dur + 0.1);
    }
};

/* ═══════════════════════════════════════════════════════════════
   3. COMPOSER (PROCEDURAL GENERATION)
   ═══════════════════════════════════════════════════════════════ */
const TAB = [];
let b = 0; // Beat Cursor

function add(s, f, d, t='n') { TAB.push({ beat: b, string: s, fret: f, dur: d, type: t }); }
function advance(d) { b += d; }

// SCALES & PATTERNS
const A_HARM_MINOR = [0, 2, 3, 5, 7, 8, 11, 12]; // Fret offsets
const PEDAL_E = 12; // High E string 12th fret

// --- MOVEMENT I: THE AWAKENING (Sweeps) ---
function sweep(rootFret, shape, dir='up') {
    const s = dir === 'up' ? shape : [...shape].reverse();
    s.forEach(([str, off]) => {
        add(str, rootFret + off, S, 'sweep');
        advance(S);
    });
}
// Shapes (String, FretOffset)
const MIN_SHAPE = [[5,0], [4,2], [3,2], [2,0], [1,0], [0,0]]; // Am
const MAJ_SHAPE = [[5,1], [4,3], [3,2], [2,2], [1,1], [0,1]]; // F

for (let i=0; i<4; i++) {
    sweep(5, MIN_SHAPE, 'up'); sweep(5, MIN_SHAPE, 'down');
    sweep(1, MAJ_SHAPE, 'up'); sweep(1, MAJ_SHAPE, 'down');
}

// --- MOVEMENT II: GALLOPING FURY (Rhythm) ---
function gallop(root, count) {
    for (let i=0; i<count; i++) {
        add(5, root, S, 'pm'); advance(S);
        add(5, root, S, 'pm'); advance(S);
        add(5, root, E, 'pm'); advance(E);
    }
}
// Progression: A -> F -> G -> E
gallop(5, 8); gallop(1, 4); gallop(3, 4); 
gallop(5, 8); gallop(0, 8); // Open E chug

// --- MOVEMENT III: NEO-CLASSICAL LEAD ---
// Pedal Point on High E (12)
const scaleRun = [10, 12, 13, 12, 10, 9, 10, 12]; // B string melody
for (let k=0; k<4; k++) {
    scaleRun.forEach(fret => {
        add(1, fret, S, 'lead'); advance(S);
        add(0, 12, S, 'pm');     advance(S); // Pedal
    });
}

// --- MOVEMENT IV: HARMONIC FINALE ---
// Dual Voice simulation (Root + 3rd)
const melody = [5, 7, 8, 10, 12, 13, 16, 17];
melody.forEach(f => {
    // Voice 1
    TAB.push({ beat: b, string: 0, fret: f, dur: Q, type: 'lead' });
    // Voice 2 (Harmony)
    TAB.push({ beat: b, string: 1, fret: f+4, dur: Q, type: 'lead' });
    
    // Unterlying Chug
    add(5, 5, S, 'pm'); 
    add(5, 5, S, 'pm'); 
    add(5, 5, S, 'pm'); 
    add(5, 5, S, 'pm'); 
    advance(Q);
});

// Final Chord
add(5, 5, W, 'chord');
add(4, 7, W, 'chord');
add(3, 7, W, 'chord');
advance(W);

const LOOP_LEN = b + 4;

/* ═══════════════════════════════════════════════════════════════
   4. SEQUENCER & VISUALS
   ═══════════════════════════════════════════════════════════════ */
let isPlaying = false;
let startTime = 0;
let beat = 0;
let noteIdx = 0;

function scheduler() {
    if (!isPlaying) return;
    const now = AudioEngine.ctx.currentTime;
    beat = (now - startTime) * (CONFIG.BPM / 60);

    if (beat >= LOOP_LEN) {
        startTime = now;
        beat = 0;
        noteIdx = 0;
    }

    while (noteIdx < TAB.length && TAB[noteIdx].beat <= beat + 0.1) {
        const n = TAB[noteIdx];
        // Calculate exact play time to keep rhythm tight
        const playTime = startTime + (n.beat * (60 / CONFIG.BPM));
        
        // Humanize slightly (random velocity logic handled in play)
        const dur = n.dur * (60 / CONFIG.BPM);
        AudioEngine.play(n.string, n.fret, playTime, dur, n.type);
        triggerVisual(n);
        noteIdx++;
    }
    requestAnimationFrame(scheduler);
}

// VISUAL ENGINE
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const particles = [];

window.onresize = () => { w = cvs.width = window.innerWidth; h = cvs.height = window.innerHeight; };
window.onresize();

function triggerVisual(note) {
    particles.push({
        y: h/2 + (note.string - 2.5) * 40,
        x: w * 0.3,
        life: 1.0,
        color: note.type === 'pm' ? '#500' : '#f00',
        size: note.type === 'chord' ? 20 : 5
    });
}

function draw() {
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(0, 0, w, h);

    const CY = h/2;
    // Strings
    CONFIG.STRING_NAMES.forEach((s, i) => {
        const y = CY + (i - 2.5) * 40;
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y);
        ctx.strokeStyle = '#333'; ctx.stroke();
    });

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size + (1-p.life)*50, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 0, 0, ${p.life})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        p.life -= 0.05;
        p.x += 2; // Move right
        if (p.life <= 0) particles.splice(i, 1);
    }
    
    // Playhead
    ctx.beginPath(); ctx.moveTo(w*0.3, 0); ctx.lineTo(w*0.3, h);
    ctx.strokeStyle = '#d00'; ctx.lineWidth = 2; ctx.stroke();

    requestAnimationFrame(draw);
}
draw();

/* ═══════════════════════════════════════════════════════════════
   5. CONTROLLER
   ═══════════════════════════════════════════════════════════════ */
const overlay = document.getElementById('overlay');
const status = document.getElementById('status');

async function engage() {
    try {
        status.innerText = "INITIALIZING...";
        if (!AudioEngine.ready) await AudioEngine.init();
        
        // CRITICAL FIX: Force Resume
        if (AudioEngine.ctx.state === 'suspended') {
            await AudioEngine.ctx.resume();
        }
        
        isPlaying = true;
        startTime = AudioEngine.ctx.currentTime;
        overlay.classList.add('hidden');
        scheduler();
    } catch (e) {
        status.innerText = "ERROR: " + e.message;
        console.error(e);
    }
}

overlay.addEventListener('click', engage);

</script>
</body>
</html>