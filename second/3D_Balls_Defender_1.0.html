<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Ball Defender</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #zone_joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            z-index: 2;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            display: none;
        }
        
        /* UI Elements */
        .hud-text {
            position: absolute;
            font-weight: bold;
            font-size: 24px;
            z-index: 3;
            text-shadow: 2px 2px 0px #000;
            pointer-events: none;
            display: none;
        }
        
        #wave-display { top: 20px; left: 20px; color: #00ffcc; }
        #score-display { top: 20px; right: 20px; color: #ffcc00; }
        
        #lives-display { 
            bottom: 30px; 
            right: 30px; 
            color: #ff3333; 
            font-size: 30px;
        }

        #center-msg {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 40px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            z-index: 3;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* Screens */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }
        
        #game-over-screen {
            display: none;
            background: rgba(50, 0, 0, 0.95);
        }

        button {
            padding: 20px 40px;
            font-size: 24px;
            background: #0088ff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            font-weight: bold;
            transition: transform 0.1s;
        }
        button:active {
            transform: scale(0.95);
        }
        
        h1 { 
            margin-bottom: 30px; 
            text-transform: uppercase; 
            letter-spacing: 4px; 
            font-size: 48px;
            text-shadow: 0 0 10px #0088ff;
        }
        .score-final { font-size: 30px; color: #ffcc00; margin: 10px 0; }

        /* Trophy Styles */
        #trophy-container {
            margin: 20px 0;
            font-size: 50px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .trophy-text {
            display: block;
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .trophy-bronze { color: #cd7f32; }
        .trophy-silver { color: #c0c0c0; }
        .trophy-gold { color: #ffd700; }
        .trophy-platinum { 
            color: #e5e4e2;
            animation: shine 1.5s infinite alternate;
        }

        @keyframes shine {
            from { text-shadow: 0 0 10px #e5e4e2; }
            to { text-shadow: 0 0 25px #ffffff, 0 0 5px #00ffff; }
        }
    </style>
</head>
<body>

    <!-- Start Screen -->
    <div id="start-screen" class="overlay-screen">
        <h1>3D BALL DEFENDER</h1>
        <button onclick="startGame()">START GAME</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="overlay-screen">
        <h1>GAME OVER</h1>
        <p>You survived until Wave <span id="final-wave">0</span></p>
        
        <div id="trophy-container"></div>

        <div class="score-final">SCORE: <span id="final-score">0</span></div>
        <button onclick="retryGame()">RETRY</button>
    </div>

    <!-- HUD -->
    <div id="wave-display" class="hud-text">WAVE: 1</div>
    <div id="lives-display" class="hud-text">LIVES: 3</div>
    <div id="score-display" class="hud-text">SCORE: 0</div>
    <div id="center-msg">WAVE 1</div>

    <!-- Game World -->
    <div id="game-container"></div>
    <div id="zone_joystick"></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

    <script>
        // --- 1. SETUP SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        // Adjusted fog for zoomed out camera
        scene.fog = new THREE.Fog(0x1a1a2e, 30, 120);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // --- 2. LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 40, 20);
        dirLight.castShadow = true;
        // Increased shadow map area for zoomed out view
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        scene.add(dirLight);

        // --- 3. ENVIRONMENT ---
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        const gridHelper = new THREE.GridHelper(200, 40, 0xffffff, 0x1a6b1a);
        gridHelper.position.y = 0.05;
        scene.add(gridHelper);

        // --- 4. PLAYER ---
        const ballRadius = 1;
        const ball = new THREE.Mesh(
            new THREE.SphereGeometry(ballRadius, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0x0088ff, emissive: 0x0044aa, emissiveIntensity: 0.4, roughness: 0.1 })
        );
        ball.position.y = ballRadius;
        ball.castShadow = true;
        scene.add(ball);

        // --- 5. GAME VARIABLES ---
        let enemies = [];
        let playerProjectiles = [];
        let enemyProjectiles = [];
        let powerups = [];
        
        let wave = 1;
        let score = 0;
        let lives = 3;
        let isWaveSpawning = false;
        let enemiesToSpawnQueue = 0;
        let gameActive = false;
        
        // Status Effects
        let isInvulnerable = false;
        let invulnerableTimer = 0;
        
        // Power Up Logic
        let doubleShotEndTime = 0;
        let baseFireRate = 350; 

        const frustum = new THREE.Frustum();
        const projScreenMatrix = new THREE.Matrix4();

        // UI References
        const waveEl = document.getElementById('wave-display');
        const scoreEl = document.getElementById('score-display');
        const livesEl = document.getElementById('lives-display');
        const msgEl = document.getElementById('center-msg');
        const joystickZone = document.getElementById('zone_joystick');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const finalWaveEl = document.getElementById('final-wave');
        const trophyContainer = document.getElementById('trophy-container');

        function updateUI() {
            waveEl.innerText = `WAVE: ${wave}`;
            scoreEl.innerText = `SCORE: ${score}`;
            livesEl.innerText = `LIVES: ${lives}`;
        }

        function showMessage(text, color = 'white') {
            msgEl.innerText = text;
            msgEl.style.color = color;
            msgEl.style.opacity = 1;
            setTimeout(() => { msgEl.style.opacity = 0; }, 2000);
        }

        // --- 6. POWER UP LOGIC ---
        function createHeartGeometry() {
            const x = 0, y = 0;
            const heartShape = new THREE.Shape();
            heartShape.moveTo(x + 0.25, y + 0.25);
            heartShape.bezierCurveTo(x + 0.25, y + 0.25, x + 0.20, y, x, y);
            heartShape.bezierCurveTo(x - 0.30, y, x - 0.30, y + 0.35, x - 0.30, y + 0.35);
            heartShape.bezierCurveTo(x - 0.30, y + 0.55, x - 0.10, y + 0.77, x + 0.25, y + 0.95);
            heartShape.bezierCurveTo(x + 0.60, y + 0.77, x + 0.80, y + 0.55, x + 0.80, y + 0.35);
            heartShape.bezierCurveTo(x + 0.80, y + 0.35, x + 0.80, y, x + 0.50, y);
            heartShape.bezierCurveTo(x + 0.35, y, x + 0.25, y + 0.25, x + 0.25, y + 0.25);
            
            const geometry = new THREE.ExtrudeGeometry(heartShape, { depth: 0.4, bevelEnabled: false });
            geometry.center(); 
            geometry.scale(1.5, 1.5, 1.5); 
            return geometry;
        }

        const heartGeo = createHeartGeometry();
        const boxGeo = new THREE.BoxGeometry(1.3, 1.3, 1.3);

        function spawnPowerUp(position) {
            const r = Math.random();
            let type = null;
            let color = null;
            let geometry = boxGeo;

            if (r < 0.01) {
                type = 'heart'; color = 0xff0000; geometry = heartGeo;
            } else if (r < 0.06) {
                type = 'permanent'; color = 0x00ff00; 
            } else if (r < 0.12) {
                type = 'double'; color = 0x00ffff; 
            } else {
                return; 
            }

            const material = new THREE.MeshBasicMaterial({ color: color });
            const powerUp = new THREE.Mesh(geometry, material);
            
            powerUp.position.copy(position);
            powerUp.position.y = 1.5; 
            powerUp.userData = { type: type };
            
            scene.add(powerUp);
            
            powerups.push({ mesh: powerUp, life: 300 });
        }

        function collectPowerUp(type) {
            if (type === 'heart') {
                lives++;
                updateUI();
                showMessage("EXTRA LIFE!", "#ff0000");
            } else if (type === 'permanent') {
                baseFireRate = Math.max(50, baseFireRate * 0.9);
                showMessage("FIRE RATE UP!", "#00ff00");
            } else if (type === 'double') {
                doubleShotEndTime = Date.now() + 10000; 
                showMessage("DOUBLE SHOT!", "#00ffff");
            }
        }

        // --- 7. DAMAGE & GAME OVER ---
        function takeDamage() {
            if (isInvulnerable || !gameActive) return;

            lives--;
            updateUI();

            if (lives <= 0) {
                endGame();
            } else {
                isInvulnerable = true;
                invulnerableTimer = 90; 
                ball.material.color.setHex(0xff0000);
                ball.material.emissive.setHex(0xff0000);
            }
        }

        function endGame() {
            gameActive = false;
            finalScoreEl.innerText = score;
            finalWaveEl.innerText = wave;
            
            let trophyHTML = "";
            if (score >= 4000) {
                trophyHTML = `<span class="trophy-platinum">üèÜ</span><span class="trophy-text trophy-platinum">PLATINUM TROPHY</span>`;
            } else if (score >= 2500) {
                trophyHTML = `<span class="trophy-gold">üèÜ</span><span class="trophy-text trophy-gold">GOLD TROPHY</span>`;
            } else if (score >= 1500) {
                trophyHTML = `<span class="trophy-silver">üèÜ</span><span class="trophy-text trophy-silver">SILVER TROPHY</span>`;
            } else if (score >= 800) {
                trophyHTML = `<span class="trophy-bronze">üèÜ</span><span class="trophy-text trophy-bronze">BRONZE TROPHY</span>`;
            } else {
                trophyHTML = `<span style="font-size:20px; color:#888;">No Trophy</span>`;
            }
            trophyContainer.innerHTML = trophyHTML;

            gameOverScreen.style.display = 'flex';
            joystickZone.style.display = 'none';
            waveEl.style.display = 'none';
            scoreEl.style.display = 'none';
            livesEl.style.display = 'none';
        }

        function retryGame() {
            gameOverScreen.style.display = 'none';
            startGame();
        }

        // --- 8. WAVE LOGIC ---
        function startNextWave() {
            if (isWaveSpawning) return;
            isWaveSpawning = true;

            showMessage(`WAVE ${wave}`);

            const count = Math.floor(5 * Math.pow(1.4, wave - 1));
            enemiesToSpawnQueue = count;

            spawnWaveLoop();
        }

        function spawnWaveLoop() {
            if (!gameActive) return;

            if (enemiesToSpawnQueue > 0) {
                spawnEnemy();
                enemiesToSpawnQueue--;
                setTimeout(() => spawnWaveLoop(), 1500); 
            } else {
                isWaveSpawning = false;
            }
        }

        function spawnEnemy() {
            let size = 1.5;
            const enemyGroup = new THREE.Group();

            let type, color, hp;
            
            const maxGreen = 0.20;  
            const maxOrange = 0.30; 
            const maxPink = 0.40;   

            let pGreen = 0;
            let pOrange = 0;
            let pPink = 0.25; 

            if (wave >= 4) {
                pGreen = 0.03 + (wave - 4) * 0.015;
                if (pGreen > maxGreen) pGreen = maxGreen;
            }

            if (wave >= 3) {
                pOrange = 0.08 + (wave - 3) * 0.02;
                if (pOrange > maxOrange) pOrange = maxOrange;
            }

            pPink = 0.25 + (wave * 0.01);
            if (pPink > maxPink) pPink = maxPink;

            const r = Math.random();

            if (r < pGreen) {
                type = 'tracker'; color = 0x006400; hp = 9; size = 2.0;
            } else if (r < pGreen + pOrange) {
                type = 'tri'; color = 0xffaa00; hp = 6;
            } else if (r < pGreen + pOrange + pPink) {
                type = 'ranged'; color = 0xff00ff; hp = 5;
            } else {
                type = 'melee'; color = 0xff0000; hp = 3;
            }

            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(size, size, size),
                new THREE.MeshStandardMaterial({ color: color })
            );
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.position.y = size / 2;
            enemyGroup.add(mesh);

            const hpBg = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.3), new THREE.MeshBasicMaterial({ color: 0x550000 }));
            hpBg.position.y = size + 1;
            enemyGroup.add(hpBg);

            const hpFg = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.3), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            hpFg.position.z = 0.01;
            hpBg.add(hpFg);

            const angle = Math.random() * Math.PI * 2;
            const radius = 80; 
            enemyGroup.position.x = Math.cos(angle) * radius;
            enemyGroup.position.z = Math.sin(angle) * radius;

            enemyGroup.userData = {
                type: type,
                health: hp,
                maxHealth: hp,
                hpBar: hpFg,
                lastShot: 0
            };

            scene.add(enemyGroup);
            enemies.push(enemyGroup);
        }

        // --- 9. SHOOTING ---
        let lastShotTime = 0;
        const range = 50;

        function playerShoot(target) {
            const isDouble = Date.now() < doubleShotEndTime;

            const fireOne = (offsetVector) => {
                const proj = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                
                const startPos = ball.position.clone().add(offsetVector);
                proj.position.copy(startPos);
                proj.position.y = ballRadius;
                
                const targetPos = target.position.clone();
                targetPos.y += 0.75; 
                proj.lookAt(targetPos);
                
                scene.add(proj);
                
                const velocity = new THREE.Vector3().subVectors(targetPos, startPos).normalize().multiplyScalar(1.8);
                playerProjectiles.push({ mesh: proj, velocity: velocity, life: 60 });
            };

            if (isDouble) {
                const dir = new THREE.Vector3().subVectors(target.position, ball.position).normalize();
                const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize().multiplyScalar(0.5);
                const left = right.clone().negate();

                fireOne(left);
                fireOne(right);
            } else {
                fireOne(new THREE.Vector3(0,0,0));
            }
        }

        function enemyShoot(enemy) {
            const type = enemy.userData.type;
            let projColor = 0xff00ff;
            let projSpeed = 0.144; 
            let isTracking = false;

            if (type === 'tri') projColor = 0xffaa00;
            if (type === 'tracker') {
                projColor = 0x00ff00; 
                projSpeed = 0.12; 
                isTracking = true;
            }

            const fireProjectile = (directionVector) => {
                const proj = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 8, 8),
                    new THREE.MeshBasicMaterial({ color: projColor })
                );
                proj.position.copy(enemy.position);
                proj.position.y = 1.5;
                scene.add(proj);
                
                const velocity = directionVector.normalize().multiplyScalar(projSpeed);
                
                enemyProjectiles.push({ 
                    mesh: proj, 
                    velocity: velocity, 
                    life: isTracking ? 1000 : 800, 
                    isTracking: isTracking,
                    speed: projSpeed
                });
            };

            const baseDir = new THREE.Vector3().subVectors(ball.position, enemy.position);

            if (type === 'ranged') {
                fireProjectile(baseDir.clone());
            } else if (type === 'tri') {
                fireProjectile(baseDir.clone()); 
                const axis = new THREE.Vector3(0, 1, 0); 
                const leftDir = baseDir.clone().applyAxisAngle(axis, 0.35); 
                fireProjectile(leftDir);
                const rightDir = baseDir.clone().applyAxisAngle(axis, -0.35); 
                fireProjectile(rightDir);
            } else if (type === 'tracker') {
                fireProjectile(baseDir.clone());
            }
        }

        // --- 10. CONTROLS ---
        let moveData = { x: 0, y: 0 };
        let joystickManager;

        // --- 11. MAIN LOOP ---
        let velocity = new THREE.Vector3(0, 0, 0);
        const acceleration = 0.04;
        const friction = 0.94;
        const maxSpeed = 0.54;

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('wave-display').style.display = 'block';
            document.getElementById('score-display').style.display = 'block';
            document.getElementById('lives-display').style.display = 'block';
            joystickZone.style.display = 'block';
            
            if (!joystickManager) {
                joystickManager = nipplejs.create({
                    zone: document.getElementById('zone_joystick'),
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: 'white',
                    size: 100
                });
                joystickManager.on('move', (evt, data) => {
                    if (data && data.vector) { moveData.x = data.vector.x; moveData.y = data.vector.y; }
                });
                joystickManager.on('end', () => { moveData.x = 0; moveData.y = 0; });
            }
            
            moveData = { x: 0, y: 0 };

            gameActive = true;
            resetGame();
            animate(); 
        }

        function resetGame() {
            ball.position.set(0, ballRadius, 0);
            velocity.set(0, 0, 0);
            
            ball.material.color.setHex(0x0088ff);
            ball.material.emissive.setHex(0x0044aa);
            ball.visible = true;
            
            enemies.forEach(e => scene.remove(e));
            enemies = [];
            playerProjectiles.forEach(p => scene.remove(p.mesh));
            playerProjectiles = [];
            enemyProjectiles.forEach(p => scene.remove(p.mesh));
            enemyProjectiles = [];
            powerups.forEach(p => scene.remove(p.mesh));
            powerups = [];

            wave = 1;
            score = 0;
            lives = 3;
            isInvulnerable = false;
            doubleShotEndTime = 0;
            baseFireRate = 350; 
            enemiesToSpawnQueue = 0;
            isWaveSpawning = false;
            updateUI();
            startNextWave();
        }

        function animate() {
            if (!gameActive) return;
            requestAnimationFrame(animate);

            // --- STATUS EFFECTS ---
            const now = Date.now();
            const isDoubleShot = now < doubleShotEndTime;

            if (isInvulnerable) {
                invulnerableTimer--;
                if (invulnerableTimer % 10 < 5) ball.visible = false;
                else ball.visible = true;

                if (invulnerableTimer <= 0) {
                    isInvulnerable = false;
                    ball.visible = true;
                }
            }

            if (!isInvulnerable) {
                if (isDoubleShot) {
                    ball.material.color.setHex(0x00ffff); 
                    ball.material.emissive.setHex(0x00aaaa);
                } else {
                    ball.material.color.setHex(0x0088ff); 
                    ball.material.emissive.setHex(0x0044aa);
                }
            }

            // --- PLAYER PHYSICS ---
            velocity.x += moveData.x * acceleration;
            velocity.z += -moveData.y * acceleration;
            velocity.multiplyScalar(friction);
            if (velocity.length() > maxSpeed) velocity.setLength(maxSpeed);
            ball.position.add(velocity);
            ball.rotation.x -= velocity.z * 0.3;
            ball.rotation.z += velocity.x * 0.3;

            // --- POWER UP LOGIC ---
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                p.life--;
                p.mesh.rotation.y += 0.05;
                
                if (p.mesh.userData.type === 'heart') {
                    p.mesh.rotation.z = 0; 
                } else {
                    p.mesh.rotation.x += 0.05;
                }

                if (ball.position.distanceTo(p.mesh.position) < 1.5) {
                    collectPowerUp(p.mesh.userData.type);
                    scene.remove(p.mesh);
                    powerups.splice(i, 1);
                    continue;
                }
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    powerups.splice(i, 1);
                }
            }

            // --- AUTO-TARGETING ---
            camera.updateMatrixWorld();
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(projScreenMatrix);

            if (now - lastShotTime > baseFireRate) {
                let closest = null;
                let minDst = Infinity;
                
                enemies.forEach(e => {
                    const d = ball.position.distanceTo(e.position);
                    if (d < minDst && d < range) {
                        if (frustum.containsPoint(e.position)) {
                            minDst = d; 
                            closest = e; 
                        }
                    }
                });

                if (closest) {
                    playerShoot(closest);
                    lastShotTime = now;
                }
            }

            // --- PLAYER PROJECTILES ---
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const p = playerProjectiles[i];
                p.mesh.position.add(p.velocity);
                p.life--;
                
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (p.mesh.position.distanceTo(enemy.position) < 1.5) {
                        enemy.userData.health -= 1;
                        const pct = Math.max(0, enemy.userData.health / enemy.userData.maxHealth);
                        enemy.userData.hpBar.scale.x = pct;

                        if (enemy.userData.health <= 0) {
                            spawnPowerUp(enemy.position);
                            scene.remove(enemy);
                            enemies.splice(j, 1);
                            
                            let pts = 10; 
                            if (enemy.userData.type === 'ranged') pts = 25; 
                            if (enemy.userData.type === 'tri') pts = 40; 
                            if (enemy.userData.type === 'tracker') pts = 60; 
                            score += pts;
                            
                            updateUI();
                        }
                        hit = true;
                        break;
                    }
                }
                if (hit || p.life <= 0) {
                    scene.remove(p.mesh);
                    playerProjectiles.splice(i, 1);
                }
            }

            // --- ENEMY PROJECTILES ---
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                
                if (p.isTracking) {
                    const targetDir = new THREE.Vector3().subVectors(ball.position, p.mesh.position).normalize();
                    p.velocity.lerp(targetDir.multiplyScalar(p.speed), 0.02);
                    p.velocity.normalize().multiplyScalar(p.speed);
                }

                p.mesh.position.add(p.velocity);
                p.life--;

                if (p.mesh.position.distanceTo(ball.position) < (ballRadius + 0.5)) {
                    takeDamage();
                    scene.remove(p.mesh);
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    enemyProjectiles.splice(i, 1);
                }
            }

            // --- WAVE MANAGEMENT ---
            if (enemies.length === 0 && enemiesToSpawnQueue === 0 && !isWaveSpawning) {
                wave++;
                updateUI();
                startNextWave();
            }

            // --- ENEMY BEHAVIOR ---
            enemies.forEach(enemy => {
                const distToPlayer = ball.position.distanceTo(enemy.position);
                const type = enemy.userData.type;

                let moveSpeed = 0.1275; // Reduced Red Speed
                if (type === 'ranged' || type === 'tri') moveSpeed = 0.08;
                if (type === 'tracker') moveSpeed = 0.05; 

                const dir = new THREE.Vector3().subVectors(ball.position, enemy.position).normalize();
                enemy.position.add(dir.multiplyScalar(moveSpeed));
                
                enemy.lookAt(ball.position);
                enemy.children[1].lookAt(camera.position);

                if (type === 'ranged' || type === 'tri' || type === 'tracker') {
                    if (now - enemy.userData.lastShot > 2000 && distToPlayer < 60) {
                        enemyShoot(enemy);
                        enemy.userData.lastShot = now;
                    }
                }

                if (distToPlayer < (ballRadius + 0.75)) {
                    takeDamage();
                    const pushDir = new THREE.Vector3().subVectors(enemy.position, ball.position).normalize();
                    enemy.position.add(pushDir.multiplyScalar(5));
                }
            });

            // --- CAMERA & BOUNDS ---
            // Zoomed out camera
            const camOffset = new THREE.Vector3(0, 25, 35);
            camera.position.lerp(ball.position.clone().add(camOffset), 0.1);
            camera.lookAt(ball.position);

            if (Math.abs(ball.position.x) > 100 || Math.abs(ball.position.z) > 100) {
                lives = 0;
                takeDamage(); 
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>