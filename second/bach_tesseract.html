<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BACH // TESSERACT</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Orbitron:wght@400;900&display=swap');

    :root {
        --void: #000000;
        --light: #e0e0e0;
        --hyper: #00ffcc;
        --dim: #1a1a2e;
    }

    body {
        margin: 0;
        background: var(--void);
        overflow: hidden;
        font-family: 'Cinzel', serif;
        color: var(--light);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.92);
        z-index: 10;
        transition: opacity 1.5s;
    }

    h1 {
        font-family: 'Orbitron', sans-serif;
        font-size: 4rem;
        margin: 0;
        color: var(--light);
        text-shadow: 0 0 20px var(--hyper);
        letter-spacing: 10px;
        text-align: center;
        font-weight: 900;
    }

    p {
        font-family: 'Cinzel', serif;
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.2rem;
        color: var(--hyper);
        opacity: 0.8;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 30px;
        left: 30px;
        font-family: 'Orbitron', sans-serif;
        font-size: 12px;
        pointer-events: none;
        z-index: 5;
        color: var(--hyper);
        border-left: 1px solid var(--hyper);
        padding-left: 15px;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>J.S. BACH<br><span style="font-size: 2rem; letter-spacing: 20px;">TESSERACT</span></h1>
    <p>[ ENTER THE HYPERCUBE ]</p>
    <p style="font-size: 0.7rem; color: #666; margin-top: 3rem;">MOUSE Y = TIME DILATION</p>
</div>

<div id="hud">
    DIMENSION: 5<br>
    STATUS: QUANTUM SUPERPOSITION
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * BACH TESSERACT ENGINE
 * 5D Spectral Granulation + Hypercube Visuals
 */

// --- AUDIO ENGINE (The Quantum Cello) ---
const AudioEngine = {
    ctx: null,
    master: null,
    convolver: null,
    
    // Granular buffers
    grains: [],
    
    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.5;
        
        // 5D Reverb (Infinite Space)
        AudioEngine.convolver = AudioEngine.ctx.createConvolver();
        AudioEngine.convolver.buffer = await AudioEngine.createImpulse(5.0, 4.0); // 5s tail
        
        AudioEngine.master.connect(AudioEngine.convolver);
        AudioEngine.convolver.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = length - i;
            // Reverse exponential for "swelling" space
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // Plays a "Grain" of the note
    playGrain: (freq, time, panX, panY, panZ) => {
        if(!AudioEngine.ctx) return;
        
        const osc = AudioEngine.ctx.createOscillator();
        const amp = AudioEngine.ctx.createGain();
        const panner = AudioEngine.ctx.createStereoPanner();
        const filter = AudioEngine.ctx.createBiquadFilter();
        
        // 5D Tone: Sine modulated by random noise (texture)
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        // Filter based on "Z" (Depth)
        // Far away = Lowpass, Close = Highpass
        if (panZ < 0) {
            filter.type = 'lowpass';
            filter.frequency.value = 500 + (panZ + 1) * 2000; 
        } else {
            filter.type = 'highpass';
            filter.frequency.value = 100 + panZ * 500;
        }
        
        // Panning X (Left/Right)
        panner.pan.value = panX;
        
        // Envelope (Grain shape)
        const dur = 0.1 + Math.random() * 0.2; // Short grains
        amp.gain.setValueAtTime(0, time);
        amp.gain.linearRampToValueAtTime(0.1 * (1-Math.abs(panY)), time + dur/2); // Y affects volume
        amp.gain.linearRampToValueAtTime(0, time + dur);
        
        // Chain
        osc.connect(filter);
        filter.connect(panner);
        panner.connect(amp);
        amp.connect(AudioEngine.master);
        
        osc.start(time);
        osc.stop(time + dur);
    },
    
    // Triggers a full note as a cloud of grains
    playNote: (freq, time) => {
        // Burst of 10 grains scattered in 5D space
        for(let i=0; i<8; i++) {
            const offset = Math.random() * 0.1;
            const px = (Math.random() * 2 - 1);
            const py = (Math.random() * 2 - 1);
            const pz = (Math.random() * 2 - 1);
            // Slight detune for thickness
            const f = freq + (Math.random() * 4 - 2);
            AudioEngine.playGrain(f, time + offset, px, py, pz);
        }
        
        // Fundamental Anchor (The Cello body)
        const fund = AudioEngine.ctx.createOscillator();
        fund.type = 'triangle';
        fund.frequency.value = freq;
        const fAmp = AudioEngine.ctx.createGain();
        fAmp.gain.setValueAtTime(0, time);
        fAmp.gain.linearRampToValueAtTime(0.2, time + 0.05);
        fAmp.gain.exponentialRampToValueAtTime(0.001, time + 1.5);
        
        fund.connect(fAmp);
        fAmp.connect(AudioEngine.master);
        fund.start(time);
        fund.stop(time + 1.5);
    }
};

// --- THE COMPOSITION (Bach Prelude G Major) ---
const BACH_NOTES = [
    // Measure 1
    ['G2', 0.0], ['D3', 0.25], ['B3', 0.5], ['A3', 0.75], ['B3', 1.0], ['D3', 1.25], ['B3', 1.5], ['D3', 1.75],
    // Measure 1 (repeat pattern)
    ['G2', 2.0], ['D3', 2.25], ['B3', 2.5], ['A3', 2.75], ['B3', 3.0], ['D3', 3.25], ['B3', 3.5], ['D3', 3.75],
    
    // Measure 2
    ['G2', 4.0], ['E3', 4.25], ['C4', 4.5], ['B3', 4.75], ['C4', 5.0], ['E3', 5.25], ['C4', 5.5], ['E3', 5.75],
    ['G2', 6.0], ['E3', 6.25], ['C4', 6.5], ['B3', 6.75], ['C4', 7.0], ['E3', 7.25], ['C4', 7.5], ['E3', 7.75],
    
    // Measure 3
    ['G2', 8.0], ['F#3', 8.25], ['C4', 8.5], ['B3', 8.75], ['C4', 9.0], ['F#3', 9.25], ['C4', 9.5], ['F#3', 9.75],
    ['G2', 10.0], ['F#3', 10.25], ['C4', 10.5], ['B3', 10.75], ['C4', 11.0], ['F#3', 11.25], ['C4', 11.5], ['F#3', 11.75],
    
    // Measure 4 (Back to G)
    ['G2', 12.0], ['D3', 12.25], ['B3', 12.5], ['A3', 12.75], ['B3', 13.0], ['D3', 13.25], ['B3', 13.5], ['D3', 13.75],
    ['G2', 14.0], ['D3', 14.25], ['B3', 14.5], ['A3', 14.75], ['B3', 15.0], ['D3', 15.25], ['B3', 15.5], ['D3', 15.75],
    
    // Measure 5 (Climb)
    ['G2', 16.0], ['E3', 16.25], ['B3', 16.5], ['A3', 16.75], ['B3', 17.0], ['E3', 17.25], ['B3', 17.5], ['E3', 17.75]
];

// Map Note Names to Freq
const FREQ_MAP = {
    'G2': 98.00, 'A2': 110.00, 'B2': 123.47, 'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F#3': 185.00,
    'G3': 196.00, 'A3': 220.00, 'B3': 246.94, 'C4': 261.63, 'D4': 293.66
};

// --- SEQUENCER ---
let startTime = 0;
let noteIdx = 0;
let speedMult = 1.0;

function scheduler() {
    if (!AudioEngine.ctx) return;
    
    const lookahead = 0.1;
    const currentTime = AudioEngine.ctx.currentTime;
    
    // Loop
    if (noteIdx >= BACH_NOTES.length) {
        noteIdx = 0;
        startTime = currentTime;
    }
    
    while (noteIdx < BACH_NOTES.length) {
        const noteData = BACH_NOTES[noteIdx];
        const noteTime = startTime + (noteData[1] * 0.6 * speedMult); // 0.6 = base tempo scaling
        
        if (noteTime < currentTime + lookahead) {
            const freq = FREQ_MAP[noteData[0]];
            if (freq) {
                AudioEngine.playNote(freq, noteTime);
                spawnVisual(noteData[0]);
            }
            noteIdx++;
        } else {
            break;
        }
    }
    
    requestAnimationFrame(scheduler);
}

// --- 4D VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
let angleX = 0;
let angleY = 0;
let angleZ = 0;
let angleW = 0;

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Matrix Math
function mult(v, m) {
    let result = [];
    for (let i = 0; i < m.length; i++) { // rows
        let sum = 0;
        for (let j = 0; j < v.length; j++) { // cols
            sum += m[i][j] * v[j];
        }
        result.push(sum);
    }
    return result;
}

// Tesseract Geometry (16 points)
// x, y, z, w (4D coordinates)
const points = [];
for(let i=0; i<16; i++) {
    let x = (i & 1) ? 1 : -1;
    let y = (i & 2) ? 1 : -1;
    let z = (i & 4) ? 1 : -1;
    let w_coord = (i & 8) ? 1 : -1;
    points.push([x, y, z, w_coord]);
}

// Connections
// A mess of lines to form the hypercube
// Simplified: Connect if hamming distance is 1
const edges = [];
for(let i=0; i<16; i++) {
    for(let j=i+1; j<16; j++) {
        let dist = 0;
        // Check coordinate differences
        if (points[i][0] !== points[j][0]) dist++;
        if (points[i][1] !== points[j][1]) dist++;
        if (points[i][2] !== points[j][2]) dist++;
        if (points[i][3] !== points[j][3]) dist++;
        
        if (dist === 1) {
            edges.push([i, j]);
        }
    }
}

// Active notes highlighting
let activePulse = 0;
let activeHue = 0;

function spawnVisual(noteName) {
    activePulse = 1.0;
    // Map pitch to hue
    const freq = FREQ_MAP[noteName];
    activeHue = (freq - 98) * 2; 
}

function draw() {
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(0,0,w,h);
    
    const projected = [];
    
    // Rotation Matrices (4D)
    // XY, XZ, XW, YZ, YW, ZW
    // We'll rotate XW and YZ
    
    const t = Date.now() * 0.0005 * (1/speedMult);
    
    for (let i = 0; i < points.length; i++) {
        let p = points[i];
        
        // Rotate ZW plane
        let angle = t;
        let cos = Math.cos(angle);
        let sin = Math.sin(angle);
        
        // Apply rotations manually for speed
        // Z, W rotation
        let z = p[2] * cos - p[3] * sin;
        let w_coord = p[2] * sin + p[3] * cos;
        let x = p[0];
        let y = p[1];
        
        // Rotate XY plane
        let x2 = x * Math.cos(angle*0.5) - y * Math.sin(angle*0.5);
        let y2 = x * Math.sin(angle*0.5) + y * Math.cos(angle*0.5);
        
        // 4D to 3D Projection (Perspective)
        let distance = 3;
        let w_inv = 1 / (distance - w_coord);
        
        let p3 = [
            x2 * w_inv,
            y2 * w_inv,
            z * w_inv
        ];
        
        // 3D to 2D Projection
        let z_inv = 1 / (distance - p3[2]);
        let p2 = [
            p3[0] * z_inv * 500 + w/2,
            p3[1] * z_inv * 500 + h/2
        ];
        
        projected.push(p2);
        
        // Draw Vertices
        ctx.beginPath();
        ctx.arc(p2[0], p2[1], 3 + (activePulse * 5), 0, Math.PI*2);
        ctx.fillStyle = `hsla(${activeHue}, 100%, 50%, 1)`;
        ctx.fill();
    }
    
    // Draw Edges
    ctx.lineWidth = 1 + (activePulse * 3);
    ctx.strokeStyle = `hsla(${activeHue + 180}, 100%, 50%, ${0.2 + activePulse * 0.5})`;
    
    for (let i = 0; i < edges.length; i++) {
        const a = projected[edges[i][0]];
        const b = projected[edges[i][1]];
        
        ctx.beginPath();
        ctx.moveTo(a[0], a[1]);
        ctx.lineTo(b[0], b[1]);
        ctx.stroke();
    }
    
    activePulse *= 0.9;
    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        document.getElementById('overlay').classList.add('hidden');
        startTime = AudioEngine.ctx.currentTime;
        scheduler();
    }
});

document.addEventListener('mousemove', (e) => {
    const y = e.clientY / window.innerHeight;
    // Map Y to Speed (0.5x to 2.0x)
    speedMult = 0.5 + (y * 1.5);
});

draw();

</script>
</body>
</html>