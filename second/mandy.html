<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIBERIA // FRACTAL HOWL</title>
    <style>
        body {
            margin: 0;
            background-color: #050508;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #aaddff;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
            /* Frost effect */
            filter: contrast(1.3) brightness(1.2) drop-shadow(0 0 10px #00ccff);
        }

        #ui-layer {
            position: absolute;
            z-index: 10;
            text-align: center;
            pointer-events: none;
            mix-blend-mode: lighten;
        }

        h1 {
            font-size: 3rem;
            margin: 0;
            text-shadow: 0 0 20px #00ccff;
            letter-spacing: 5px;
        }

        .readout {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00ccff;
            padding: 10px;
            margin-top: 20px;
            font-size: 12px;
            display: inline-block;
        }

        #start-screen {
            position: absolute;
            width: 100%; height: 100%;
            background: rgba(5, 5, 8, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s;
        }

        button {
            background: transparent;
            color: #00ccff;
            border: 2px solid #00ccff;
            padding: 20px 50px;
            font-size: 1.5rem;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-top: 20px;
            transition: 0.3s;
        }

        button:hover {
            background: #00ccff;
            color: #000;
            box-shadow: 0 0 50px #00ccff;
        }
        
        /* Snow Overlay */
        .snow {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMjUiIGN5PSIyNSIgcj0iMSIgZmlsbD0id2hpdGUiIG9wYWNpdHk9IjAuMyIvPjwvc3ZnPg==');
            animation: snowFall 2s linear infinite;
            pointer-events: none;
            z-index: 5;
            opacity: 0.3;
        }
        @keyframes snowFall { 0% { background-position: 0 0; } 100% { background-position: 50px 50px; } }

    </style>
</head>
<body>

    <div class="snow"></div>
    <canvas id="fractal"></canvas>

    <div id="ui-layer">
        <div id="readout" class="readout">
            COORDS: WAITING...<br>
            COLLATZ_ORBIT: NULL<br>
            PACK_STATUS: SILENT
        </div>
    </div>

    <div id="start-screen">
        <h1>THE HUSKYBROT</h1>
        <div style="color: #8899aa; margin-top: 10px;">COLLATZ RESONANCE ENGINE</div>
        <button onclick="init()">ENTER THE TUNDRA</button>
    </div>

    <script>
        const canvas = document.getElementById('fractal');
        const ctx = canvas.getContext('2d', { alpha: false });
        const readout = document.getElementById('readout');

        let width, height;
        let cx, cy;
        let mouse = { x: 0, y: 0, real: 0, imag: 0 };
        let isRunning = false;

        // FRACTAL STATE
        // We zoom in slightly to emphasize the "Head" shape of the Mandelbrot
        const ZOOM = 200; 
        const MAX_ITER = 64;

        // COLLATZ LIGHTNING
        let lightningPaths = [];

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            cx = width / 2;
            cy = height / 2;
            if (isRunning) drawStaticFractal();
        }
        window.addEventListener('resize', resize);
        
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            
            // Calculate complex coordinates
            // We mirror X to create the "Husky Face" symmetry
            let mx = (mouse.x - cx) / ZOOM;
            let my = (mouse.y - cy) / ZOOM;
            
            mouse.real = Math.abs(mx) - 0.5; // Mirror logic
            mouse.imag = my;
            
            updateWind(mouse.y / height);
        });

        /* ------------------------------------------------
           VISUAL ENGINE: THE SYMMETRIC MANDELBROT
           ------------------------------------------------ */
        
        // We render the static fractal to an offscreen buffer for performance,
        // then compose dynamic elements on top.
        let fractalBuffer;

        function drawStaticFractal() {
            // Create buffer
            const buf = document.createElement('canvas');
            buf.width = width;
            buf.height = height;
            const bctx = buf.getContext('2d');
            
            const imgData = bctx.createImageData(width, height);
            const data = imgData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // SYMMETRY HACK: Abs(x) creates the mirrored "Face"
                    let zx = 0;
                    let zy = 0;
                    let cx_f = (Math.abs(x - cx) / ZOOM) - 0.75; // Shift to center main bulb
                    let cy_f = (y - cy) / ZOOM;

                    let iter = 0;
                    while (zx*zx + zy*zy < 4 && iter < MAX_ITER) {
                        let tmp = zx*zx - zy*zy + cx_f;
                        zy = 2*zx*zy + cy_f;
                        zx = tmp;
                        iter++;
                    }

                    // Pixel Index
                    const p = (y * width + x) * 4;
                    
                    // COLOR PALETTE: SIBERIAN ICE
                    // Map iterations to Blue/Grey/White
                    const t = iter / MAX_ITER;
                    
                    if (iter === MAX_ITER) {
                        // Inside the set (The Void/Black nose)
                        data[p] = 5;     // R
                        data[p+1] = 5;   // G
                        data[p+2] = 10;  // B
                        data[p+3] = 255; // Alpha
                    } else {
                        // The Fur/Ice
                        data[p] = t * 200;             // R
                        data[p+1] = t * 230 + 20;      // G (Cyan tint)
                        data[p+2] = t * 255 + 50;      // B
                        data[p+3] = 255;
                    }
                }
            }
            bctx.putImageData(imgData, 0, 0);
            fractalBuffer = buf;
        }

        function draw() {
            if(!isRunning) return;
            requestAnimationFrame(draw);

            // 1. Draw Background (Fractal)
            if(fractalBuffer) ctx.drawImage(fractalBuffer, 0, 0);

            // 2. Draw Interaction (Mouse Glow)
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = 'rgba(200, 240, 255, 0.1)';
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 50, 0, Math.PI*2);
            ctx.fill();

            // 3. Draw Collatz Lightning
            ctx.globalCompositeOperation = 'lighter';
            ctx.lineWidth = 2;
            
            for(let i = lightningPaths.length - 1; i >= 0; i--) {
                const path = lightningPaths[i];
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${path.life})`;
                ctx.beginPath();
                
                // Draw the orbit visually
                for(let j=0; j<path.points.length - 1; j++) {
                    const p1 = path.points[j];
                    const p2 = path.points[j+1];
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                }
                ctx.stroke();
                
                path.life -= 0.02;
                if(path.life <= 0) lightningPaths.splice(i, 1);
            }
            
            ctx.globalCompositeOperation = 'source-over';
        }

        /* ------------------------------------------------
           MATH ENGINE: THE COLLATZ ORBIT
           ------------------------------------------------ */
        
        function generateCollatzOrbit(seed) {
            // Convert mouse coordinate seed into a starting integer
            // We scale it up to get interesting numbers
            let n = Math.floor(Math.abs(seed * 1000)) + 1;
            if (n < 2) n = 27; // Classic long orbit number

            let sequence = [n];
            while (n !== 1 && sequence.length < 100) {
                if (n % 2 === 0) n = n / 2;
                else n = 3 * n + 1;
                sequence.push(n);
            }
            
            // Map sequence to screen coordinates
            // We map the integer value to an angle and radius to create a "Lightning" shape
            // over the fractal.
            const visualPoints = sequence.map((val, i) => {
                const angle = (val % 360) * (Math.PI / 180); // Value determines direction
                const r = (i * 5) + 50; // Time determines distance from click
                return {
                    x: mouse.x + Math.cos(angle) * r,
                    y: mouse.y + Math.sin(angle) * r
                };
            });

            lightningPaths.push({
                points: visualPoints,
                life: 1.0
            });

            return sequence;
        }

        /* ------------------------------------------------
           AUDIO ENGINE: THE WOLF CHOIR
           ------------------------------------------------ */
        const AC = window.AudioContext || window.webkitAudioContext;
        let actx, master;
        let windNode, windGain;
        
        // SCALE: A Dorian (Husky/Folk vibe)
        // A, B, C, D, E, F#, G
        const SCALE = [220, 246.94, 261.63, 293.66, 329.63, 369.99, 392.00];

        function initAudio() {
            actx = new AC();
            
            // REVERB (The Tundra)
            const convolver = actx.createConvolver();
            const rate = actx.sampleRate;
            const len = rate * 3.0;
            const buff = actx.createBuffer(2, len, rate);
            for(let i=0; i<len; i++) {
                buff.getChannelData(0)[i] = (Math.random()*2-1) * Math.pow(1-i/len, 3);
                buff.getChannelData(1)[i] = (Math.random()*2-1) * Math.pow(1-i/len, 3);
            }
            convolver.buffer = buff;

            master = actx.createGain();
            master.gain.value = 0.5;
            
            master.connect(convolver);
            convolver.connect(actx.destination);
            master.connect(actx.destination); // Dry mix

            // WIND DRONE
            startWind();
        }

        function startWind() {
            const bufSize = actx.sampleRate * 2;
            const buf = actx.createBuffer(1, bufSize, actx.sampleRate);
            const data = buf.getChannelData(0);
            for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;

            windNode = actx.createBufferSource();
            windNode.buffer = buf;
            windNode.loop = true;

            const filter = actx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 400;
            filter.Q.value = 1;

            windGain = actx.createGain();
            windGain.gain.value = 0.1;

            windNode.connect(filter);
            filter.connect(windGain);
            windGain.connect(master);
            windNode.start();
            
            // Store filter to modulation
            windNode.filter = filter;
        }

        function updateWind(yPct) {
            if(windNode && windNode.filter) {
                // Mouse Y controls wind pitch (The Blizzard)
                const freq = 200 + (yPct * 600);
                windNode.filter.frequency.setTargetAtTime(freq, actx.currentTime, 0.1);
            }
        }

        function triggerHowl(sequence) {
            const osc = actx.createOscillator();
            const osc2 = actx.createOscillator(); // Harmony
            const gain = actx.createGain();
            const filter = actx.createBiquadFilter();

            // PITCH SELECTION based on Collatz length
            // Longer sequence = Higher, more intense howl
            const rootIdx = sequence.length % SCALE.length;
            const freq = SCALE[rootIdx];

            osc.type = 'sawtooth';
            osc.frequency.value = freq;
            
            osc2.type = 'sawtooth';
            osc2.frequency.value = freq * 1.5; // Perfect Fifth (The "Pack" harmony)
            osc2.detune.value = 10;

            // FORMANT FILTER (The "Aaaa-Ooooo" shape)
            filter.type = 'lowpass';
            filter.Q.value = 8; // High resonance for vocal quality
            
            const now = actx.currentTime;
            const duration = 2 + (sequence.length * 0.05); // Length of howl

            // Pitch Glide (The scoop up and down)
            osc.frequency.setValueAtTime(freq * 0.8, now);
            osc.frequency.linearRampToValueAtTime(freq, now + (duration * 0.3));
            osc.frequency.linearRampToValueAtTime(freq * 0.9, now + duration);
            
            osc2.frequency.setValueAtTime(freq * 1.5 * 0.8, now);
            osc2.frequency.linearRampToValueAtTime(freq * 1.5, now + (duration * 0.3));

            // Filter Sweep (Vowel Morph)
            filter.frequency.setValueAtTime(400, now); // "Ooo"
            filter.frequency.linearRampToValueAtTime(1200, now + (duration * 0.4)); // "Aaa"
            filter.frequency.linearRampToValueAtTime(300, now + duration); // "Ooo"

            // Volume Envelope
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.2, now + 0.5);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            osc.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(master);

            osc.start(now); osc2.start(now);
            osc.stop(now + duration); osc2.stop(now + duration);
        }

        /* ------------------------------------------------
           INTERACTION
           ------------------------------------------------ */
        
        window.addEventListener('mousedown', () => {
            if(isRunning) {
                // Calculate complexity of the clicked point on the Fractal
                // Use mouse X/Y as a seed
                const seed = mouse.x + mouse.y;
                const seq = generateCollatzOrbit(seed);
                
                // Trigger Audio
                triggerHowl(seq);
                
                // Update UI
                readout.innerHTML = `
                    COORDS: ${mouse.real.toFixed(3)} + ${mouse.imag.toFixed(3)}i<br>
                    COLLATZ_STEPS: ${seq.length}<br>
                    PACK_STATUS: HOWLING
                `;
            }
        });

        function init() {
            const s = document.getElementById('start-screen');
            s.style.opacity = 0;
            setTimeout(() => s.style.display = 'none', 1000);
            
            resize();
            initAudio();
            // Pre-render the fractal background
            drawStaticFractal();
            isRunning = true;
            draw();
        }

    </script>
</body>
</html>