<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NC RIVER BATTLE // ALTMAN vs MUSK</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            overflow: hidden;
            font-family: 'Impact', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            background: #222;
        }

        /* HUD */
        #ui {
            position: absolute;
            top: 20px;
            width: 90%;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #fff;
            padding: 15px;
            width: 350px;
            transform: skew(-10deg);
        }

        .name {
            color: white;
            font-size: 2rem;
            text-transform: uppercase;
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000;
        }

        .bar-track {
            width: 100%;
            height: 25px;
            background: #333;
            border: 2px solid #555;
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }

        /* START SCREEN */
        #menu {
            position: absolute;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        h1 {
            color: #ffd700;
            font-size: 4rem;
            text-transform: uppercase;
            text-shadow: 4px 4px 0 #d00;
            margin: 0;
            font-style: italic;
            letter-spacing: 2px;
        }

        h2 {
            color: #aaa;
            font-family: 'Courier New';
            font-size: 1.5rem;
            margin-top: 10px;
        }

        button {
            margin-top: 50px;
            padding: 20px 60px;
            font-size: 2rem;
            font-family: 'Impact';
            background: #d00;
            color: #fff;
            border: 4px solid #fff;
            cursor: pointer;
            transform: skew(-10deg);
            transition: 0.1s;
            box-shadow: 0 0 20px #d00;
        }

        button:hover {
            background: #fff;
            color: #d00;
            transform: skew(-10deg) scale(1.05);
        }

    </style>
</head>
<body>

    <div id="ui">
        <div class="hud-panel" style="border-color: #0ff;">
            <div class="name" style="color: #0ff;">SAM ALTMAN</div>
            <div class="bar-track"><div class="bar-fill" id="hp1" style="background: linear-gradient(90deg, #00f, #0ff);"></div></div>
        </div>
        <div class="hud-panel" style="border-color: #f00; text-align: right;">
            <div class="name" style="color: #f00;">ELON MUSK</div>
            <div class="bar-track"><div class="bar-fill" id="hp2" style="background: linear-gradient(90deg, #800, #f00); float: right;"></div></div>
        </div>
    </div>

    <div id="menu">
        <h1>SILICON RIVALS</h1>
        <h2>STAGE: BLUE RIDGE RIVER</h2>
        <button onclick="startGame()">FIGHT!</button>
    </div>

    <canvas id="game"></canvas>

    <script>
        // 1. DEFINE GLOBALS FIRST (Fixing the ReferenceError)
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        // Audio Context Global Definition
        const AC = window.AudioContext || window.webkitAudioContext;

        let width = 0;
        let height = 0;
        let floorY = 0; // Defined here, assigned in resize
        
        let isRunning = false;
        let time = 0;
        let shake = 0;
        let timeScale = 1.0; // Hitstop multiplier

        let p1, p2;
        let particles = [];

        /* ------------------------------------------------
           SETUP & RESIZE
           ------------------------------------------------ */
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            floorY = height - 120; // The ground line

            // Safety: Ensure fighters stay on screen if resized
            if(p1) { p1.y = floorY; p1.x = Math.min(p1.x, width-50); }
            if(p2) { p2.y = floorY; p2.x = Math.min(p2.x, width-50); }
        }
        
        // Initial call
        resize();
        window.addEventListener('resize', resize);

        /* ------------------------------------------------
           PHYSICS: THE PARTICLE SYSTEM
           ------------------------------------------------ */
        class Particle {
            constructor(x, y, direction) {
                this.x = x; 
                this.y = y;
                
                // CONE SPREAD: Direction + random spread (-0.5 to 0.5 radians)
                const angle = direction + (Math.random() - 0.5);
                const speed = Math.random() * 10 + 5; // Fast burst

                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.02; 
                this.gravity = 0.6;
                this.drag = 0.92;
                this.size = Math.random() * 8 + 4;
                this.colorType = Math.random(); // To pick color palette
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                this.vx *= this.drag;
                this.vy += this.gravity; // Gravity pulls down
                
                this.life -= this.decay;

                // Floor Bounce
                if (this.y > floorY) {
                    this.y = floorY;
                    this.vy *= -0.6; // Lose energy
                    this.vx *= 0.8;  // Friction
                }
            }

            draw() {
                // COLOR SHIFT: Heat (White) -> Fire (Yellow/Orange) -> Smoke (Grey)
                let r, g, b;
                
                if (this.life > 0.7) { // White hot
                    r = 255; g = 255; b = 255;
                } else if (this.life > 0.3) { // Fire
                    r = 255; g = Math.floor(this.life * 200); b = 0;
                } else { // Smoke
                    const c = Math.floor(this.life * 100);
                    r = c; g = c; b = c;
                }

                // CUBIC EASING for Alpha (Stays visible then disappears fast)
                const alpha = this.life * this.life * this.life;
                
                ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function spawnParticles(x, y, impactDir) {
            // ImpactDir is 1 (Right) or -1 (Left). 
            // Particles fly OPPOSITE to impact.
            const baseAngle = impactDir === 1 ? Math.PI : 0; // If hit right, fly left (PI)
            // Add slight upward bias (-0.2 rads)
            const angle = baseAngle - 0.2;

            for(let i=0; i<15; i++) {
                particles.push(new Particle(x, y, angle));
            }
        }

        /* ------------------------------------------------
           FIGHTER LOGIC
           ------------------------------------------------ */
        class Fighter {
            constructor(name, startX) {
                this.name = name;
                this.x = startX;
                this.y = floorY;
                this.vx = 0; 
                this.vy = 0;
                this.hp = 100;
                this.state = 'IDLE';
                this.facing = name === 'SAM' ? 1 : -1;
                this.timer = 0;
                
                // Stats
                this.speed = name === 'SAM' ? 1.5 : 0.8; // Sam fast, Elon slow
                this.mass = name === 'SAM' ? 1.0 : 1.5;  // Elon heavy
            }

            update(enemy) {
                // AI BRAIN
                const dx = enemy.x - this.x;
                const dist = Math.abs(dx);
                const dir = Math.sign(dx);

                // Always look at enemy
                if (this.state !== 'HIT') this.facing = dir || 1;

                if (this.state === 'IDLE' || this.state === 'RUN') {
                    if (dist > 100) {
                        // Chase
                        this.vx += dir * (this.speed * 0.5);
                        this.state = 'RUN';
                    } else {
                        // Attack Range
                        this.vx *= 0.8; // Brake
                        if (this.timer <= 0 && Math.random() > 0.95) {
                            this.attack();
                        }
                    }
                }

                // ATTACK STATE
                if (this.state === 'ATTACK') {
                    if (this.timer === 18) { // Lunge frame
                        this.vx = this.facing * 15;
                    }
                }

                // PHYSICS
                this.vy += 1.0; // Gravity
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.85; // Friction

                // Floor constraint
                if (this.y > floorY) {
                    this.y = floorY;
                    this.vy = 0;
                }

                // Wall constraint
                if (this.x < 50) this.x = 50;
                if (this.x > width-50) this.x = width-50;

                // Cooldowns
                if (this.timer > 0) this.timer--;
                if (this.timer === 0 && this.state !== 'IDLE') this.state = 'IDLE';
            }

            attack() {
                this.state = 'ATTACK';
                this.timer = 25; // Duration
                playSfx('SWOOSH');
            }

            takeHit(damage, knockDir) {
                this.state = 'HIT';
                this.timer = 20; // Stun
                this.hp -= damage;
                
                // Physics Reaction
                this.vx = knockDir * (20 / this.mass);
                this.vy = -10;
                
                // Effects
                playSfx('HIT');
                shake = 10;
                timeScale = 0.1; // Freeze frame
                setTimeout(() => timeScale = 1.0, 80);
                
                spawnParticles(this.x, this.y - 50, knockDir);
                updateUI();
            }

            checkHit(enemy) {
                // Active frames of attack: 15 to 20
                if (this.state === 'ATTACK' && this.timer > 15 && this.timer < 20) {
                    const dx = Math.abs(this.x - enemy.x);
                    const dy = Math.abs(this.y - enemy.y);
                    
                    if (dx < 80 && dy < 50 && enemy.state !== 'HIT') {
                        enemy.takeHit(10, this.facing);
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 0, 50, 10, 0, 0, Math.PI*2);
                ctx.fill();

                if (this.name === 'SAM') this.drawSam();
                else this.drawElon();

                ctx.restore();
            }

            drawSam() {
                // Attack Pose tilt
                if (this.state === 'ATTACK') ctx.rotate(0.2);
                if (this.state === 'HIT') ctx.rotate(-0.5);

                // Suit Body
                ctx.fillStyle = '#2c3e50'; // Navy Suit
                ctx.fillRect(-25, -130, 50, 80);
                // Legs
                ctx.fillRect(-25, -50, 20, 50);
                ctx.fillRect(5, -50, 20, 50);
                // Tie
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(-5, -130, 10, 50);
                // Head
                ctx.fillStyle = '#f1c40f'; // Skin/Hair
                ctx.fillRect(-20, -160, 40, 35);
                // Eyes
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(0, -150, 15, 5);

                // Energy Blade (Attack Only)
                if (this.state === 'ATTACK') {
                    ctx.fillStyle = 'rgba(0,255,255,0.6)';
                    ctx.beginPath();
                    ctx.moveTo(20, -100);
                    ctx.lineTo(120, -80); // Blade tip
                    ctx.lineTo(30, -60);
                    ctx.fill();
                }
            }

            drawElon() {
                if (this.state === 'ATTACK') ctx.rotate(0.2);
                if (this.state === 'HIT') ctx.rotate(-0.5);

                // Mech Armor
                ctx.fillStyle = '#222'; // Black Armor
                ctx.fillRect(-30, -135, 60, 85);
                // Metal Legs
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(-30, -50, 25, 50);
                ctx.fillRect(5, -50, 25, 50);
                // Chest Plate
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(-15, -110); ctx.lineTo(15, -90);
                ctx.moveTo(15, -110); ctx.lineTo(-15, -90);
                ctx.stroke();
                // Head
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(-20, -165, 40, 35);
                // Red Visor
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(-15, -155, 35, 8);

                // Rocket Fist (Attack Only)
                if (this.state === 'ATTACK') {
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(60, -90, 35, 0, Math.PI*2);
                    ctx.fill();
                    // Trail
                    ctx.fillStyle = 'rgba(255,200,0,0.5)';
                    ctx.fillRect(20, -100, 40, 20);
                }
            }
        }

        function updateUI() {
            document.getElementById('hp1').style.width = Math.max(0, p1.hp) + '%';
            document.getElementById('hp2').style.width = Math.max(0, p2.hp) + '%';
            if (p1.hp <= 0 || p2.hp <= 0) setTimeout(resetGame, 2000);
        }

        function resetGame() {
            p1.hp = 100; p2.hp = 100;
            p1.x = width * 0.2; p2.x = width * 0.8;
            updateUI();
        }

        /* ------------------------------------------------
           VISUAL ENGINE: NORTH CAROLINA RIVER
           ------------------------------------------------ */
        function drawBackground() {
            // 1. Sky Gradient
            const grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, '#2b5876'); // Deep Blue
            grad.addColorStop(1, '#4e4376'); // Purple Haze
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            // 2. Mountains (Parallax)
            drawMountainLayer(height * 0.5, '#1B2631', 0.1);
            drawMountainLayer(height * 0.65, '#283747', 0.3);

            // 3. River
            const riverY = height - 150;
            ctx.fillStyle = '#21618C';
            ctx.fillRect(0, riverY, width, 150);
            
            // River Shine (Sine waves)
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                for (let x = 0; x <= width; x+=20) {
                    const y = riverY + 20 + (i*25) + Math.sin(x*0.01 + time*0.05 + i)*5;
                    if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                }
                ctx.stroke();
            }

            // 4. Trees (Bank)
            ctx.fillStyle = '#0B3B0B';
            for(let x = -50; x < width+50; x+=60) {
                // Parallax tree movement
                const px = x - ((time * 2) % 1000) + (x > width ? 0 : 1000); // Loop roughly
                // Actually, let's keep trees static for the arena feel, maybe just wind
                const sway = Math.sin(time * 0.05 + x)*5;
                ctx.beginPath();
                ctx.moveTo(x + sway, height - 200);
                ctx.lineTo(x - 20, height);
                ctx.lineTo(x + 20, height);
                ctx.fill();
            }
        }

        function drawMountainLayer(baseY, color, speed) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, height);
            for (let x = 0; x <= width; x += 20) {
                // Simplex-ish noise
                const noise = Math.sin(x * 0.005) * 100 + Math.sin(x * 0.02) * 30;
                // Scroll
                const scroll = Math.sin(time * 0.01 * speed) * 50;
                ctx.lineTo(x, baseY - Math.abs(noise) + scroll);
            }
            ctx.lineTo(width, height);
            ctx.fill();
        }

        /* ------------------------------------------------
           AUDIO ENGINE: POKEMON BATTLE THEME
           ------------------------------------------------ */
        let actx;
        let nextNoteTime = 0;
        let beatCount = 0;

        const BASSLINE = [110, 110, 116, 116, 123, 123, 116, 116]; // Chromatic tension
        const ARP = [440, 554, 659, 880]; // High energy arp

        function initAudio() {
            if(actx) return;
            actx = new AC();
            nextNoteTime = actx.currentTime;
            scheduler();
        }

        function scheduler() {
            const bpm = 175; // Fast battle music
            const secondsPerBeat = 60.0 / bpm;
            const sixteenth = secondsPerBeat / 4;

            while (nextNoteTime < actx.currentTime + 0.1) {
                playStep(nextNoteTime, beatCount);
                nextNoteTime += sixteenth;
                beatCount = (beatCount + 1) % 32;
            }
            setTimeout(scheduler, 25);
        }

        function playStep(t, step) {
            const master = actx.createGain();
            master.gain.value = 0.15;
            master.connect(actx.destination);

            // Bass (8th notes)
            if (step % 2 === 0) {
                const osc = actx.createOscillator();
                osc.type = 'square';
                const note = BASSLINE[Math.floor(step/4) % BASSLINE.length];
                osc.frequency.setValueAtTime(note, t);
                
                const g = actx.createGain();
                g.gain.setValueAtTime(0.5, t);
                g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                
                osc.connect(g); g.connect(master);
                osc.start(t); osc.stop(t + 0.1);
            }

            // Snare (Noise) on 4, 12
            if (step % 8 === 4) {
                const buf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
                const d = buf.getChannelData(0);
                for(let i=0; i<d.length; i++) d[i] = Math.random() * 2 - 1;
                const src = actx.createBufferSource();
                src.buffer = buf;
                const g = actx.createGain();
                g.gain.setValueAtTime(0.4, t);
                g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                src.connect(g); g.connect(master);
                src.start(t);
            }

            // Arp (16ths)
            const osc = actx.createOscillator();
            osc.type = 'sawtooth';
            const arpNote = ARP[step % ARP.length] * (step % 8 === 0 ? 2 : 1); // Accent
            osc.frequency.setValueAtTime(arpNote, t);
            
            const g = actx.createGain();
            g.gain.setValueAtTime(0.1, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            
            osc.connect(g); g.connect(master);
            osc.start(t); osc.stop(t + 0.1);
        }

        function playSfx(type) {
            if(!actx) return;
            const osc = actx.createOscillator();
            const g = actx.createGain();
            g.connect(actx.destination);
            
            if (type === 'HIT') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, actx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, actx.currentTime + 0.1);
                g.gain.setValueAtTime(0.3, actx.currentTime);
                g.gain.linearRampToValueAtTime(0, actx.currentTime + 0.1);
            } else { // Swoosh
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, actx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, actx.currentTime + 0.1);
                g.gain.setValueAtTime(0.1, actx.currentTime);
                g.gain.linearRampToValueAtTime(0, actx.currentTime + 0.1);
            }
            
            osc.connect(g);
            osc.start(); osc.stop(actx.currentTime + 0.2);
        }

        /* ------------------------------------------------
           MAIN LOOP
           ------------------------------------------------ */
        function loop() {
            if (!isRunning) return;
            requestAnimationFrame(loop);

            if (timeScale > 0.5) {
                time++;
                p1.update(p2);
                p2.update(p1);
                p1.checkHit(p2);
                p2.checkHit(p1);
            }

            // Screenshake
            let sx = 0, sy = 0;
            if (shake > 0) {
                sx = (Math.random() - 0.5) * shake;
                sy = (Math.random() - 0.5) * shake;
                shake *= 0.9;
            }

            ctx.save();
            ctx.translate(sx, sy);

            drawBackground();
            
            // Draw Particles
            for(let i=particles.length-1; i>=0; i--) {
                particles[i].update();
                particles[i].draw();
                if(particles[i].life <= 0) particles.splice(i, 1);
            }

            p1.draw();
            p2.draw();

            ctx.restore();
        }

        function startGame() {
            document.getElementById('menu').style.display = 'none';
            initAudio();
            p1 = new Fighter('SAM', width * 0.2);
            p2 = new Fighter('ELON', width * 0.8);
            isRunning = true;
            loop();
        }

    </script>
</body>
</html>