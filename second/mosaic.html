<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BACARDI_SINGULARITY // FINAL_RENDER</title>
    <style>
        body {
            margin: 0;
            background-color: #020205; /* Deep Miami Night Black */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
        }

        #loader {
            position: absolute;
            z-index: 10;
            color: #00f3ff;
            border: 2px solid #00f3ff;
            padding: 20px 40px;
            font-size: 1.5rem;
            letter-spacing: 4px;
            cursor: pointer;
            background: rgba(0,0,0,0.9);
            text-transform: uppercase;
            transition: 0.3s;
        }

        #loader:hover {
            background: #00f3ff;
            color: #000;
            box-shadow: 0 0 30px #00f3ff;
        }
    </style>
</head>
<body>

    <div id="loader" onclick="initSystem()">
        Initialize Mosaic
    </div>
    <canvas id="mosaic"></canvas>

    <script>
        /* 
         * CONFIGURATION 
         * Adjusted for visual impact vs performance
         */
        const TILE_SIZE = 14; // Size of each mosaic tile
        const GAP = 1;        // Grout size
        const TEXT_STR = "THE SINGULARITY IS NIGH\nBUT BROTHERS\nVALUE YOUR SOUL";

        const canvas = document.getElementById('mosaic');
        const ctx = canvas.getContext('2d', { alpha: false });

        let width, height;
        let cols, rows;
        let tiles = [];
        let time = 0;
        let isRunning = false;

        /* ------------------------------------------------
           AUDIO ENGINE: THE ASCENSION
           ------------------------------------------------ */
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let actx;
        let waterGain, spiritGain;
        let evolution = 0; // 0.0 to 1.0

        function initAudio() {
            actx = new AudioContext();

            // 1. THE WATERFALL (Pink Noise + Lowpass)
            const bufferSize = actx.sampleRate * 2;
            const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5; 
            }
            let lastOut = 0;

            const waterNode = actx.createBufferSource();
            waterNode.buffer = buffer;
            waterNode.loop = true;

            const waterFilter = actx.createBiquadFilter();
            waterFilter.type = 'lowpass';
            waterFilter.frequency.value = 200;

            waterGain = actx.createGain();
            waterGain.gain.value = 0.5;

            waterNode.connect(waterFilter);
            waterFilter.connect(waterGain);
            waterGain.connect(actx.destination);
            waterNode.start();

            // 2. THE SPIRIT (FM Bell Synthesis)
            spiritGain = actx.createGain();
            spiritGain.gain.value = 0; // Starts silent
            spiritGain.connect(actx.destination);

            // Create a chord of "Glassy" oscillators
            const chord = [523.25, 783.99, 1046.50, 1318.51, 1567.98]; // C Major 9
            
            chord.forEach(freq => {
                const osc = actx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                // FM Modulation for "Bell" tone
                const mod = actx.createOscillator();
                mod.frequency.value = freq * 2.5; // Inharmonic ratio
                const modGain = actx.createGain();
                modGain.gain.value = 100;
                
                mod.connect(modGain);
                modGain.connect(osc.frequency);
                
                osc.connect(spiritGain);
                
                osc.start();
                mod.start();
            });
        }

        function updateAudio() {
            // Slowly shift balance from Water to Spirit
            evolution += 0.0003;
            if (evolution > 1) evolution = 1;

            waterGain.gain.value = 0.5 * (1 - evolution);
            spiritGain.gain.value = 0.2 * evolution;
        }

        /* ------------------------------------------------
           VISUAL ENGINE: THE GRID
           ------------------------------------------------ */

        class Tile {
            constructor(x, y, isText) {
                this.x = x;
                this.y = y;
                this.isText = isText;
                this.baseHue = isText ? 0 : 200; // Text uses different palette logic
                this.phase = Math.random() * Math.PI * 2;
            }

            draw(time, vPct) {
                // Calculate Color & Brightness based on Height (vPct)
                
                let h, s, l;
                
                // THE TEXT LOGIC (Higher Dimensional Language)
                if (this.isText) {
                    // Text oscillates rapidly between Gold and White
                    // We use a binary glitch effect to make it look like "Code"
                    const glitch = Math.sin(time * 20 + this.x * 0.5) > 0 ? 1 : 0;
                    h = 45; // Gold
                    s = 100;
                    l = 50 + (glitch * 50); 
                    
                    // Occasional "Alien" color shift
                    if (Math.random() > 0.95) h = 280; // Purple flash
                } 
                
                // THE BACKGROUND LOGIC
                else {
                    if (vPct < 0.4) {
                        // TOP: COMBUSTING SUNS (Fire)
                        // High turbulence noise
                        const noise = Math.sin(this.x * 0.2 + time * 3) * Math.sin(this.y * 0.2 - time);
                        h = 10 + (noise * 30); // Red to Orange
                        s = 100;
                        l = 30 + (noise * 20);
                        
                    } else if (vPct > 0.6) {
                        // BOTTOM: CUTSIE WATERFALL (Water)
                        // Smooth sine wave flow
                        const flow = Math.sin(this.x * 0.1 + this.y * 0.1 + time * 2);
                        h = 190 + (flow * 20); // Cyan to Blue
                        s = 80;
                        l = 30 + (flow * 10);

                    } else {
                        // MIDDLE: TRANSITION
                        h = 260; // Purple/Void
                        s = 50;
                        l = 10;
                    }
                }

                // RENDER TILE
                ctx.fillStyle = `hsl(${h}, ${s}%, ${l}%)`;
                
                // Draw the main square
                ctx.fillRect(this.x * TILE_SIZE, this.y * TILE_SIZE, TILE_SIZE - GAP, TILE_SIZE - GAP);

                // If Text, add a "Rune" dot in the center to make it look complex
                if (this.isText && l > 80) {
                    ctx.fillStyle = 'black';
                    ctx.fillRect((this.x * TILE_SIZE) + 4, (this.y * TILE_SIZE) + 4, 4, 4);
                }
            }
        }

        function setupGrid() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            cols = Math.floor(width / TILE_SIZE);
            rows = Math.floor(height / TILE_SIZE);
            tiles = [];

            // 1. ANALYZE TEXT
            // Create offscreen canvas to read text pixels
            const tCanvas = document.createElement('canvas');
            tCanvas.width = cols; // Low res!
            tCanvas.height = rows;
            const tCtx = tCanvas.getContext('2d');
            
            tCtx.fillStyle = 'black';
            tCtx.fillRect(0, 0, cols, rows);
            
            tCtx.fillStyle = 'white';
            tCtx.textAlign = 'center';
            tCtx.font = 'bold 12px monospace'; // Tiny font for tiny grid
            
            // Split lines
            const lines = TEXT_STR.split('\n');
            const centerY = rows / 2;
            
            lines.forEach((line, i) => {
                tCtx.fillText(line, cols / 2, centerY + (i * 10) - 10);
            });

            // Get Data
            const pData = tCtx.getImageData(0, 0, cols, rows).data;

            // 2. CREATE TILES
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    // Check alpha of text canvas
                    const idx = (y * cols + x) * 4;
                    const isText = pData[idx] > 100 || pData[idx+3] > 100; // Red channel or Alpha
                    
                    tiles.push(new Tile(x, y, isText));
                }
            }
        }

        function animate() {
            if (!isRunning) return;
            
            time += 0.03;
            updateAudio();

            // Background Clear (Grout color)
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);

            // Draw Tiles
            // We iterate a flat array for speed
            for (let i = 0; i < tiles.length; i++) {
                const t = tiles[i];
                const vPct = t.y / rows; // Vertical percentage (0 to 1)
                t.draw(time, vPct);
            }

            requestAnimationFrame(animate);
        }

        function initSystem() {
            const btn = document.getElementById('loader');
            btn.style.opacity = 0;
            setTimeout(() => btn.style.display = 'none', 500);
            
            setupGrid();
            initAudio();
            isRunning = true;
            animate();
        }

        window.addEventListener('resize', () => {
            if(isRunning) setupGrid();
        });

    </script>
</body>
</html>