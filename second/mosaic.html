<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SINGULARITY // HYPER_MOSAIC</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial Black', sans-serif;
        }

        /* INTENSITY FILTER */
        canvas {
            filter: contrast(1.4) saturate(1.5) brightness(1.1);
            box-shadow: 0 0 100px rgba(0, 255, 255, 0.2);
        }

        #ui {
            position: absolute;
            z-index: 10;
            text-align: center;
            mix-blend-mode: difference;
            pointer-events: none;
        }

        #btn {
            pointer-events: auto;
            color: #fff;
            border: 4px solid #fff;
            padding: 30px 60px;
            font-size: 2rem;
            font-weight: 900;
            letter-spacing: 5px;
            background: #000;
            cursor: pointer;
            transition: 0.1s;
            text-transform: uppercase;
            box-shadow: 0 0 50px #fff;
        }

        #btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 100px #fff;
        }

        #btn:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div id="btn" onclick="ignite()">
            INITIATE
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // CONFIG
        const TILE = 12; // Tile size
        const TEXT_STR = "THE SINGULARITY IS NIGH\nBUT BROTHERS\nVALUE YOUR SOUL";
        
        // STATE
        let width, height;
        let cols, rows;
        let offsetX, offsetY;
        let tiles = [];
        let time = 0;
        let isRunning = false;
        let mouse = { x: 0, y: 0 };

        // PRE-CALCULATED TEXT DATA
        let textMap = null;

        // --- RESIZE & CENTER LOGIC ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            // Calculate Grid dimensions
            cols = Math.floor(width / TILE);
            rows = Math.floor(height / TILE);

            // CALCULATE CENTERING OFFSET
            // We center the grid block within the window
            const gridW = cols * TILE;
            const gridH = rows * TILE;
            offsetX = Math.floor((width - gridW) / 2);
            offsetY = Math.floor((height - gridH) / 2);

            if (isRunning) buildGrid();
            else drawPreview();
        }

        // --- TEXT ANALYSIS ---
        function analyzeText() {
            const tCan = document.createElement('canvas');
            tCan.width = cols;
            tCan.height = rows;
            const tCtx = tCan.getContext('2d');

            // Fill Black
            tCtx.fillStyle = '#000';
            tCtx.fillRect(0, 0, cols, rows);

            // Draw Text White
            tCtx.fillStyle = '#fff';
            tCtx.textAlign = 'center';
            tCtx.textBaseline = 'middle';
            
            // Dynamic massive font
            tCtx.font = '900 16px "Arial Black"'; 

            const lines = TEXT_STR.split('\n');
            const lh = 20; // Line height in tiles
            const totalH = lines.length * lh;
            const startY = (rows / 2) - (totalH / 2) + (lh/2);

            lines.forEach((line, i) => {
                tCtx.fillText(line, cols / 2, startY + (i * lh));
            });

            return tCtx.getImageData(0, 0, cols, rows).data;
        }

        // --- BUILD TILES ---
        function buildGrid() {
            tiles = [];
            const data = analyzeText();

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const i = (y * cols + x) * 4;
                    // If Red channel is bright, it's text
                    const isText = data[i] > 128;
                    
                    tiles.push({
                        x: x,
                        y: y,
                        isText: isText,
                        // Pre-calculate phase for speed
                        phase: Math.random() * Math.PI * 2,
                        // Random "Glitch" speed for each tile
                        speed: 1 + Math.random() * 3
                    });
                }
            }
        }

        // --- RENDER LOOP ---
        function draw() {
            if (!isRunning) return;
            
            // SPEED MULTIPLIER
            time += 0.15; 
            updateAudio();

            // Clear background to deep void
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Shift context to center the grid
            ctx.save();
            ctx.translate(offsetX, offsetY);

            for (let i = 0; i < tiles.length; i++) {
                const t = tiles[i];
                
                // COORDS
                const px = t.x * TILE;
                const py = t.y * TILE;

                // GLOBAL GRADIENT (0 = Top, 1 = Bottom)
                const vPct = t.y / rows; 

                let h, s, l;

                // --- TEXT LAYER (HIGH VOLTAGE) ---
                if (t.isText) {
                    // Rapid strobe
                    const strobe = Math.sin(time * 20 + t.x); 
                    
                    if (strobe > 0.5) {
                        h = 50; s = 100; l = 100; // BLINDING WHITE
                    } else {
                        h = 40; s = 100; l = 50; // GOLD
                    }

                    // Random Glitch Artifacts
                    if (Math.random() > 0.95) {
                        h = 180; l = 80; // CYAN FLASH
                    }
                } 
                
                // --- BACKGROUND LAYER (CHAOS) ---
                else {
                    // Interaction force
                    const dx = (px + offsetX) - mouse.x;
                    const dy = (py + offsetY) - mouse.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const force = Math.max(0, (400 - dist) / 400); // Mouse radius

                    // 1. TOP: PLASMA FIRE
                    if (vPct < 0.4) {
                        // Fast, jagged noise
                        const n = Math.sin(t.x * 0.5 + time * 5) * Math.tan(t.y * 0.1 - time * 2);
                        
                        h = 10 + (n * 20); // Red/Orange
                        s = 100;
                        l = 30 + (n * 20) + (force * 70); // Mouse makes it explode
                        
                        if (Math.random() > 0.98) l = 100; // Sparks
                    }
                    
                    // 2. BOTTOM: RAPIDS
                    else if (vPct > 0.6) {
                        // Fast flowing sine waves
                        const flow = Math.sin(t.x * 0.2 + t.y * 0.2 + time * 3);
                        h = 200 + (flow * 10);
                        s = 90;
                        l = 30 + (flow * 20) + (force * 60);
                    }
                    
                    // 3. MIDDLE: THE VOID TRANSITION
                    else {
                        h = 270; 
                        s = 50;
                        l = 5 + (force * 30);
                    }
                }

                // DRAW
                ctx.fillStyle = `hsl(${h}, ${s}%, ${l}%)`;
                // Tiny gap for grout line
                ctx.fillRect(px, py, TILE - 1, TILE - 1);
                
                // INTENSITY BLOOM CENTER
                if (l > 80) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(px + 2, py + 2, TILE - 5, TILE - 5);
                }
            }

            ctx.restore();
            requestAnimationFrame(draw);
        }

        function drawPreview() {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            
            // Draw a target rect where the grid will be
            const gw = cols * TILE;
            const gh = rows * TILE;
            
            ctx.strokeRect(offsetX, offsetY, gw, gh);
            ctx.moveTo(0, 0); ctx.lineTo(width, height);
            ctx.moveTo(width, 0); ctx.lineTo(0, height);
            ctx.stroke();
        }

        /* ------------------------------------------------
           AUDIO (UNCHANGED BUT CONNECTED)
           ------------------------------------------------ */
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let actx, waterGain, spiritGain, evolution = 0;

        function initAudio() {
            actx = new AudioContext();
            // Water Drone
            const bufferSize = actx.sampleRate * 2;
            const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5; 
            }
            const noise = actx.createBufferSource();
            noise.buffer = buffer;
            noise.loop = true;
            const filter = actx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 300;
            waterGain = actx.createGain();
            waterGain.gain.value = 0.5;
            noise.connect(filter);
            filter.connect(waterGain);
            waterGain.connect(actx.destination);
            noise.start();

            // Spirit
            spiritGain = actx.createGain();
            spiritGain.gain.value = 0;
            spiritGain.connect(actx.destination);
            [523.25, 783.99, 1046.50, 1318.51].forEach(f => {
                const osc = actx.createOscillator();
                osc.frequency.value = f;
                osc.connect(spiritGain);
                osc.start();
            });
        }

        function updateAudio() {
            evolution += 0.001; // Faster evolution
            if (evolution > 1) evolution = 1;
            if (waterGain) waterGain.gain.value = 0.5 * (1 - evolution);
            if (spiritGain) spiritGain.gain.value = 0.15 * evolution;
        }

        // INIT
        function ignite() {
            const ui = document.getElementById('ui');
            ui.style.opacity = 0;
            setTimeout(() => ui.style.display = 'none', 500);
            
            resize(); // Recalculate everything
            buildGrid(); // Build grid with correct offsets
            initAudio();
            isRunning = true;
            draw();
        }

        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        
        // Initial call
        resize();

    </script>
</body>
</html>