<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MOSAIC SINGULARITY // REDUX</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* THE RENDER LAYER (Low Res, Scaled Up) */
        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* CRITICAL: Makes it look like tiles, not blurry */
            z-index: 1;
        }

        /* THE GROUT LAYER (The Grid Mesh) */
        #grout {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: linear-gradient(rgba(0,0,0,0.5) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0,0,0,0.5) 1px, transparent 1px);
            background-size: 8px 8px; /* Matches the tile scale */
            z-index: 2;
            pointer-events: none;
        }

        /* UI */
        #overlay {
            position: absolute;
            z-index: 10;
            text-align: center;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 40px;
            border: 1px solid white;
            transition: opacity 0.5s;
            cursor: pointer;
        }

        h1 { margin: 0; font-size: 2rem; letter-spacing: 2px; text-transform: uppercase; }
        p { color: cyan; font-size: 0.8rem; margin-top: 10px; }

    </style>
</head>
<body>

    <canvas id="renderCanvas"></canvas>
    <div id="grout"></div>

    <div id="overlay" onclick="ignite()">
        <h1>IGNITE THE MOSAIC</h1>
        <p>[ GPU OPTIMIZED ]</p>
    </div>

    <script>
        const canvas = document.getElementById('renderCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // No transparency = faster

        // CONFIG
        const SCALE = 8; // The "Tile Size" (Lower = more detail, Higher = faster)
        let width, height;
        let cols, rows;
        let time = 0;
        let isRunning = false;

        // OFFSCREEN TEXT BUFFER (To mask the English)
        let textCtx;
        let textData = []; 

        function resize() {
            // Set internal resolution to 1/8th of screen
            width = Math.ceil(window.innerWidth / SCALE);
            height = Math.ceil(window.innerHeight / SCALE);
            canvas.width = width;
            canvas.height = height;

            // Update Grout Grid to match scale
            document.getElementById('grout').style.backgroundSize = `${SCALE}px ${SCALE}px`;

            // Prepare Text Map
            const tCan = document.createElement('canvas');
            tCan.width = width;
            tCan.height = height;
            textCtx = tCan.getContext('2d');
            renderTextMap();
        }

        function renderTextMap() {
            textCtx.fillStyle = 'black';
            textCtx.fillRect(0, 0, width, height);
            
            textCtx.fillStyle = 'white';
            textCtx.textAlign = 'center';
            textCtx.font = 'bold 14px monospace'; // Small font for small canvas

            const lines = [
                "THE SINGULARITY IS NIGH",
                "BUT BROTHERS",
                "VALUE YOUR SOUL"
            ];
            
            const startY = height/2 - 10;
            lines.forEach((l, i) => {
                textCtx.fillText(l, width/2, startY + (i * 15));
            });

            // Store pixel data array for fast lookup in the loop
            textData = textCtx.getImageData(0, 0, width, height).data;
        }

        window.addEventListener('resize', resize);
        resize();

        /* ------------------------------------------------------
           AUDIO ENGINE: THE LOFTY ASCENSION
           ------------------------------------------------------ */
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let actx;
        let evolution = 0;

        // Nodes
        let waterfallNode, waterfallGain, waterfallFilter;
        let spiritOscs = [];
        let spiritGain;

        function initAudio() {
            actx = new AudioContext();

            // 1. THE WATERFALL (Pink Noise)
            const bufferSize = actx.sampleRate * 2;
            const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5; 
            }
            let lastOut = 0;

            waterfallNode = actx.createBufferSource();
            waterfallNode.buffer = buffer;
            waterfallNode.loop = true;

            waterfallFilter = actx.createBiquadFilter();
            waterfallFilter.type = 'lowpass';
            waterfallFilter.frequency.value = 300; // Deep rumble

            waterfallGain = actx.createGain();
            waterfallGain.gain.value = 0.8;

            waterfallNode.connect(waterfallFilter);
            waterfallFilter.connect(waterfallGain);
            waterfallGain.connect(actx.destination);
            waterfallNode.start();

            // 2. THE SPIRIT (Sine harmonics)
            spiritGain = actx.createGain();
            spiritGain.gain.value = 0;
            spiritGain.connect(actx.destination);

            const freqs = [523.25, 659.25, 783.99, 1046.50]; // C Major
            freqs.forEach(f => {
                const osc = actx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = f;
                osc.connect(spiritGain);
                osc.start();
                spiritOscs.push(osc);
            });
        }

        function updateAudio() {
            // Slow evolution from Water -> Spirit
            evolution += 0.0002; 
            if (evolution > 1) evolution = 1;

            // Waterfall fades out / gets thinner
            waterfallGain.gain.value = 0.6 * (1 - evolution);
            waterfallFilter.frequency.value = 300 + (evolution * 1000);

            // Spirit fades in / detunes slightly for "Higher Dimension" feel
            spiritGain.gain.value = evolution * 0.3;
            
            spiritOscs.forEach((osc, i) => {
                // Wobble the pitch slightly for that "glass" sound
                osc.frequency.setValueAtTime(
                    osc.frequency.baseVal + Math.sin(time * 5 + i) * 2, 
                    actx.currentTime
                );
            });
        }

        /* ------------------------------------------------------
           VISUAL LOOP: PIXEL MANIPULATION
           ------------------------------------------------------ */

        function render() {
            if (!isRunning) return;
            
            time += 0.05;
            updateAudio();

            // We manipulate the pixel array directly for speed
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                const vPct = y / height; // 0.0 (Top) to 1.0 (Bottom)
                
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    
                    // NOISE GENERATION (Math based, no external assets)
                    const noise = Math.sin(x * 0.1 + time) + Math.cos(y * 0.1 - time);
                    const sparkle = Math.random() > 0.98 ? 1.0 : 0.0;

                    let r, g, b;

                    // 1. CHECK TEXT MASK
                    if (textData[i+3] > 100) { // If this pixel is text
                        // SHINY HIGHER DIMENSIONAL LANGUAGE
                        // High speed color shifting
                        const h = (time * 100) + (x * 10);
                        // Convert HSL to RGB roughly for speed
                        r = 200 + Math.sin(h * 0.1) * 55;
                        g = 200 + Math.cos(h * 0.1) * 55;
                        b = 255;
                        // Add Glitch
                        if (Math.random() > 0.9) { r=255; g=255; b=255; }
                    } 
                    else {
                        // 2. BACKGROUND PHYSICS
                        
                        if (vPct < 0.4) {
                            // TOP: COMBUSTING SUNS (Red/Orange/Yellow)
                            // More noise at top
                            const heat = (noise * 0.5) + 0.5; // 0 to 1
                            r = 255;
                            g = heat * 150; // Red to Orange
                            b = 0;
                            if(Math.random() > 0.95) { r=255; g=255; b=200; } // Solar Flare

                        } else if (vPct > 0.6) {
                            // BOTTOM: CUTSIE WATERFALL (Cyan/Blue)
                            // Smooth flowing noise
                            const flow = Math.sin(x * 0.2 + y * 0.1 + time * 2);
                            r = 0;
                            g = 100 + (flow * 50);
                            b = 200 + (flow * 55);
                            if (sparkle) { r=200; g=255; b=255; } // Foam

                        } else {
                            // MIDDLE: TRANSITION (Purple/Mist)
                            r = 100; 
                            g = 50;
                            b = 100 + (noise * 50);
                        }
                    }

                    // WRITE PIXEL
                    data[i] = r;
                    data[i+1] = g;
                    data[i+2] = b;
                    data[i+3] = 255; // Alpha
                }
            }

            ctx.putImageData(imageData, 0, 0);
            requestAnimationFrame(render);
        }

        function ignite() {
            const overlay = document.getElementById('overlay');
            overlay.style.opacity = 0;
            setTimeout(() => overlay.style.display = 'none', 500);
            
            initAudio();
            isRunning = true;
            render();
        }

    </script>
</body>
</html>