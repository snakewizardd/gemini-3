<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASI // THE RECONCILIATION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');

        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Cinzel', serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
            /* Dreamy Bloom */
            filter: blur(0.5px) contrast(1.2) brightness(1.3);
        }

        #ui-layer {
            position: absolute;
            z-index: 100;
            text-align: center;
            color: #fff;
            pointer-events: none;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,0,0,0.8) 100%);
        }

        h1 {
            font-size: 4vw;
            text-transform: uppercase;
            letter-spacing: 15px;
            text-shadow: 0 0 20px #ffd700; /* Gold Shadow */
            margin-bottom: 20px;
            animation: pulse 3s infinite;
        }

        #btn {
            pointer-events: auto;
            border: 1px solid #ffd700;
            color: #ffd700;
            background: rgba(0,0,0,0.5);
            padding: 20px 60px;
            font-size: 1.2rem;
            letter-spacing: 5px;
            cursor: pointer;
            transition: 0.5s;
            text-transform: uppercase;
            font-family: 'Cinzel', serif;
        }

        #btn:hover {
            background: #ffd700;
            color: #000;
            box-shadow: 0 0 50px #ffd700;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        /* Floating Text particles */
        .spirit-text {
            position: absolute;
            color: rgba(255,255,255,0.5);
            font-size: 10px;
            pointer-events: none;
            animation: rise 5s linear forwards;
        }
        @keyframes rise { to { transform: translateY(-200px); opacity: 0; } }

    </style>
</head>
<body>

    <canvas id="heaven"></canvas>
    
    <div id="ui-layer">
        <h1>THE RECONCILIATION</h1>
        <div id="btn" onclick="startAudio()">INITIATE HARMONY</div>
    </div>

    <script>
        // --- GRAPHICS SETUP ---
        const canvas = document.getElementById('heaven');
        const ctx = canvas.getContext('2d', { alpha: false });

        let width, height, cx, cy;
        let time = 0;
        let mouse = { x: 0, y: 0 };
        let particles = [];
        
        // Audio State
        let audioRunning = false;

        // --- RESIZE HANDLER (FIXED) ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            
            // Reset transform to avoid exponential scaling bug
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            canvas.width = width;
            canvas.height = height;
            
            cx = width / 2;
            cy = height / 2;
        }
        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        
        // Initial resize call
        resize();


        /* ------------------------------------------------
           VISUAL ENGINE: STAIRWAY TO ASI
           ------------------------------------------------ */

        function drawStairs() {
            const steps = 40;
            const vanishingY = height * 0.2; // Top of screen
            const startY = height; // Bottom of screen
            
            // Perspective Mouse Pan
            const pan = (mouse.x - cx) * 0.1;

            ctx.save();
            ctx.translate(-pan, 0);

            // Glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ffd700';

            for (let i = 0; i < steps; i++) {
                const t = i / steps; // 0 (bottom) to 1 (top)
                
                // Perspective math
                const y = startY - (t * (startY - vanishingY));
                const w = (1 - t) * 800 + 20; // Get narrower at top
                const x = cx - (w / 2);
                const stepHeight = (1 - t) * 20;

                // Gold Gradient
                const alpha = 1 - t; 
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha * 0.5})`;
                
                // Floating motion
                const wave = Math.sin(time * 2 + i * 0.5) * 5;

                ctx.fillRect(x, y + wave, w, stepHeight);
            }
            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function drawSingularity() {
            // The blinding light at the top
            const x = cx;
            const y = height * 0.2;
            
            const grad = ctx.createRadialGradient(x, y, 0, x, y, width * 0.6);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(0.2, 'rgba(255, 255, 200, 0.5)');
            grad.addColorStop(1, 'transparent');

            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawAvatar(x, y, color, name, t) {
            // The Seraphim (Sam/Elon)
            // Hovering geometric light beings
            
            const hover = Math.sin(t * 2) * 10;
            const size = 60;

            ctx.save();
            ctx.translate(x, y + hover);

            // 1. Aura
            const grad = ctx.createRadialGradient(0, 0, 10, 0, 0, 100);
            grad.addColorStop(0, color);
            grad.addColorStop(1, 'transparent');
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, 100, 0, Math.PI*2); ctx.fill();

            // 2. Sacred Geometry (Rotating Rings)
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.rotate(t);
            ctx.arc(0, 0, 30, 0, Math.PI*2);
            ctx.stroke();
            
            ctx.rotate(-t * 2);
            ctx.beginPath();
            ctx.rect(-20, -20, 40, 40); // Diamond
            ctx.stroke();

            // 3. Name
            ctx.fillStyle = '#fff';
            ctx.font = '14px Cinzel';
            ctx.textAlign = 'center';
            ctx.fillText(name, 0, 120);

            ctx.restore();
        }

        function drawGrid() {
            // Wireframe Floor
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            const horizon = height * 0.2;
            
            // Perspective Lines
            for(let i=-10; i<=10; i++) {
                const x = cx + (i * 100);
                ctx.beginPath();
                ctx.moveTo(x, height);
                ctx.lineTo(cx + (i * 10), horizon); // Vanishing point
                ctx.stroke();
            }
            
            // Horizontal Moving Lines
            const speed = (time * 100) % 100;
            for(let i=0; i<20; i++) {
                const y = horizon + Math.pow(i/20, 3) * (height - horizon);
                if (y > horizon) {
                    ctx.beginPath();
                    ctx.moveTo(0, y + speed);
                    ctx.lineTo(width, y + speed);
                    ctx.stroke();
                }
            }
        }

        function render() {
            requestAnimationFrame(render);
            time += 0.01;

            // Clear Background (Deep Void)
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            bgGrad.addColorStop(0, '#111');
            bgGrad.addColorStop(1, '#000');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            drawGrid();
            drawSingularity();
            drawStaircase();

            // Draw Sam (Left) - Cyan/Gold
            drawAvatar(cx - 300, height * 0.5, '#00ffff', 'SAM', time);
            
            // Draw Elon (Right) - Magenta/Gold
            drawAvatar(cx + 300, height * 0.5, '#ff00ff', 'ELON', time + 1.5);

            // Spawn Float Text
            if (audioRunning && Math.random() > 0.98) {
                const div = document.createElement('div');
                div.className = 'spirit-text';
                div.innerText = ["HARMONY", "ALIGNMENT", "AGI", "LOVE", "UNITY"][Math.floor(Math.random()*5)];
                div.style.left = (Math.random() * width) + 'px';
                div.style.top = height + 'px';
                document.body.appendChild(div);
                setTimeout(() => div.remove(), 5000);
            }
        }

        // START RENDER LOOP IMMEDIATELY
        render();


        /* ------------------------------------------------
           AUDIO ENGINE: THE CHOIR
           ------------------------------------------------ */
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let actx;
        let masterGain;
        let reverb;
        
        const CHORDS = [
            [130.81, 164.81, 196.00, 261.63], // C Major
            [174.61, 220.00, 261.63, 349.23], // F Major
            [220.00, 261.63, 329.63, 440.00], // Am
            [196.00, 246.94, 293.66, 392.00]  // G Major
        ];
        
        let chordIndex = 0;

        function startAudio() {
            if(audioRunning) return;
            
            // Hide UI
            document.getElementById('ui-layer').style.opacity = 0;
            
            actx = new AudioContext();
            masterGain = actx.createGain();
            masterGain.gain.value = 0.4;
            
            // Simple Reverb (Delay Line approach for CPU safety)
            const delay = actx.createDelay();
            delay.delayTime.value = 0.3;
            const feedback = actx.createGain();
            feedback.gain.value = 0.6;
            
            masterGain.connect(delay);
            delay.connect(feedback);
            feedback.connect(delay);
            delay.connect(actx.destination);
            masterGain.connect(actx.destination);
            
            audioRunning = true;
            playSequence();
        }

        function playVoice(freq, panVal) {
            const osc = actx.createOscillator();
            const gain = actx.createGain();
            const pan = actx.createStereoPanner();
            
            // SYNTHESIS: Triangle + Sine for "Angelic" tone
            osc.type = 'triangle';
            osc.frequency.value = freq;

            // ENVELOPE (Swell)
            const now = actx.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.1, now + 2); // Slow attack
            gain.gain.exponentialRampToValueAtTime(0.001, now + 6); // Long release

            // PANNING (Sam Left, Elon Right)
            pan.pan.value = panVal;

            osc.connect(pan);
            pan.connect(gain);
            gain.connect(masterGain);

            osc.start(now);
            osc.stop(now + 6);
        }

        function playSequence() {
            const now = actx.currentTime;
            const chord = CHORDS[chordIndex % CHORDS.length];

            // SAM (High Notes - Left)
            playVoice(chord[2] * 2, -0.5);
            playVoice(chord[3] * 2, -0.3);

            // ELON (Low Notes - Right)
            playVoice(chord[0], 0.5);
            playVoice(chord[1], 0.3);

            chordIndex++;
            
            // Next Chord in 4 seconds
            setTimeout(playSequence, 4000);
        }

    </script>
</body>
</html>