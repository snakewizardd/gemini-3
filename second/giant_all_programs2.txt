<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>THE AVIARY // 61 FLUTES</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Italiana&display=swap');

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            cursor: none; /* NO MOUSE INTERACTION */
            font-family: 'Italiana', serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            z-index: 1;
        }

        #start-overlay {
            position: absolute;
            z-index: 999;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            transition: opacity 3s cubic-bezier(0.4, 0, 1, 1);
            cursor: pointer;
        }

        .title {
            text-align: center;
            color: #d8c0a8;
            opacity: 0.8;
            animation: breathe 4s infinite ease-in-out;
        }

        h1 {
            font-size: 3rem;
            margin: 0;
            letter-spacing: 15px;
            font-weight: 400;
            text-shadow: 0 0 20px #d8c0a8;
        }
        
        p {
            margin-top: 10px;
            letter-spacing: 5px;
            font-size: 0.9rem;
            color: #777;
        }

        @keyframes breathe {
            0%, 100% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .dissolve {
            opacity: 0;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <!-- VISUALS -->
    <canvas id="canvas"></canvas>

    <!-- START GATE (REQUIRED BY BROWSERS) -->
    <div id="start-overlay">
        <div class="title">
            <h1>61 FLUTES</h1>
            <p>TOUCH TO IGNITE THE INFINITE</p>
        </div>
    </div>

    <script>
        /**
         * THE AVIARY: ETERNAL AUTOPLAY MASTERPIECE
         * 7 Layers of Audio / 61 Virtual Flute Agents
         * No input required after initialization.
         */

        /* --- CONFIGURATION --- */
        const TOTAL_FLUTES = 61; 
        const LAYERS = 7;
        
        // E Major Lydian / Ethereal Scale logic
        const SCALE_RATIOS = [1, 1.125, 1.25, 1.406, 1.5, 1.666, 1.875]; // Root, 2, 3, #4, 5, 6, 7
        const BASE_PITCH = 82.41; // Low E
        
        // Global Systems
        let ctx, canvas, w, h;
        let actx, master, reverb;
        let audioRunning = false;
        let startOverlay = document.getElementById('start-overlay');
        
        // Time
        let time = 0;

        /* --- VISUAL SYSTEM (THE AURORA) --- */
        const flows = [];
        
        function initVisuals() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resize();
            window.addEventListener('resize', resize);
            
            // Create visual streams corresponding to the 7 layers
            for(let i=0; i<LAYERS; i++) {
                flows.push({
                    y: (h / LAYERS) * i,
                    points: [],
                    color: `hsla(${20 + i*5}, 60%, 50%, 0.1)`,
                    speed: 0.001 + (i * 0.0005)
                });
            }
        }
        
        function resize() {
            w = window.innerWidth;
            h = window.innerHeight;
            canvas.width = w;
            canvas.height = h;
        }

        // Simulating flow fields
        function drawVisuals() {
            if(!audioRunning) return;
            
            // Deep Trail Fade
            ctx.fillStyle = 'rgba(0, 0, 2, 0.05)';
            ctx.fillRect(0, 0, w, h);
            
            ctx.globalCompositeOperation = 'screen';
            time += 0.01;

            flows.forEach((layer, idx) => {
                const layerFluctuation = Math.sin(time + idx) * 50;
                
                ctx.beginPath();
                ctx.moveTo(0, layer.y);

                // Create organic wave based on Flute Activity
                for (let x = 0; x < w; x += 30) {
                    const noise = Math.sin(x * 0.002 + time * layer.speed * 20) 
                                + Math.cos(x * 0.01 - time);
                    const y = layer.y + layerFluctuation + (noise * (h/6));
                    
                    // Draw random sparks for high notes
                    if (Math.random() > 0.999 && idx > 4) {
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(x, y, 2, 2);
                    }
                    
                    ctx.lineTo(x, y);
                }

                ctx.strokeStyle = `hsla(${10 + idx * 8}, 70%, ${50 + idx * 5}%, 0.2)`;
                ctx.lineWidth = 2 + (idx * 2); // Thicker for higher layers
                ctx.shadowBlur = 20;
                ctx.shadowColor = ctx.strokeStyle;
                ctx.stroke();
            });
            
            ctx.globalCompositeOperation = 'source-over';
            requestAnimationFrame(drawVisuals);
        }

        /* --- AUDIO SYSTEM (THE 61 FLUTES) --- */
        
        // Single Global Noise Buffer (For Breath sounds) - Optimization
        let noiseBuffer;

        function initAudio() {
            actx = new (window.AudioContext || window.webkitAudioContext)();
            master = actx.createGain();
            
            // Limit master volume to prevent clipping from 61 voices
            master.gain.value = 0.6; 
            
            /* --- REVERB (The Cathedral) --- */
            reverb = actx.createConvolver();
            const rate = actx.sampleRate;
            const length = rate * 6; // 6 seconds tail
            const decay = 2.5;
            const imp = actx.createBuffer(2, length, rate);
            
            for (let c = 0; c < 2; c++) {
                const chan = imp.getChannelData(c);
                for (let i = 0; i < length; i++) {
                    chan[i] = (Math.random() * 2 - 1) * Math.pow(1 - (i / length), decay);
                }
            }
            reverb.buffer = imp;
            
            master.connect(reverb);
            reverb.connect(actx.destination);
            // Dry mix
            master.connect(actx.destination);

            /* --- NOISE GEN (Breath) --- */
            const bSize = 2 * rate;
            noiseBuffer = actx.createBuffer(1, bSize, rate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bSize; i++) output[i] = Math.random() * 2 - 1;

            startOrchestra();
        }

        /**
         * THE FLUTE VOICE 
         * Procedural Synthesis Node
         */
        class FluteVoice {
            constructor(layerID) {
                this.layer = layerID;
                this.isPlaying = false;
                this.osc = null;
                this.gain = null;
                this.breathGain = null;
            }

            play(pitch, duration) {
                if(this.isPlaying) return;
                this.isPlaying = true;
                const t = actx.currentTime;
                const release = 2.0;

                // 1. TONE OSCILLATOR
                this.osc = actx.createOscillator();
                this.osc.type = 'sine'; // Flute core is Sine
                this.osc.frequency.value = pitch;

                // Vibrato LFO (Essential for realism)
                const lfo = actx.createOscillator();
                lfo.frequency.value = 4 + Math.random(); // 4-5hz wobbles
                const lfoGain = actx.createGain();
                lfoGain.gain.value = pitch * 0.02; // Depth
                lfo.connect(lfoGain);
                lfoGain.connect(this.osc.frequency);
                lfo.start(t);

                // 2. BREATH NOISE (The "Air" sound)
                const breathNode = actx.createBufferSource();
                breathNode.buffer = noiseBuffer;
                breathNode.loop = true;
                // Pitch shift noise down/up based on layer
                breathNode.playbackRate.value = 0.5 + (this.layer * 0.1); 

                // ENVELOPES
                this.gain = actx.createGain(); // Tone Gain
                this.breathGain = actx.createGain(); // Noise Gain

                // Filter the noise (flutes aren't white noise, they are "chiff")
                const noiseFilter = actx.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = pitch * 1.5;
                noiseFilter.Q.value = 1;

                // Wiring
                this.osc.connect(this.gain);
                breathNode.connect(noiseFilter);
                noiseFilter.connect(this.breathGain);
                
                this.gain.connect(master);
                this.breathGain.connect(master);

                // --- SHAPING THE SOUND ---
                // Lower layers = slower, heavier
                // Higher layers = fast, sharp
                const attack = 0.1 + (Math.random() * 0.5) + ((7-this.layer)*0.1);
                const sustainVol = 0.05 / (1 + (Math.log(TOTAL_FLUTES) * 0.2)); // Dynamic mix mixing

                // Tone Envelope (Swelling)
                this.gain.gain.setValueAtTime(0, t);
                this.gain.gain.linearRampToValueAtTime(sustainVol, t + attack);
                this.gain.gain.linearRampToValueAtTime(sustainVol * 0.8, t + duration * 0.5); // Breathe out
                this.gain.gain.exponentialRampToValueAtTime(0.001, t + duration + release);

                // Breath Envelope (Short puff at start + low sustain)
                this.breathGain.gain.setValueAtTime(0, t);
                this.breathGain.gain.linearRampToValueAtTime(sustainVol * 0.5, t + 0.05); // Initial "Chiff"
                this.breathGain.gain.exponentialRampToValueAtTime(sustainVol * 0.1, t + attack);
                this.breathGain.gain.linearRampToValueAtTime(0, t + duration);

                // Start
                this.osc.start(t);
                breathNode.start(t);

                // Stop logic
                const killTime = (duration + release + 1) * 1000;
                
                setTimeout(() => {
                    if (this.osc) {
                        this.osc.stop(); 
                        breathNode.stop();
                        this.osc.disconnect();
                        this.gain.disconnect();
                        lfo.stop();
                        this.isPlaying = false;
                    }
                }, killTime);
            }
        }

        /* --- THE CONDUCTOR (Zero Human Interaction) --- */
        
        // Create the army of flutes
        const flutes = [];
        
        function startOrchestra() {
            // Instantiate 61 Flutes
            // Layer Dist:
            // 0 (Bass): 5
            // 1 (Tenor): 10
            // 2 (Mid): 12
            // 3 (Alto): 10
            // 4 (Soprano): 8
            // 5 (Descant): 8
            // 6 (Piccolo): 8
            const distro = [5, 10, 12, 10, 8, 8, 8]; // Sums to 61
            
            let idCount = 0;
            distro.forEach((count, layerIdx) => {
                for(let i=0; i<count; i++) {
                    flutes.push(new FluteVoice(layerIdx));
                }
            });

            console.log(`Orchestra assembled. ${flutes.length} flutes standing by.`);
            
            conduct();
        }

        // Automatic Generative Logic
        function conduct() {
            const now = actx.currentTime;
            
            // Loop through all 61 flutes and decide if they should play
            flutes.forEach(f => {
                if (f.isPlaying) return; // Busy flutes ignore conductor
                
                // Probabilities tuned per layer (lower layers = slower, higher = busier)
                const pBase = 0.001 + (f.layer * 0.002); 
                
                if (Math.random() < pBase) {
                    
                    // --- MUSIC THEORY ENGINE ---
                    // Pitch calc
                    const octaveOffset = Math.floor(f.layer / 2); // 0, 0, 1, 1, 2, 2, 3...
                    const octaveMultiplier = Math.pow(2, octaveOffset);
                    
                    // Select a note from scale ratios
                    const noteIdx = Math.floor(Math.random() * SCALE_RATIOS.length);
                    let freq = BASE_PITCH * SCALE_RATIOS[noteIdx] * octaveMultiplier;
                    
                    // Layer 6 (Piccolo) often plays harmonic overtones
                    if (f.layer === 6) freq *= 2; 

                    // Duration based on layer
                    // Bass flutes hold for 6-12s, Piccolos for 1-3s
                    const duration = 2 + (Math.random() * 4) + ((6 - f.layer) * 2);

                    f.play(freq, duration);
                }
            });

            // Conductor ticks every 100ms
            setTimeout(conduct, 100);
        }

        /* --- INITIALIZATION HANDLER --- */
        startOverlay.addEventListener('click', () => {
            initAudio();
            initVisuals();
            actx.resume();
            
            startOverlay.classList.add('dissolve');
            audioRunning = true;
            
            // Start visuals loop
            requestAnimationFrame(drawVisuals);

            // Hide the cursor logic manually for browser compat
            document.body.style.cursor = 'none';
        });

    </script>
</body>
</html>

PROGRAM 1
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TERMINUS // FULL ARRANGEMENT ENGINE</title>
<style>
    :root { --p: #ff3300; --s: #fff; --bg: #050505; }
    body { 
        margin: 0; background: var(--bg); overflow: hidden; 
        font-family: 'Courier New', monospace; color: var(--s);
        display: flex; justify-content: center; align-items: center; height: 100vh;
        user-select: none;
    }
    canvas { position: absolute; top: 0; left: 0; z-index: 1; }
    
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        pointer-events: none;
    }

    #panel {
        background: rgba(0,0,0,0.9); padding: 40px; border: 1px solid var(--p);
        text-align: center; pointer-events: auto; box-shadow: 0 0 100px rgba(255, 51, 0, 0.2);
        transition: opacity 0.5s;
    }

    h1 { font-size: 3rem; margin: 0 0 20px 0; letter-spacing: 8px; color: var(--p); text-shadow: 0 0 10px var(--p); }
    
    button {
        background: var(--p); color: #000; border: none; padding: 15px 40px;
        font-size: 1.2rem; font-weight: 900; letter-spacing: 2px; cursor: pointer;
        transition: 0.2s; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
    }
    button:hover { background: #fff; }

    /* HUD */
    #hud {
        position: absolute; top: 20px; left: 20px; z-index: 5;
        font-size: 12px; opacity: 0; transition: opacity 1s;
    }
    .row { display: flex; gap: 20px; margin-bottom: 5px; }
    .label { color: #666; }
    .val { color: var(--p); font-weight: bold; }

    /* TIMELINE */
    #timeline-container {
        position: absolute; bottom: 40px; left: 10%; width: 80%; height: 2px; background: #333; z-index: 5;
        opacity: 0; transition: opacity 1s;
    }
    #timeline-fill {
        height: 100%; width: 0%; background: var(--p);
        box-shadow: 0 0 10px var(--p); position: relative;
    }
    #timeline-marker {
        position: absolute; right: 0; top: -4px; width: 10px; height: 10px; background: #fff; border-radius: 50%;
    }
    .marker-label {
        position: absolute; top: -20px; font-size: 10px; color: #666; transform: translateX(-50%);
    }
</style>
</head>
<body>

<div id="hud">
    <div class="row"><span class="label">SECTION:</span><span class="val" id="hud-section">STANDBY</span></div>
    <div class="row"><span class="label">BAR:</span><span class="val" id="hud-bar">0</span></div>
    <div class="row"><span class="label">TIME:</span><span class="val" id="hud-time">00:00</span></div>
</div>

<div id="timeline-container">
    <div id="timeline-fill"><div id="timeline-marker"></div></div>
    <!-- Structure Markers -->
    <div class="marker-label" style="left: 0%">INTRO</div>
    <div class="marker-label" style="left: 25%">BUILD</div>
    <div class="marker-label" style="left: 37.5%">DROP</div>
    <div class="marker-label" style="left: 75%">BRIDGE</div>
    <div class="marker-label" style="left: 87.5%">OUT</div>
</div>

<div id="ui-layer">
    <div id="panel">
        <h1>TERMINUS</h1>
        <button id="btn">EXECUTE SEQUENCE</button>
    </div>
</div>

<canvas id="c"></canvas>

<script>
/**
 * PROJECT: TERMINUS
 * ENGINE: Linear Arrangement Sequencer
 * BPM: 435 (Previously 174)
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

// AUDIO GRAPH
let actx, master, limiter, distortion, reverb, analyser;
let isPlaying = false;
let startTime = 0;

// CONFIG
const BPM = 435;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;
const TOTAL_BARS = 160; // Full song length

// FREQUENCIES (F Minor)
const N = { F1: 43.65, Ab1: 51.91, C2: 65.41, F2: 87.31, G2: 98.00, Ab2: 103.83, C3: 130.81, F3: 174.61 };

// === 1. AUDIO ENGINE ===

async function init() {
    actx = new AC();
    await actx.resume();

    master = actx.createGain();
    master.gain.value = 0.6;

    limiter = actx.createDynamicsCompressor();
    limiter.threshold.value = -3;
    limiter.ratio.value = 20;
    
    distortion = actx.createWaveShaper();
    distortion.curve = makeDistortionCurve(80);
    
    analyser = actx.createAnalyser();
    analyser.fftSize = 1024;

    master.connect(limiter);
    limiter.connect(analyser);
    analyser.connect(actx.destination);

    reverb = await createReverb();
    reverb.output.connect(master);
}

function makeDistortionCurve(amount) {
    const k = amount, n = 44100, curve = new Float32Array(n);
    for (let i = 0; i < n; ++i) {
        const x = i * 2 / n - 1;
        curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
    }
    return curve;
}

async function createReverb() {
    const len = actx.sampleRate * 3;
    const b = actx.createBuffer(2, len, actx.sampleRate);
    for(let c=0;c<2;c++) for(let i=0;i<len;i++) b.getChannelData(c)[i] = (Math.random()*2-1)*Math.pow(1-i/len,3);
    const c = actx.createConvolver(); c.buffer = b;
    const i = actx.createGain(); const o = actx.createGain(); o.gain.value = 0.3;
    i.connect(c); c.connect(o);
    return {input:i, output:o};
}

// INSTRUMENTS

// 1. THE NEURO BASS (Reese)
// Two detuned saws + Modulation + Distortion
function playReese(t, freq, dur, modSpeed) {
    const o1 = actx.createOscillator(); o1.type='sawtooth'; o1.frequency.value=freq; o1.detune.value = -12;
    const o2 = actx.createOscillator(); o2.type='sawtooth'; o2.frequency.value=freq; o2.detune.value = 12;
    const sub = actx.createOscillator(); sub.type='sine'; sub.frequency.value=freq/2;

    const f = actx.createBiquadFilter(); f.type='lowpass'; f.Q.value = 6;
    
    // Filter Modulation (The "Wub")
    const lfo = actx.createOscillator(); 
    lfo.frequency.value = modSpeed; // Speed of the wobble
    const lfoG = actx.createGain(); lfoG.gain.value = 1500; // Depth of wobble
    lfo.connect(lfoG); lfoG.connect(f.frequency);
    f.frequency.setValueAtTime(500, t);

    const g = actx.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.6, t+0.05);
    g.gain.linearRampToValueAtTime(0, t+dur);

    const subG = actx.createGain(); subG.gain.value=0.6;

    o1.connect(f); o2.connect(f); f.connect(distortion);
    sub.connect(subG); subG.connect(g); // Sub clean
    distortion.connect(g); g.connect(master);

    o1.start(t); o1.stop(t+dur);
    o2.start(t); o2.stop(t+dur);
    sub.start(t); sub.stop(t+dur);
    lfo.start(t); lfo.stop(t+dur);
}

// 2. PUNCH KICK
function playKick(t) {
    const o = actx.createOscillator();
    o.frequency.setValueAtTime(150, t);
    o.frequency.exponentialRampToValueAtTime(40, t+0.1);
    const g = actx.createGain();
    g.gain.setValueAtTime(1, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
    
    const c = actx.createOscillator(); c.type='square'; 
    const cg = actx.createGain(); cg.gain.setValueAtTime(0.2, t); cg.gain.exponentialRampToValueAtTime(0.001, t+0.02);

    o.connect(g); g.connect(master); c.connect(cg); cg.connect(master);
    o.start(t); o.stop(t+0.2); c.start(t); c.stop(t+0.02);
    
    visPulse = 1;
}

// 3. SNAP SNARE
function playSnare(t) {
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.2, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer=b;
    const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=500;
    const g = actx.createGain(); g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
    
    const o = actx.createOscillator(); o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(100, t+0.1);
    const og = actx.createGain(); og.gain.setValueAtTime(0.5, t); og.gain.exponentialRampToValueAtTime(0.001, t+0.1);

    n.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    o.connect(og); og.connect(master);
    n.start(t); o.start(t); o.stop(t+0.15);
}

// 4. HI HATS
function playHat(t) {
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.05, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer=b;
    const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=8000;
    const g = actx.createGain(); g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.05);
    n.connect(f); f.connect(g); g.connect(master);
    n.start(t);
}

// 5. PADS
function playPad(t, freq, dur) {
    const o = actx.createOscillator(); o.type='sawtooth'; o.frequency.value=freq;
    const f = actx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=600;
    const g = actx.createGain(); 
    g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.15, t+1); g.gain.linearRampToValueAtTime(0, t+dur);
    o.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    o.start(t); o.stop(t+dur);
}

// === 2. LINEAR SEQUENCER ===

let nextNoteTime = 0.0;
let currentStep = 0;

function scheduler() {
    // Sync check: if we are lagging, jump to now
    if (nextNoteTime < actx.currentTime - 0.2) nextNoteTime = actx.currentTime + 0.1;

    while (nextNoteTime < actx.currentTime + 0.1) {
        scheduleStep(currentStep, nextNoteTime);
        nextNoteTime += SIXTEENTH;
        currentStep++;
    }
    
    // Update UI Time
    if (isPlaying) {
        const elapsed = actx.currentTime - startTime;
        const mins = Math.floor(elapsed/60);
        const secs = Math.floor(elapsed%60).toString().padStart(2,'0');
        document.getElementById('hud-time').innerText = `${mins}:${secs}`;
        setTimeout(scheduler, 25);
    }
}

function scheduleStep(step, t) {
    const bar = Math.floor(step / 16);
    const stepInBar = step % 16;
    
    // --- ARRANGEMENT STRUCTURE ---
    // 0-32: INTRO (Dark)
    // 32-48: BUILD (Riser)
    // 48-80: DROP A (Heavy)
    // 80-96: BRIDGE (Break)
    // 96-128: DROP B (Complex)
    // 128-160: OUTRO

    if (bar >= TOTAL_BARS) {
        stopSong();
        return;
    }

    let section = "INTRO";
    if(bar >= 32) section = "BUILD UP";
    if(bar >= 48) section = "DROP A";
    if(bar >= 80) section = "BRIDGE";
    if(bar >= 96) section = "DROP B";
    if(bar >= 128) section = "OUTRO";

    // UI Updates
    if(stepInBar === 0) {
        document.getElementById('hud-bar').innerText = bar + 1;
        document.getElementById('hud-section').innerText = section;
        const pct = (bar / TOTAL_BARS) * 100;
        document.getElementById('timeline-fill').style.width = pct + "%";
    }

    // --- DRUMS ---
    
    const isDrop = (section === "DROP A" || section === "DROP B");
    const isBuild = (section === "BUILD UP");
    
    if (isDrop || (isBuild && bar > 40)) {
        // Neuro Pattern: Kick on 0, Snare on 4 and 12
        if (stepInBar === 0) playKick(t);
        if (stepInBar === 4) playSnare(t);
        // Ghost kick
        if (stepInBar === 10) playKick(t);
        if (stepInBar === 12) playSnare(t);
        
        // Build Snare Roll
        if (isBuild && bar >= 46) {
            if (stepInBar % 2 === 0) playSnare(t);
        }
    }
    
    // Hi Hats
    if (section !== "INTRO" && section !== "OUTRO") {
        if (stepInBar % 2 === 0) playHat(t);
        if (isDrop && Math.random() > 0.7) playHat(t); // Shuffles
    }

    // --- BASS ---
    
    if (isDrop) {
        // Call
        if (stepInBar === 0) playReese(t, N.F1, BEAT * 1.5, 6); // Wobble
        // Response
        if (stepInBar === 6) playReese(t, N.F1, BEAT, 12); // Fast wobble
        // Fill
        if (stepInBar === 11) playReese(t, N.Ab1, BEAT, 2);
    } else if (section === "INTRO" || section === "BRIDGE") {
        // Drone Bass
        if (stepInBar === 0 && bar % 4 === 0) playReese(t, N.F1, BEAT*16, 0.5); // Slow filter move
    } else if (isBuild) {
        // Rising Bass
        if (stepInBar === 0) playReese(t, N.F1, BEAT, 8);
    }

    // --- ATMOSPHERE / PADS ---
    if (section === "INTRO" || section === "BRIDGE" || section === "OUTRO") {
        if (stepInBar === 0 && bar % 8 === 0) {
            playPad(t, N.F3, BEAT*32); // Long pad
            playPad(t, N.C3, BEAT*32);
        }
    }
}

function stopSong() {
    isPlaying = false;
    document.getElementById('hud-section').innerText = "COMPLETE";
    document.getElementById('panel').style.opacity = 1;
    document.querySelector('h1').innerText = "TERMINATED";
    document.getElementById('btn').innerText = "RELOAD SYSTEM";
    document.getElementById('btn').onclick = () => location.reload();
}

// === 3. VISUALS ===

let visPulse = 0;
let time = 0;

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}

function draw() {
    requestAnimationFrame(draw);
    
    // Trails
    ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
    ctx.fillRect(0,0,w,h);
    
    visPulse *= 0.9;
    time += 0.01;
    
    const cx = w/2;
    const cy = h/2;
    
    const section = document.getElementById('hud-section').innerText;
    const isDrop = section.includes("DROP");
    
    // Get Frequency Data
    const freq = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(freq);
    
    // Draw Tunnel / Spectrum
    ctx.lineWidth = 2;
    
    // Number of shapes
    const shapes = isDrop ? 20 : 10;
    
    for(let i=0; i<shapes; i++) {
        const z = (time * 2 + i) % shapes; // Movement
        const size = Math.pow(z, 3) * 5;
        const alpha = z / shapes;
        
        if (size > w * 1.5) continue;
        
        ctx.beginPath();
        
        // Deform shape based on audio
        const audioVal = freq[i * 2] / 255;
        const r = size + (audioVal * 100 * visPulse);
        
        // Draw Hexagon
        for(let j=0; j<6; j++) {
            const angle = (Math.PI*2/6) * j + (time * 0.5 * (i%2?-1:1));
            const x = cx + Math.cos(angle) * r;
            const y = cy + Math.sin(angle) * r;
            if(j===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.closePath();
        
        const hue = isDrop ? 0 : 180; // Red vs Cyan
        ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
        ctx.stroke();
    }
    
    // Impact Flash
    if (visPulse > 0.8) {
        ctx.fillStyle = `rgba(255, 255, 255, ${visPulse * 0.1})`;
        ctx.fillRect(0,0,w,h);
    }
}

window.onresize = initVis;
initVis();

document.getElementById('btn').addEventListener('click', async (e) => {
    const btn = e.target;
    btn.innerText = "RUNNING...";
    document.getElementById('panel').style.opacity = 0;
    document.getElementById('hud').style.opacity = 1;
    document.getElementById('timeline-container').style.opacity = 1;
    
    await init();
    startTime = actx.currentTime + 0.1;
    nextNoteTime = startTime;
    isPlaying = true;
    
    scheduler();
    draw();
});

</script>
</body>
</html>

PROGRAM 2
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AMADEUS // ALGORITHMIC COMPOSER</title>
<style>
    :root { --paper: #f0e6d2; --ink: #2c241b; --gold: #c5a059; }
    body {
        margin: 0; background: var(--paper); overflow: hidden;
        font-family: 'Times New Roman', serif; color: var(--ink);
        display: flex; justify-content: center; align-items: center; height: 100vh;
        user-select: none;
    }
    
    /* VINTAGE PAPER TEXTURE */
    body::before {
        content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background-image: url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.1'/%3E%3C/svg%3E");
        pointer-events: none; z-index: 0;
    }

    #score-container {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 10; pointer-events: none;
    }

    #plaque {
        background: rgba(240, 230, 210, 0.95); padding: 50px; 
        border: 4px double var(--ink); box-shadow: 10px 10px 30px rgba(44, 36, 27, 0.2);
        text-align: center; pointer-events: auto; transition: opacity 1s;
    }

    h1 { font-size: 3rem; margin: 0 0 10px 0; letter-spacing: 2px; font-weight: normal; }
    h2 { font-style: italic; font-size: 1rem; color: #5a4a3a; margin-bottom: 30px; }
    
    button {
        background: transparent; border: 2px solid var(--ink); color: var(--ink);
        padding: 15px 40px; font-family: 'Times New Roman', serif; font-size: 1.2rem;
        cursor: pointer; transition: 0.3s; font-weight: bold; letter-spacing: 1px;
    }
    button:hover { background: var(--ink); color: var(--paper); }

    /* DYNAMIC SCORE */
    #hud {
        position: absolute; top: 30px; width: 100%; text-align: center; opacity: 0; transition: opacity 1s;
    }
    .hud-text { font-size: 14px; letter-spacing: 2px; font-style: italic; }
    #current-chord { font-size: 24px; font-weight: bold; margin-top: 10px; }

    canvas { position: absolute; top: 0; left: 0; z-index: 1; opacity: 0.8; }
</style>
</head>
<body>

<div id="hud">
    <div class="hud-text">MOVEMENT I: ALLEGRO</div>
    <div id="current-chord">I</div>
</div>

<div id="score-container">
    <div id="plaque">
        <h1>AMADEUS</h1>
        <h2>Wolfgang Amadeus Mozart // Generative Engine</h2>
        <button id="btn">CONDUCT</button>
    </div>
</div>

<canvas id="c"></canvas>

<script>
/**
 * PROJECT: AMADEUS
 * ENGINE: Classical Harmonics & Voice Leading
 * KEY: G Major (Classic Mozart Key)
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

// AUDIO
let ac, master, reverb, compressor;
let isPlaying = false;
let startTime = 0;

// THEORY: G MAJOR
// G, A, B, C, D, E, F#
const SCALE = {
    G2: 98.00, B2: 123.47, D3: 146.83, 
    G3: 196.00, A3: 220.00, B3: 246.94, C4: 261.63, D4: 293.66, E4: 329.63, Fs4: 369.99,
    G4: 392.00, A4: 440.00, B4: 493.88, C5: 523.25, D5: 587.33, E5: 659.25, Fs5: 739.99, G5: 783.99
};

// CHORD DEFINITIONS (Roman Numerals)
const CHORDS = {
    'I':   [SCALE.G2, SCALE.B2, SCALE.D3], // G Maj
    'IV':  [SCALE.C4/2, SCALE.E4/2, SCALE.G2], // C Maj (inversions)
    'V':   [SCALE.D3, SCALE.Fs4/2, SCALE.A3], // D Maj
    'vi':  [SCALE.E4/2, SCALE.G2, SCALE.B2], // E min
    'ii':  [SCALE.A3/2, SCALE.C4/2, SCALE.E4/2], // A min
    'V7':  [SCALE.D3, SCALE.Fs4/2, SCALE.A3, SCALE.C4/2] // D7
};

// PROGRESSION STATE MACHINE
const PROGRESSION = ['I', 'V', 'V', 'I', 'IV', 'I', 'V7', 'I', 'vi', 'ii', 'V7', 'I'];

// ================= AUDIO ENGINE ================= //

async function init() {
    ac = new AC();
    await ac.resume();

    master = ac.createGain();
    master.gain.value = 0.5;

    // CONCERT HALL REVERB
    reverb = await createConvolver();
    compressor = ac.createDynamicsCompressor();

    master.connect(compressor).connect(ac.destination);
    master.connect(reverb).connect(ac.destination);
}

async function createConvolver() {
    const len = ac.sampleRate * 2.5; // 2.5s tail
    const buf = ac.createBuffer(2, len, ac.sampleRate);
    for(let c=0;c<2;c++){
        const d = buf.getChannelData(c);
        for(let i=0;i<len;i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/len, 3);
    }
    const c = ac.createConvolver();
    c.buffer = buf;
    const g = ac.createGain(); g.gain.value = 0.3; // Wet Mix
    c.connect(g);
    return g;
}

// INSTRUMENT 1: FORTEPIANO (The "Hammer" Sound)
function playPiano(t, freq, velocity) {
    const osc = ac.createOscillator();
    const osc2 = ac.createOscillator();
    
    // Mix Triangle (Body) and Square (Hammer strike)
    osc.type = 'triangle';
    osc2.type = 'square';
    
    osc.frequency.value = freq;
    osc2.frequency.value = freq;
    
    // Envelope
    const gain = ac.createGain();
    const vel = velocity || 0.5;
    
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(vel, t + 0.02); // Attack
    gain.gain.exponentialRampToValueAtTime(vel * 0.1, t + 0.5); // Decay
    gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0); // Release

    // Filter (Damps high freq as note decays)
    const filter = ac.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(2000, t);
    filter.frequency.exponentialRampToValueAtTime(500, t + 1.0);

    const osc2Gain = ac.createGain(); osc2Gain.gain.value = 0.2; // Lower square vol

    osc.connect(filter);
    osc2.connect(osc2Gain).connect(filter);
    filter.connect(gain).connect(master);

    osc.start(t); osc.stop(t+2.5);
    osc2.start(t); osc2.stop(t+2.5);
    
    visualizeNote(freq, t, 'piano');
}

// INSTRUMENT 2: VIOLIN SECTION (Background)
function playString(t, freq, dur) {
    const osc = ac.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.value = freq;

    // Vibrato
    const vib = ac.createOscillator();
    vib.frequency.value = 5; // Hz
    const vibG = ac.createGain();
    vibG.gain.value = 3; 
    vib.connect(vibG).connect(osc.frequency);

    const filter = ac.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 1500;

    const gain = ac.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.1, t + 0.5); // Slow attack
    gain.gain.linearRampToValueAtTime(0.1, t + dur - 0.5);
    gain.gain.linearRampToValueAtTime(0, t + dur); // Slow release

    osc.connect(filter).connect(gain).connect(master);
    
    osc.start(t); osc.stop(t+dur);
    vib.start(t); vib.stop(t+dur);
}

// ================= THE MOZART ENGINE ================= //

const BPM = 130; // Allegro
const BEAT = 60 / BPM;
const MEASURE = BEAT * 3; // 3/4 Time (Minuet) or 4/4. Let's do 4/4 Common Time.
const BAR_LEN = BEAT * 4;

let nextTime = 0;
let barCount = 0;

function scheduler() {
    if(!isPlaying) return;
    const lookahead = 0.1;
    while(nextTime < ac.currentTime + lookahead) {
        composeMeasure(nextTime);
        nextTime += BAR_LEN;
        barCount++;
    }
    setTimeout(scheduler, 50);
}

// THE "MUSICAL DICE" LOGIC
function composeMeasure(t) {
    // 1. Determine Harmony
    const chordName = PROGRESSION[barCount % PROGRESSION.length];
    const notes = CHORDS[chordName];
    const root = notes[0];
    const third = notes[1];
    const fifth = notes[2];

    // UI Update
    document.getElementById('current-chord').innerText = chordName + (barCount%2===0 ? "" : " (Var)");

    // 2. LEFT HAND: ALBERTI BASS
    // Pattern: Root - 5 - 3 - 5
    const lh = [root, fifth, third, fifth]; // 8th notes
    for(let i=0; i<8; i++) {
        // Play the 4 note pattern twice to fill 8 eighth notes
        let note = lh[i % 4];
        playPiano(t + (i * (BEAT/2)), note, 0.35); // Softer volume
    }

    // 3. RIGHT HAND: PROCEDURAL MELODY
    // Mozart often used scales, turns, and leaps on beat 1.
    
    // Type A: The Arpeggio Rise
    if (barCount % 3 === 0) {
        playPiano(t, root * 4, 0.6);
        playPiano(t + BEAT, third * 4, 0.6);
        playPiano(t + BEAT*2, fifth * 4, 0.6);
        // Trill at end
        playTrill(t + BEAT*3, fifth * 4, BEAT);
    }
    // Type B: The Scalar Run (16th notes)
    else if (barCount % 3 === 1) {
        // Scale starting from high root down
        const scale = [SCALE.G5, SCALE.Fs5, SCALE.E5, SCALE.D5, SCALE.C5, SCALE.B4, SCALE.A4, SCALE.G4];
        for(let i=0; i<8; i++) {
            playPiano(t + (i * (BEAT/4)), scale[i], 0.5);
        }
        playPiano(t + BEAT*2, SCALE.D5, 0.6); // Landing
        playPiano(t + BEAT*3, SCALE.G4, 0.6);
    }
    // Type C: The Lyrical Turn
    else {
        playPiano(t, third * 4, 0.7); // Long note
        playPiano(t + BEAT*2, fifth * 4, 0.6);
        playPiano(t + BEAT*2.5, third * 4, 0.5);
        playPiano(t + BEAT*3, root * 4, 0.6);
    }

    // 4. STRINGS (Pad)
    // Only change every measure
    if (barCount % 2 === 0) {
        playString(t, root, BAR_LEN * 2); // Root
        playString(t, third, BAR_LEN * 2); // Harmony
    }
}

function playTrill(t, baseFreq, dur) {
    // Rapid alternation between note and note+1 tone
    const count = 8;
    const step = dur / count;
    // Calculate Whole Tone approx (freq * 1.12)
    const upper = baseFreq * 1.122; 
    
    for(let i=0; i<count; i++) {
        const note = (i % 2 === 0) ? baseFreq : upper;
        playPiano(t + (i*step), note, 0.4);
    }
}

// ================= VISUALS (THE QUILL) ================= //

const notesOnScreen = [];

function visualizeNote(freq, time, type) {
    // Map freq to Y position (Score)
    // Normalize rough range 100hz - 800hz
    const yVal = 1 - Math.min(1, Math.max(0, (freq - 100) / 700));
    
    notesOnScreen.push({
        y: yVal * (h * 0.6) + (h*0.2), // Keep central
        x: w + 50, // Start off screen
        born: Date.now(),
        type: type
    });
}

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.onresize = initVis;

function draw() {
    requestAnimationFrame(draw);
    ctx.clearRect(0,0,w,h);
    
    // Draw Staff Lines
    ctx.strokeStyle = '#d0c0a0';
    ctx.lineWidth = 1;
    const staffTop = h * 0.3;
    const staffGap = 20;
    
    for(let i=0; i<5; i++) {
        // Treble Clef Lines
        ctx.beginPath();
        ctx.moveTo(0, staffTop + (i*staffGap));
        ctx.lineTo(w, staffTop + (i*staffGap));
        ctx.stroke();
        
        // Bass Clef Lines
        ctx.beginPath();
        ctx.moveTo(0, staffTop + 150 + (i*staffGap));
        ctx.lineTo(w, staffTop + 150 + (i*staffGap));
        ctx.stroke();
    }

    // Draw Notes (Ink Blots)
    ctx.fillStyle = '#2c241b';
    
    for(let i=notesOnScreen.length-1; i>=0; i--) {
        const n = notesOnScreen[i];
        
        // Move Left (Scroll)
        n.x -= 2; // Speed
        
        // Draw Head
        ctx.beginPath();
        ctx.ellipse(n.x, n.y, 6, 5, -0.5, 0, Math.PI*2);
        ctx.fill();
        
        // Draw Stem
        ctx.beginPath();
        ctx.moveTo(n.x + 5, n.y);
        ctx.lineTo(n.x + 5, n.y - 35);
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#2c241b';
        ctx.stroke();
        
        // Remove if off screen
        if(n.x < -20) notesOnScreen.splice(i, 1);
    }
}

initVis();
draw();

document.getElementById('btn').addEventListener('click', async () => {
    const btn = document.getElementById('btn');
    const plaque = document.getElementById('plaque');
    
    plaque.style.opacity = 0;
    plaque.style.pointerEvents = 'none';
    
    document.getElementById('hud').style.opacity = 1;
    
    await init();
    isPlaying = true;
    startTime = ac.currentTime + 0.5;
    nextTime = startTime;
    
    scheduler();
});

</script>
</body>
</html>

PROGRAM 3
___________________________________________________

<!-- 
    PROJECT: BLACKBIRD // MK.II
    MODE: ACOUSTIC SIMULATION
    LOGIC: SEQUENTIAL PATTERN MATRIX
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Î© // BLACKBIRD // MECHANIZED</title>
    <style>
        :root {
            --void: #050505;
            --bird: #ffae00; /* Amber */
            --wing: #ffffff;
            --string: rgba(255, 255, 255, 0.1);
            --fret: rgba(255, 255, 255, 0.05);
        }

        body {
            margin: 0;
            background: var(--void);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        #hud {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-shadow: 0 0 10px black;
        }

        #measure-display {
            font-size: 10vw;
            font-weight: 900;
            color: transparent;
            -webkit-text-stroke: 1px var(--bird);
            opacity: 0.2;
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: -5px;
        }

        #lyric-display {
            margin-top: 10px;
            font-size: 1.2rem;
            color: var(--wing);
            text-shadow: 0 0 10px var(--wing);
            letter-spacing: 3px;
            text-align: center;
            min-height: 30px;
            font-weight: bold;
        }

        #tab-visual {
            position: absolute;
            bottom: 150px;
            display: flex;
            gap: 10px;
            font-size: 0.8rem;
            color: var(--bird);
            opacity: 0.7;
        }

        #controls {
            position: absolute;
            bottom: 40px;
            z-index: 20;
            display: flex;
            gap: 20px;
            align-items: center;
            pointer-events: auto;
            background: rgba(10,10,10,0.9);
            padding: 15px 30px;
            border: 1px solid var(--bird);
            border-radius: 4px;
        }

        button {
            background: var(--bird);
            color: black;
            border: none;
            padding: 12px 30px;
            font-weight: 900;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 15px var(--bird);
            transition: 0.2s;
        }

        button:hover {
            background: white;
            box-shadow: 0 0 30px white;
            transform: scale(1.05);
        }

        input[type=range] {
            width: 150px;
            accent-color: var(--bird);
        }

        .pulse { animation: pulse 0.2s ease-out; }
        @keyframes pulse { 0% { opacity: 1; transform: scale(1.05); } 100% { opacity: 0.2; transform: scale(1); } }
    </style>
</head>
<body>

    <canvas id="stage"></canvas>

    <div id="hud">
        <div id="measure-display">WAITING</div>
        <div id="lyric-display">CPU IDLE // LOAD "BLACKBIRD"</div>
        <div id="tab-visual"></div>
    </div>

    <div id="controls">
        <button onclick="SIM.start()">EXECUTE</button>
        <div style="display:flex; flex-direction:column; color:var(--bird); font-size:0.7rem; font-weight:bold;">
            <label>TEMPO</label>
            <input type="range" min="70" max="110" value="94" oninput="SIM.setBPM(this.value)">
            <span id="bpm-val">94 BPM</span>
        </div>
    </div>

    <script>
        // ======================================================
        // 1. ACOUSTIC PHYSICS ENGINE
        // ======================================================
        const TUNING = [82.41, 110.00, 146.83, 196.00, 246.94, 329.63]; // Standard E
        
        const AudioEngine = {
            ctx: null,
            master: null,
            
            init() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.4;
                
                // Compressor to unify picking levels
                const comp = this.ctx.createDynamicsCompressor();
                comp.threshold.value = -20;
                comp.ratio.value = 4;
                
                this.master.connect(comp);
                comp.connect(this.ctx.destination);
                
                return this.ctx.resume();
            },

            play(stringIdx, fret, time) {
                if(fret === -1) return;
                
                const base = TUNING[stringIdx];
                const freq = base * Math.pow(2, fret/12);
                
                // 1. Transient (Pluck sound)
                const osc = this.ctx.createOscillator();
                osc.type = 'triangle'; // Softer than sawtooth
                osc.frequency.value = freq;
                
                // 2. Harmonic (The string metallic buzz)
                const harmonic = this.ctx.createOscillator();
                harmonic.type = 'sawtooth';
                harmonic.frequency.value = freq;

                // Envelopes
                const g1 = this.ctx.createGain();
                const g2 = this.ctx.createGain();
                
                // Main Body
                g1.gain.setValueAtTime(0, time);
                g1.gain.linearRampToValueAtTime(0.5, time + 0.01);
                g1.gain.exponentialRampToValueAtTime(0.01, time + 1.5); // Short decay

                // Metallic top end
                g2.gain.setValueAtTime(0, time);
                g2.gain.linearRampToValueAtTime(0.1, time + 0.01);
                g2.gain.exponentialRampToValueAtTime(0.001, time + 0.2); // Very short

                osc.connect(g1); g1.connect(this.master);
                harmonic.connect(g2); g2.connect(this.master);

                osc.start(time); osc.stop(time + 2);
                harmonic.start(time); harmonic.stop(time + 2);

                Visuals.pluck(stringIdx, 1);
            }
        };

        // ======================================================
        // 2. TAB TRANSCRIPTION (The Logic)
        // ======================================================
        // 0=E, 1=A, 2=D, 3=G, 4=B, 5=e
        // T = beat in the measure (0.0 to X.X)
        
        const RIFFS = {
            // Meas 1: G - Am7 - G/B (3/4)
            "INTRO_WALK": {
                beats: 3,
                notes: [
                    {s:0, f:3, t:0.0}, {s:4, f:0, t:0.0}, // G
                    {s:3, f:0, t:0.5},
                    {s:1, f:0, t:1.0}, {s:4, f:1, t:1.0}, // Am7
                    {s:3, f:0, t:1.5},
                    {s:1, f:2, t:2.0}, {s:4, f:3, t:2.0}, // G/B
                    {s:3, f:0, t:2.5}
                ]
            },
            // Meas 2: High G drone (4/4)
            "HIGH_G": {
                beats: 4,
                notes: [
                    {s:0, f:3, t:0.0}, // Low G (optional in some tabs, but anchors it)
                    {s:1, f:10, t:0.0}, {s:4, f:12, t:0.0},
                    {s:3, f:0, t:0.5},
                    {s:1, f:10, t:1.0}, {s:4, f:12, t:1.0},
                    {s:3, f:0, t:1.5},
                    {s:1, f:10, t:2.0}, {s:4, f:12, t:2.0},
                    {s:3, f:0, t:2.5},
                    {s:1, f:10, t:3.0}, {s:4, f:12, t:3.0},
                    {s:3, f:0, t:3.5}
                ]
            },
            // Meas 5: Broken Wings 1 (C - A7 - D - B7) (4/4)
            "WINGS_1": {
                beats: 4,
                notes: [
                    {s:1, f:3, t:0.0}, {s:4, f:5, t:0.0}, {s:3, f:0, t:0.5}, // C
                    {s:1, f:7, t:1.0}, {s:4, f:8, t:1.0}, {s:3, f:0, t:1.5}, // A7
                    {s:1, f:5, t:2.0}, {s:4, f:7, t:2.0}, {s:3, f:0, t:2.5}, // D
                    {s:1, f:9, t:3.0}, {s:4, f:10, t:3.0}, {s:3, f:0, t:3.5}  // B7
                ]
            },
            // Meas 6: Broken Wings 2 (Em - Eb) (4/4)
            "WINGS_2": {
                beats: 4,
                notes: [
                    {s:1, f:7, t:0.0}, {s:4, f:8, t:0.0}, {s:3, f:0, t:0.5}, // Em
                    {s:1, f:7, t:1.0}, {s:4, f:8, t:1.0}, {s:3, f:0, t:1.5},
                    {s:1, f:6, t:2.0}, {s:4, f:8, t:2.0}, {s:3, f:0, t:2.5}, // Eb
                    {s:1, f:6, t:3.0}, {s:4, f:8, t:3.0}, {s:3, f:0, t:3.5}
                ]
            },
            // Meas 7: All Your Life (D - A7 - C - Cm) (3/2 aka 6/4)
            "LIFE": {
                beats: 6,
                notes: [
                    {s:1, f:5, t:0.0}, {s:4, f:7, t:0.0}, {s:3, f:0, t:0.5}, // D
                    {s:1, f:7, t:1.0}, {s:4, f:8, t:1.0}, {s:3, f:0, t:1.5}, // A7
                    {s:1, f:3, t:2.0}, {s:4, f:5, t:2.0}, {s:3, f:0, t:2.5}, // C
                    {s:1, f:3, t:3.0}, {s:4, f:5, t:3.0}, {s:3, f:0, t:3.5},
                    {s:1, f:3, t:4.0}, {s:4, f:4, t:4.0}, {s:3, f:0, t:4.5}, // Cm
                    {s:1, f:3, t:5.0}, {s:4, f:4, t:5.0}, {s:3, f:0, t:5.5}
                ]
            },
            // Meas 8: Waiting (G/B - A7 - Am7 - D7) (4/4)
            "WAITING": {
                beats: 4,
                notes: [
                    {s:1, f:2, t:0.0}, {s:4, f:3, t:0.0}, {s:3, f:0, t:0.5}, // G/B
                    {s:1, f:2, t:1.0}, {s:4, f:3, t:1.0}, {s:3, f:0, t:1.5}, 
                    {s:1, f:0, t:2.0}, {s:4, f:2, t:2.0}, {s:3, f:0, t:2.5}, // A7/Open
                    {s:1, f:0, t:3.0}, {s:4, f:2, t:3.0}, {s:3, f:0, t:3.5}
                ]
            },
            // Resolution (Am7 - D7 - G)
            "RESOLVE": {
                beats: 4,
                notes: [
                    {s:2, f:0, t:0.0}, {s:4, f:1, t:0.0}, {s:3, f:0, t:0.5}, // Am7
                    {s:2, f:0, t:1.0}, {s:4, f:1, t:1.0}, {s:3, f:0, t:1.5},
                    {s:0, f:3, t:2.0}, {s:4, f:0, t:2.0}, {s:3, f:0, t:2.5}, // G (Low)
                    {s:1, f:2, t:3.0}, {s:4, f:3, t:3.0} // G/B link
                ]
            },
            // Interlude/Fly (F - Em - Dm - C - Bb - C)
            "FLY_1": {
                beats: 4,
                notes: [
                    {s:1, f:8, t:0.0}, {s:4, f:10, t:0.0}, {s:3, f:0, t:0.5}, // F
                    {s:1, f:7, t:1.0}, {s:4, f:8, t:1.0}, {s:3, f:0, t:1.5},  // Em
                    {s:1, f:5, t:2.0}, {s:4, f:6, t:2.0}, {s:3, f:0, t:2.5},  // Dm
                    {s:1, f:3, t:3.0}, {s:4, f:5, t:3.0}, {s:3, f:0, t:3.5}   // C
                ]
            },
            "FLY_2": {
                beats: 4,
                notes: [
                    {s:1, f:1, t:0.0}, {s:4, f:3, t:0.0}, {s:3, f:0, t:0.5}, // Bb
                    {s:1, f:1, t:1.0}, {s:4, f:3, t:1.0}, {s:3, f:0, t:1.5},
                    {s:1, f:3, t:2.0}, {s:4, f:5, t:2.0}, {s:3, f:0, t:2.5}, // C
                    {s:1, f:3, t:3.0}, {s:4, f:5, t:3.0}, {s:3, f:0, t:3.5}
                ]
            },
             "FLY_3": {
                beats: 4,
                notes: [
                    {s:1, f:1, t:0.0}, {s:4, f:3, t:0.0}, {s:3, f:0, t:0.5}, // Bb
                    {s:1, f:1, t:1.0}, {s:4, f:3, t:1.0}, {s:3, f:0, t:1.5},
                    {s:1, f:0, t:2.0}, {s:4, f:2, t:2.0}, {s:3, f:0, t:2.5}, // A7
                    {s:1, f:0, t:3.0}, {s:4, f:2, t:3.0}, {s:3, f:0, t:3.5}
                ]
            }
        };

        const SONG_STRUCTURE = [
            // Intro
            { r: "INTRO_WALK", l: "" },
            { r: "HIGH_G", l: "BLACKBIRD SINGING" },
            { r: "INTRO_WALK", l: "IN THE DEAD" },
            { r: "HIGH_G", l: "OF NIGHT" },
            
            // Verse 1
            { r: "WINGS_1", l: "TAKE THESE BROKEN WINGS" },
            { r: "WINGS_2", l: "AND LEARN TO FLY" },
            { r: "LIFE", l: "ALL YOUR LIFE" },
            { r: "WAITING", l: "YOU WERE ONLY WAITING" },
            { r: "RESOLVE", l: "FOR THIS MOMENT TO ARISE" },
            { r: "HIGH_G", l: "" }, // Interlude

            // Verse 2
            { r: "INTRO_WALK", l: "BLACKBIRD SINGING" },
            { r: "HIGH_G", l: "IN THE DEAD OF NIGHT" },
            { r: "WINGS_1", l: "TAKE THESE SUNKEN EYES" },
            { r: "WINGS_2", l: "AND LEARN TO SEE" },
            { r: "LIFE", l: "ALL YOUR LIFE" },
            { r: "WAITING", l: "YOU WERE ONLY WAITING" },
            { r: "RESOLVE", l: "FOR THIS MOMENT TO BE FREE" },

            // Fly Section
            { r: "FLY_1", l: "BLACKBIRD FLY" },
            { r: "FLY_2", l: "" },
            { r: "FLY_1", l: "BLACKBIRD FLY" },
            { r: "FLY_3", l: "INTO THE LIGHT" },
            { r: "INTRO_WALK", l: "OF A DARK BLACK NIGHT" },
            { r: "HIGH_G", l: "" }
        ];

        // ======================================================
        // 3. SEQUENCER
        // ======================================================
        const SIM = {
            bpm: 94,
            isPlaying: false,
            startTime: 0,
            barIndex: 0,
            nextBarTime: 0,
            
            start() {
                document.querySelector('button').style.display = 'none';
                AudioEngine.init().then(() => {
                    this.isPlaying = true;
                    this.nextBarTime = AudioEngine.ctx.currentTime + 0.5;
                    this.barIndex = 0;
                    this.tick();
                });
            },

            setBPM(val) {
                this.bpm = parseInt(val);
                document.getElementById('bpm-val').innerText = this.bpm + " BPM";
            },

            tick() {
                if(!this.isPlaying) return;

                // Lookahead scheduling
                if (AudioEngine.ctx.currentTime + 0.1 >= this.nextBarTime) {
                    this.playBar(this.barIndex);
                    
                    // Calculate next bar time
                    const currentBlock = SONG_STRUCTURE[this.barIndex % SONG_STRUCTURE.length];
                    const riff = RIFFS[currentBlock.r];
                    const beats = riff.beats;
                    const duration = (60 / this.bpm) * beats;
                    
                    this.nextBarTime += duration;
                    this.barIndex = (this.barIndex + 1) % SONG_STRUCTURE.length;
                }

                requestAnimationFrame(this.tick.bind(this));
            },

            playBar(idx) {
                const block = SONG_STRUCTURE[idx % SONG_STRUCTURE.length];
                const riffName = block.r;
                const lyric = block.l;
                const riffData = RIFFS[riffName];
                const now = this.nextBarTime;
                const beatLen = 60 / this.bpm;

                // UI
                document.getElementById('measure-display').innerText = riffName;
                document.getElementById('measure-display').classList.remove('pulse');
                void document.getElementById('measure-display').offsetWidth;
                document.getElementById('measure-display').classList.add('pulse');
                
                document.getElementById('lyric-display').innerText = lyric;

                // Schedule Notes
                riffData.notes.forEach(note => {
                    AudioEngine.play(note.s, note.f, now + (note.t * beatLen));
                });
            }
        };

        // ======================================================
        // 4. VISUALS (CYBER-STRINGS)
        // ======================================================
        const Visuals = {
            cvs: document.getElementById('stage'),
            ctx: document.getElementById('stage').getContext('2d'),
            strings: [0,0,0,0,0,0],
            
            init() {
                this.resize();
                window.onresize = () => this.resize();
                this.loop();
            },
            
            resize() {
                this.cvs.width = window.innerWidth;
                this.cvs.height = window.innerHeight;
            },

            pluck(s, v) {
                this.strings[s] = 30; // Amplitude
            },

            loop() {
                const w = this.cvs.width;
                const h = this.cvs.height;
                this.ctx.clearRect(0,0,w,h);

                // Draw Fretboard Lines (Background)
                for(let i=0; i<12; i++) {
                    const x = w * (i/12);
                    this.ctx.fillStyle = 'rgba(255,255,255,0.02)';
                    this.ctx.fillRect(x, 0, 1, h);
                }

                const spacing = h / 8;
                const top = spacing * 1.5;

                for(let i=0; i<6; i++) {
                    const y = top + (i * spacing);
                    const amp = this.strings[i];
                    
                    this.ctx.beginPath();
                    
                    // String Color Logic
                    if(amp > 1) {
                        this.ctx.strokeStyle = '#ffae00'; // Amber active
                        this.ctx.shadowColor = '#ffae00';
                        this.ctx.shadowBlur = 20;
                        this.ctx.lineWidth = 3;
                    } else {
                        this.ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                        this.ctx.shadowBlur = 0;
                        this.ctx.lineWidth = 1 + (i*0.3); // Bass strings thicker
                    }

                    this.ctx.moveTo(0, y);
                    
                    // Wave Physics
                    for(let x=0; x<w; x+=10) {
                        const freq = 0.02 + (i * 0.01); // Higher strings tighter frequency
                        const dy = Math.sin(x*freq + Date.now()*0.02) * amp * Math.sin(x/w * Math.PI);
                        this.ctx.lineTo(x, y + dy);
                    }
                    
                    this.ctx.stroke();
                    this.strings[i] *= 0.92; // Decay
                }
                
                requestAnimationFrame(() => this.loop());
            }
        };
        Visuals.init();

    </script>
</body>
</html>

PROGRAM 4
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PROMETHIUM 61 // THE QUANTUM HOWL</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Italiana&family=Share+Tech+Mono&display=swap');

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            cursor: none; /* NO INPUT DESIRED */
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            z-index: 1;
            /* The visual mindfuckery filter */
            filter: contrast(1.2) saturate(1.5); 
        }

        #ui-layer {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass to overlay */
            mix-blend-mode: exclusion;
        }

        #numeric-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 14px;
            white-space: pre;
            text-align: center;
            opacity: 0.5;
            text-shadow: 0 0 5px red;
        }

        #start-overlay {
            position: absolute;
            z-index: 999;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #020005;
            transition: opacity 3s cubic-bezier(0.4, 0, 1, 1);
            cursor: crosshair;
        }

        .title {
            text-align: center;
            color: #d8c0a8;
            opacity: 0.8;
            animation: breathe 5s infinite ease-in-out;
        }

        h1 {
            font-family: 'Italiana', serif;
            font-size: 3rem;
            margin: 0;
            letter-spacing: 15px;
            font-weight: 400;
            text-shadow: 0 0 20px #a00;
        }
        
        p {
            margin-top: 10px;
            letter-spacing: 5px;
            font-size: 0.9rem;
            color: #555;
        }

        @keyframes breathe {
            0%, 100% { opacity: 0.5; filter: blur(2px); }
            50% { opacity: 1; filter: blur(0px); }
        }

        .dissolve {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- VISUALS -->
    <canvas id="canvas"></canvas>
    <div id="ui-layer">
        <div id="numeric-display"></div>
    </div>

    <!-- GATE -->
    <div id="start-overlay">
        <div class="title">
            <h1>Pm-61</h1>
            <p>QUANTUM COLLATZ SEQUENCER</p>
        </div>
    </div>

    <script>
        /*
         * PROMETHIUM-61: THE QUANTUM HOWL
         * Layers:
         * 1. The 61 Flutes (Base Reality)
         * 2. The Wolf Synth (Formant Synthesis)
         * 3. The Collatz Electron Atom (Visual Chaos)
         */

        const TOTAL_FLUTES = 61; 
        const LAYERS = 7;
        
        // GLOBAL VARS
        let ctx, canvas, w, h, cx, cy;
        let actx, master, reverb;
        let audioRunning = false;
        let startOverlay = document.getElementById('start-overlay');
        let numDisplay = document.getElementById('numeric-display');
        
        // TIMERS
        let time = 0;

        // SCALE (E Minor / Aeolian)
        // 1, 2, b3, 4, 5, b6, b7
        const SCALE_RATIOS = [1, 1.122, 1.189, 1.335, 1.498, 1.587, 1.782]; 
        const BASE_PITCH = 82.41; // Low E
        
        /* ----------------------------------------------------------------
           THE WOLF ENGINE (Formant Filter Synthesis)
           ---------------------------------------------------------------- */
        class Wolf {
            constructor() {
                this.isActive = false;
            }

            howl() {
                if(this.isActive || Math.random() > 0.3) return; // Wolves are shy
                this.isActive = true;

                const t = actx.currentTime;
                const dur = 4 + Math.random() * 6; // Long howl

                // 1. Source (Sawtooth for harsh glottal sound)
                const osc = actx.createOscillator();
                osc.type = 'sawtooth';
                
                // Pitch: Start low, glide up (head voice), glide down
                const startFreq = 220 + Math.random()*50;
                osc.frequency.setValueAtTime(startFreq, t);
                osc.frequency.exponentialRampToValueAtTime(startFreq * 1.5, t + dur * 0.3); // Peak
                osc.frequency.exponentialRampToValueAtTime(startFreq * 0.8, t + dur); // Fade

                // 2. Throat Filter (The "Ooo" sound)
                // Lowpass filter closing simulates mouth shape closing
                const filter = actx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.Q.value = 6; // Resonant throat
                
                // Formant Glide
                filter.frequency.setValueAtTime(600, t);
                filter.frequency.linearRampToValueAtTime(900, t + dur * 0.3); // Open mouth
                filter.frequency.linearRampToValueAtTime(300, t + dur); // Close to 'u'

                // 3. Gain (Breath control)
                const gain = actx.createGain();
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3, t + 1); // Slow attack
                gain.gain.linearRampToValueAtTime(0.3, t + dur - 2); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + dur);

                // Wiring
                osc.connect(filter);
                filter.connect(gain);
                // Heavy reverb for distance
                gain.connect(reverb); 

                osc.start(t);
                osc.stop(t + dur + 1);

                setTimeout(() => { this.isActive = false; }, (dur + 1)*1000);
            }
        }

        const wolves = [new Wolf(), new Wolf(), new Wolf()];

        /* ----------------------------------------------------------------
           VISUALS: QUANTUM COLLATZ ATOM (61 ELECTRONS)
           ---------------------------------------------------------------- */
        
        class CollatzElectron {
            constructor(id) {
                this.id = id;
                this.angle = (Math.PI * 2 / 61) * id;
                this.n = 2 + id; // Initial seed
                this.r = 100;    // Current radius
                this.targetR = 100;
                this.baseR = 100 + (id % 7) * 40;
                this.speed = 0.02 + (Math.random() * 0.02);
                this.color = `hsla(${(id*5)%360}, 100%, 50%, 0.8)`;
                
                // The alternating horizontal movement tracker
                this.hOffset = 0; 
                this.hDir = (id % 2 === 0) ? 1 : -1;
            }

            step() {
                // COLLATZ ALGORITHM STEP
                if (this.n % 2 === 0) {
                    this.n = this.n / 2;
                    // Even numbers compress (gravity)
                    this.targetR = this.baseR * 0.5;
                    this.color = '#0ff'; // Cyan chill
                } else {
                    this.n = (3 * this.n) + 1;
                    // Odd numbers expand (energy)
                    this.targetR = this.baseR * 2.5;
                    this.color = '#f0f'; // Magenta excited
                }

                // If loop crashes to 1, reset with chaotic large number derived from time
                if (this.n < 2) {
                    this.n = Math.floor(Math.random() * 1000) + 10;
                }
            }

            update() {
                // Move towards radius target
                this.r += (this.targetR - this.r) * 0.05;
                
                // Orbit angle
                this.angle += this.speed * ((this.targetR > 200) ? 0.5 : 1.5); // Angular momentum cons.
                
                // Horizontal Oscillation (Alternating direction)
                this.hOffset += (this.targetR * 0.02) * this.hDir;
                if (Math.abs(this.hOffset) > w/2) {
                    this.hDir *= -1; // Bounce off screen edges conceptually
                }
            }

            draw() {
                // Polar to Cartesian
                let x = cx + Math.cos(this.angle) * this.r;
                let y = cy + Math.sin(this.angle) * this.r;

                // ADDING THE "HORIZONTAL SYMPHONIC ENTERING"
                // Instead of drawing a dot, we draw a horizontal interference line
                // "Mindfuckery" Mode:
                
                const lineWidth = 1 + (this.n % 10);
                
                ctx.beginPath();
                
                // Alternating horizontal scanning lines passing through the electron position
                if (this.id % 2 === 0) {
                    // Rightward entry
                    ctx.moveTo(x - this.hOffset, y);
                    ctx.lineTo(x + this.r, y); 
                } else {
                    // Leftward entry
                    ctx.moveTo(x + this.hOffset, y);
                    ctx.lineTo(x - this.r, y);
                }

                // Color depends on velocity
                ctx.strokeStyle = this.color;
                ctx.globalAlpha = 0.3; // Transparency for layering
                ctx.lineWidth = 2;
                ctx.stroke();

                // Core Electron
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = 1;
                ctx.fillRect(x, y, 3, 3);
            }
        }

        let electrons = [];
        let numbersString = ""; // For the display

        function initVisuals() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resize();
            window.addEventListener('resize', resize);
            
            // Create the 61 Electrons of Promethium
            electrons = [];
            for(let i=0; i<61; i++) {
                electrons.push(new CollatzElectron(i));
            }
            
            // Trigger a collatz step periodically to sync with rhythm
            setInterval(() => {
                // Randomly update a chunk of electrons
                electrons.forEach(e => {
                    if(Math.random() > 0.8) e.step();
                });
                
                // Update Numeric Display String (matrix rain style data)
                let active = electrons.filter((e,i) => i%5==0).map(e => e.n).join(" ");
                numDisplay.innerText = active + "\n" + (active.split("").reverse().join(""));
            }, 500);
        }
        
        function resize() {
            w = window.innerWidth;
            h = window.innerHeight;
            canvas.width = w;
            canvas.height = h;
            cx = w/2;
            cy = h/2;
        }

        function drawVisuals() {
            if(!audioRunning) return;
            requestAnimationFrame(drawVisuals);
            
            // TRIPPY TRAILS (Mindfuckery requires ghosting)
            // Composite difference makes it inverse colors periodically
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
            ctx.fillRect(0, 0, w, h);
            
            // The Wonderland blending
            ctx.globalCompositeOperation = 'lighter'; // or 'difference'

            electrons.forEach(e => {
                e.update();
                e.draw();
            });

            // The Atom Nucleus - Pulsing
            let pulse = 20 + Math.sin(actx.currentTime * 5) * 5;
            ctx.fillStyle = 'rgba(255, 50, 50, 0.2)';
            ctx.beginPath();
            ctx.arc(cx, cy, pulse, 0, Math.PI*2);
            ctx.fill();
        }

        /* ----------------------------------------------------------------
           AUDIO SYSTEM (FLUTES REUSED + WOLVES)
           ---------------------------------------------------------------- */
        
        let noiseBuffer;

        function initAudio() {
            actx = new (window.AudioContext || window.webkitAudioContext)();
            master = actx.createGain();
            master.gain.value = 0.6; 
            
            reverb = actx.createConvolver();
            const rate = actx.sampleRate;
            const length = rate * 6;
            const decay = 2.5;
            const imp = actx.createBuffer(2, length, rate);
            
            for (let c = 0; c < 2; c++) {
                const chan = imp.getChannelData(c);
                for (let i = 0; i < length; i++) {
                    chan[i] = (Math.random() * 2 - 1) * Math.pow(1 - (i / length), decay);
                }
            }
            reverb.buffer = imp;
            
            master.connect(reverb);
            reverb.connect(actx.destination);
            master.connect(actx.destination);

            const bSize = 2 * rate;
            noiseBuffer = actx.createBuffer(1, bSize, rate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bSize; i++) output[i] = Math.random() * 2 - 1;

            startOrchestra();
        }

        // FLUTE CLASS (Reused but with more modulation)
        class FluteVoice {
            constructor(layerID) {
                this.layer = layerID;
                this.isPlaying = false;
            }

            play(pitch, duration) {
                if(this.isPlaying) return;
                this.isPlaying = true;
                const t = actx.currentTime;
                
                // When a flute plays, trigger visual glitch on random electron
                if (Math.random() > 0.5) {
                    const idx = Math.floor(Math.random()*electrons.length);
                    electrons[idx].n = 314159; // Inject large N
                    electrons[idx].targetR = w/2;
                }

                // Audio Logic
                const osc = actx.createOscillator();
                osc.type = 'sine'; 
                osc.frequency.value = pitch;

                const lfo = actx.createOscillator();
                lfo.frequency.value = 5; 
                const lfoGain = actx.createGain();
                lfoGain.gain.value = pitch * 0.02; 
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start(t);

                const breathNode = actx.createBufferSource();
                breathNode.buffer = noiseBuffer;
                breathNode.loop = true;
                breathNode.playbackRate.value = 0.5 + (this.layer * 0.1); 

                const gain = actx.createGain();
                const breathGain = actx.createGain();

                const noiseFilter = actx.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = pitch * 1.5;
                noiseFilter.Q.value = 1;

                osc.connect(gain);
                breathNode.connect(noiseFilter);
                noiseFilter.connect(breathGain);
                
                gain.connect(master);
                breathGain.connect(master);

                const attack = 0.5;
                const vol = 0.05 / (1 + (Math.log(TOTAL_FLUTES) * 0.2)); 

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(vol, t + attack);
                gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

                breathGain.gain.setValueAtTime(0, t);
                breathGain.gain.linearRampToValueAtTime(vol * 0.6, t + 0.1);
                breathGain.gain.linearRampToValueAtTime(0, t + duration);

                osc.start(t);
                breathNode.start(t);
                
                setTimeout(() => {
                    osc.stop(); 
                    breathNode.stop();
                    osc.disconnect();
                    this.isPlaying = false;
                }, (duration+1) * 1000);
            }
        }

        const flutes = [];
        
        function startOrchestra() {
            // 7 Layers setup
            const distro = [5, 10, 12, 10, 8, 8, 8]; 
            distro.forEach((count, layerIdx) => {
                for(let i=0; i<count; i++) flutes.push(new FluteVoice(layerIdx));
            });
            conduct();
        }

        function conduct() {
            // FLUTES
            flutes.forEach(f => {
                if (f.isPlaying) return;
                const pBase = 0.001 + (f.layer * 0.002); 
                
                if (Math.random() < pBase) {
                    const octaveOffset = Math.floor(f.layer / 2);
                    const octaveMultiplier = Math.pow(2, octaveOffset);
                    const noteIdx = Math.floor(Math.random() * SCALE_RATIOS.length);
                    let freq = BASE_PITCH * SCALE_RATIOS[noteIdx] * octaveMultiplier;
                    if (f.layer === 6) freq *= 2; 
                    const duration = 2 + (Math.random() * 4) + ((6 - f.layer) * 2);
                    f.play(freq, duration);
                }
            });

            // WOLVES
            if (Math.random() < 0.005) { // Very Rare check per tick
                wolves[Math.floor(Math.random() * wolves.length)].howl();
            }

            setTimeout(conduct, 100);
        }

        /* --- INIT --- */
        startOverlay.addEventListener('click', () => {
            initAudio();
            initVisuals();
            actx.resume();
            
            startOverlay.classList.add('dissolve');
            audioRunning = true;
            
            document.body.style.cursor = 'none'; // Re-hide cursor
            drawVisuals();
        });

    </script>
</body>
</html>

PROGRAM 5
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Î© // THE OMEGA POINT // FINALITY</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Italiana&display=swap');

        :root {
            --void: #050505;
            --cyan: #00f3ff;
            --mag: #ff0055;
            --gold: #ffd700;
            --deep: #000080;
        }

        body {
            margin: 0;
            background: var(--void);
            overflow: hidden;
            font-family: 'Share Tech Mono', monospace;
            cursor: none; /* The system observes itself */
            height: 100vh;
            width: 100vw;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            /* The Unified Field Filter */
            filter: contrast(1.1) saturate(1.2);
        }

        #overlay {
            position: absolute;
            z-index: 100;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--cyan);
            transition: opacity 3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        h1 {
            font-family: 'Italiana', serif;
            font-size: 4rem;
            letter-spacing: 10px;
            margin: 0;
            text-shadow: 0 0 20px var(--deep);
            mix-blend-mode: screen;
        }

        p {
            margin-top: 20px;
            font-size: 1rem;
            opacity: 0.7;
            animation: pulse 2s infinite;
        }

        .dissolve {
            opacity: 0;
            pointer-events: none;
        }

        #debug {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 10px;
            z-index: 10;
            pointer-events: none;
        }

        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }
    </style>
</head>
<body>

    <!-- VISUAL CANVAS -->
    <canvas id="canvas"></canvas>

    <!-- UI LAYER -->
    <div id="overlay">
        <h1>Î© MEGA POINT</h1>
        <p>[ CLICK TO INITIATE SINGULARITY ]</p>
    </div>

    <div id="debug">waiting for prime mover...</div>

    <script>
        /**
         * THE OMEGA POINT ENGINE
         * INTEGRATING: PROMETHIUM 61 + 61 FLUTES + WITHOUT ME
         * TUNING: JUST INTONATION E LYDIAN (432Hz Base Ref)
         */

        const CONFIG = {
            baseFreq: 161.8, // Golden Ratio approx (E3)
            collatzStart: 27, // A volatile seed
            cycleDur: 20000, // ms per evolutionary phase
            maxParticles: 200
        };

        // JUST INTONATION E LYDIAN RATIOS
        // Root, M2, M3, #4 (Lydian), P5, M6, M7
        const SCALES = {
            lydian: [1, 9/8, 5/4, 45/32, 3/2, 5/3, 15/8],
            // Harmonics for the wolves
            overtones: [1, 2, 3, 4, 5, 6, 7, 8]
        };

        let actx, master, limiter, reverb;
        let wolfPack = [];
        let flutist;
        let w, h, cx, cy;
        let canvas, ctx;
        let time = 0;
        let isRunning = false;
        
        // --- GLOBAL STATE ---
        const State = {
            phase: 'GENESIS', // GENESIS -> CHAOS -> ORDER -> ASCENSION
            tension: 0,       // 0.0 to 1.0
            collatzVal: CONFIG.collatzStart,
            collatzPath: [],
            energy: 0
        };

        // --- AUDIO ENGINE ---
        
        async function initAudio() {
            actx = new (window.AudioContext || window.webkitAudioContext)();
            
            // MASTER BUS
            limiter = actx.createDynamicsCompressor();
            limiter.threshold.value = -10;
            limiter.knee.value = 40;
            limiter.ratio.value = 12;
            limiter.attack.value = 0;
            limiter.release.value = 0.25;

            // CONVOLUTION SIMULATION (Algorithmic Reverb)
            reverb = await createReverb(actx);

            limiter.connect(actx.destination);
            reverb.connect(limiter);

            // Initialize Instruments AFTER Context is ready
            wolfPack = [new Wolf(), new Wolf(), new Wolf()];
            flutist = new Flute();
            
            // Start the evolutionary clock
            setInterval(evolve, CONFIG.cycleDur);
            // Start the tick
            requestAnimationFrame(tick);
            
            // Binaural Theta Layer (Brain Entrainment)
            createBinauralDrone(161.8, 4.5); // E3 + Theta beat
        }

        // High Quality Algorithmic Reverb (The "Cathedral")
        async function createReverb(ctx) {
            const convolver = ctx.createConvolver();
            // Generate impulse response
            const rate = ctx.sampleRate;
            const length = rate * 4; // 4 seconds tail
            const decay = 2.0;
            const impulse = ctx.createBuffer(2, length, rate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const n = i; // reverse index
                left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
                right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
            }
            convolver.buffer = impulse;
            
            const input = ctx.createGain();
            const wet = ctx.createGain();
            const dry = ctx.createGain();
            
            input.connect(dry);
            input.connect(convolver);
            convolver.connect(wet);
            
            dry.connect(limiter);
            wet.connect(limiter);
            
            wet.gain.value = 0.5;
            dry.gain.value = 0.7;
            
            return input;
        }

        function createBinauralDrone(freq, beatFreq) {
            const lOsc = actx.createOscillator();
            const rOsc = actx.createOscillator();
            const lPan = actx.createStereoPanner();
            const rPan = actx.createStereoPanner();
            const gain = actx.createGain();

            lOsc.frequency.value = freq;
            rOsc.frequency.value = freq + beatFreq;
            
            lPan.pan.value = -1;
            rPan.pan.value = 1;
            
            gain.gain.value = 0.05; // Subtle background

            lOsc.connect(lPan).connect(gain);
            rOsc.connect(rPan).connect(gain);
            gain.connect(reverb);
            
            lOsc.start();
            rOsc.start();
        }

        // --- SYNTHESIS CLASSES ---

        class Wolf {
            constructor() {
                this.osc = actx.createOscillator();
                this.osc.type = 'sawtooth';
                this.filter = actx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.Q.value = 8;
                this.gain = actx.createGain();
                this.gain.gain.value = 0;

                this.osc.connect(this.filter).connect(this.gain).connect(reverb);
                this.osc.start();
            }

            howl(freq, dur) {
                const t = actx.currentTime;
                this.osc.frequency.setValueAtTime(freq * 0.5, t); // Sub oscillator
                this.osc.frequency.exponentialRampToValueAtTime(freq, t + dur * 0.2);
                this.osc.frequency.exponentialRampToValueAtTime(freq * 0.8, t + dur);

                // Formant simulation (The "Oooo" to "Aaa" sound)
                this.filter.frequency.setValueAtTime(400, t);
                this.filter.frequency.linearRampToValueAtTime(1200, t + dur * 0.4);
                this.filter.frequency.exponentialRampToValueAtTime(300, t + dur);

                this.gain.gain.setValueAtTime(0, t);
                this.gain.gain.linearRampToValueAtTime(0.2, t + 0.1);
                this.gain.gain.exponentialRampToValueAtTime(0.001, t + dur);

                // Visual trigger
                particles.push(new VisualAgent('howl', cx, cy));
            }
        }

        class Flute {
            constructor() {
                // Shared noise buffer logic simulation
            }

            play(freq, dur) {
                const t = actx.currentTime;
                const osc = actx.createOscillator();
                const gain = actx.createGain();
                const lfo = actx.createOscillator();
                const lfoGain = actx.createGain();

                // Vibrato
                lfo.frequency.value = 4 + Math.random(); // 4-5Hz Theta
                lfoGain.gain.value = 2;
                lfo.connect(lfoGain).connect(osc.frequency);
                lfo.start(t); lfo.stop(t+dur);

                osc.frequency.value = freq;
                osc.type = 'sine';

                // Breath (Filtered Noise)
                const noise = actx.createOscillator();
                noise.type = 'triangle'; // Approx noise for cheapness
                const nFilter = actx.createBiquadFilter();
                nFilter.type = 'bandpass';
                nFilter.frequency.value = freq * 1.5; // Breath formant
                const nGain = actx.createGain();
                nGain.gain.value = 0.05;
                
                // FM Noise modulation for "chiff"
                noise.frequency.value = freq * 2.13; // non-integer harmonic
                noise.connect(nFilter).connect(nGain).connect(limiter);
                noise.start(t); noise.stop(t+dur);

                // Envelope
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.15, t + dur*0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, t + dur);

                osc.connect(gain).connect(reverb);
                osc.start(t);
                osc.stop(t + dur);

                // Visual
                createFlowField(freq);
            }
        }

        // --- MATH ENGINE (COLLATZ) ---

        function nextCollatz(n) {
            return (n % 2 === 0) ? n / 2 : (3 * n) + 1;
        }

        // --- VISUAL ENGINE ---

        const particles = [];

        class VisualAgent {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.life = 1.0;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.hist = [];
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.005;
                this.hist.push({x: this.x, y: this.y});
                if(this.hist.length > 20) this.hist.shift();
            }

            draw(ctx) {
                ctx.beginPath();
                if(this.type === 'howl') {
                    ctx.strokeStyle = `rgba(255, 0, 85, ${this.life})`; // Mag
                    ctx.lineWidth = 2;
                    // Interference line style
                    ctx.moveTo(0, this.y);
                    ctx.lineTo(w, this.y);
                } else if (this.type === 'flow') {
                    ctx.strokeStyle = `rgba(0, 243, 255, ${this.life * 0.5})`; // Cyan
                    ctx.lineWidth = 1;
                    // Curve
                    ctx.moveTo(this.hist[0].x, this.hist[0].y);
                    for(let p of this.hist) ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
            }
        }

        function createFlowField(freq) {
            // Map freq to screen y
            const y = h - ((freq / 2000) * h);
            for(let i=0; i<5; i++) {
                particles.push(new VisualAgent('flow', Math.random()*w, y));
            }
        }

        // --- CONDUCTOR ---

        // MOVED INSTANTIATION TO initAudio TO PREVENT CRASH

        function evolve() {
            // Cycle phases
            const phases = ['GENESIS', 'CHAOS', 'ORDER', 'ASCENSION'];
            let idx = phases.indexOf(State.phase);
            idx = (idx + 1) % phases.length;
            State.phase = phases[idx];
            
            // UI Update
            document.getElementById('debug').innerText = `PHASE: ${State.phase} // TENSION: ${State.tension.toFixed(2)} // N: ${State.collatzVal}`;
            
            // Color Logic
            if(State.phase === 'CHAOS') document.body.style.background = '#100005';
            else if(State.phase === 'ORDER') document.body.style.background = '#000510';
            else document.body.style.background = '#000';
        }

        function tick() {
            if(!isRunning) return;
            
            time++;
            
            // 1. COLLATZ LOGIC (The Driver)
            if(time % 10 === 0) {
                let oldVal = State.collatzVal;
                State.collatzVal = nextCollatz(State.collatzVal);
                
                // Reset on loop
                if(State.collatzVal === 4 || State.collatzVal === 1 || State.collatzVal === 2) {
                    if(Math.random() > 0.8) State.collatzVal = Math.floor(Math.random() * 100) + 10;
                }

                // Sonify
                if(State.phase === 'CHAOS' || State.phase === 'ASCENSION') {
                    if(State.collatzVal % 2 !== 0) { // ODD (Expansion)
                         // Play Howl
                         if(wolfPack.length > 0) {
                            const wolf = wolfPack[Math.floor(Math.random()*wolfPack.length)];
                            const note = SCALES.lydian[Math.floor(Math.random()*SCALES.lydian.length)] * (CONFIG.baseFreq / 2);
                            wolf.howl(note, 2 + Math.random());
                         }
                    }
                }
            }

            // 2. AVIARY LOGIC (The Harmony)
            if(time % 40 === 0) { // Slower tick
                if(State.phase === 'GENESIS' || State.phase === 'ORDER' || State.phase === 'ASCENSION') {
                    if(Math.random() > 0.3 && flutist) {
                        const scaleDeg = SCALES.lydian[Math.floor(Math.random() * SCALES.lydian.length)];
                        // Spread across octaves
                        const octave = Math.pow(2, Math.floor(Math.random()*3)); 
                        flutist.play(CONFIG.baseFreq * scaleDeg * octave, 4 + Math.random()*4);
                    }
                }
            }

            // 3. VISUAL RENDER
            render();

            requestAnimationFrame(tick);
        }

        function render() {
            // Trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            if(State.phase === 'ASCENSION') ctx.fillStyle = 'rgba(0, 0, 0, 0.02)'; // Longer trails
            ctx.fillRect(0, 0, w, h);

            // Center Nucleus
            const pulse = Math.sin(time * 0.05) * 10;
            ctx.beginPath();
            ctx.arc(cx, cy, 50 + pulse, 0, Math.PI*2);
            
            // Mind Fuckery Blend Modes
            if(State.phase === 'CHAOS') {
                ctx.strokeStyle = '#f0f';
                ctx.globalCompositeOperation = 'difference';
            } else {
                ctx.strokeStyle = '#0ff';
                ctx.globalCompositeOperation = 'screen';
            }
            
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';

            // Draw Orbitals (The "Without Me" Strings)
            if(State.phase === 'ORDER' || State.phase === 'ASCENSION') {
                ctx.beginPath();
                ctx.ellipse(cx, cy, 200, 50 + pulse, time*0.01, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.stroke();
                
                ctx.beginPath();
                ctx.ellipse(cx, cy, 200, 50 - pulse, -time*0.01, 0, Math.PI*2);
                ctx.stroke();
            }

            // Update Particles
            particles.forEach((p, i) => {
                p.update();
                p.draw(ctx);
                if(p.life <= 0) particles.splice(i, 1);
            });
        }

        // --- INIT ---
        
        window.onload = () => {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resize();
            window.addEventListener('resize', resize);
            
            document.getElementById('overlay').addEventListener('click', () => {
                document.getElementById('overlay').classList.add('dissolve');
                initAudio();
                isRunning = true;
                State.collatzVal = Math.floor(Math.random() * 1000) + 500;
            });
        };

        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            cx = w / 2;
            cy = h / 2;
        }

    </script>
</body>
</html>

PROGRAM 6
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>THE LOFT // FOR A DEAR FRIEND</title>
<style>
    :root { --bg: #111; --act: #70ff80; --dim: #222; --txt: #eee; }
    body {
        margin: 0; background: var(--bg); overflow: hidden;
        font-family: 'Helvetica Neue', Arial, sans-serif; color: var(--txt);
        display: flex; justify-content: center; align-items: center; height: 100vh;
    }
    canvas { position: absolute; top: 0; left: 0; z-index: 1; }
    
    #ui {
        position: absolute; z-index: 10; width: 100%; height: 100%;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        background: radial-gradient(circle, transparent 0%, #000 120%);
        pointer-events: none;
    }

    #card {
        background: rgba(20, 20, 20, 0.9); padding: 40px; border: 1px solid #333;
        text-align: center; pointer-events: auto; border-radius: 4px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5); transition: opacity 0.5s;
    }

    h1 { margin: 0; font-weight: 300; letter-spacing: 4px; font-size: 2rem; margin-bottom: 10px; }
    p { color: #888; font-size: 0.8rem; margin-bottom: 30px; letter-spacing: 1px; }

    button {
        background: transparent; border: 1px solid var(--act); color: var(--act);
        padding: 15px 40px; font-size: 0.9rem; cursor: pointer; border-radius: 50px;
        transition: 0.2s; font-weight: bold; letter-spacing: 1px;
    }
    button:hover { background: var(--act); color: #000; box-shadow: 0 0 20px rgba(112, 255, 128, 0.4); }

    /* STAGE INDICATORS */
    #stages {
        position: absolute; bottom: 30px; display: flex; gap: 20px; opacity: 0; transition: opacity 1s; z-index: 5;
    }
    .stage {
        font-size: 10px; color: #444; text-transform: uppercase; letter-spacing: 2px;
        padding-bottom: 5px; border-bottom: 2px solid #222; transition: 0.3s;
    }
    .active-stage { color: var(--act); border-bottom: 2px solid var(--act); }

</style>
</head>
<body>

<div id="stages">
    <div id="s1" class="stage">1. RHYTHM</div>
    <div id="s2" class="stage">2. GROOVE</div>
    <div id="s3" class="stage">3. HARMONY</div>
    <div id="s4" class="stage">4. SOUL</div>
</div>

<div id="ui">
    <div id="card">
        <h1>THE LOFT</h1>
        <p>PROGRESSIVE HOUSE ENGINE // FOR A FRIEND</p>
        <button id="btn">OPEN THE DOORS</button>
    </div>
</div>

<canvas id="c"></canvas>

<script>
/**
 * THE LOFT
 * Genre: Deep House (124 BPM)
 * Logic: 4-Stage Progressive Layering
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

// AUDIO
let ac, master, limiter, compressor, sidechain;
let isPlaying = false;
let startTime = 0;

const BPM = 124;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;

// SCALES (C Minor 9)
// C3, Eb3, G3, Bb3, D4
const CHORD_NOTES = [130.81, 155.56, 196.00, 233.08, 293.66]; 
const BASS_NOTES = { C: 65.41, Eb: 77.78, F: 87.31, G: 98.00, Bb: 116.54 };

// ================= AUDIO ENGINE ================= //

async function init() {
    ac = new AC();
    await ac.resume();

    master = ac.createGain();
    master.gain.value = 0.6;

    // Dynamics
    limiter = ac.createDynamicsCompressor();
    limiter.threshold.value = -2;
    limiter.ratio.value = 20;

    // Master Sidechain Bus (Things connected here duck when kick hits)
    sidechain = ac.createGain();
    sidechain.gain.value = 1.0;

    master.connect(limiter).connect(ac.destination);
    sidechain.connect(master);
}

// --- 1. DRUMS (The Foundation) ---
function playKick(t) {
    const o = ac.createOscillator();
    const g = ac.createGain();
    
    o.frequency.setValueAtTime(150, t);
    o.frequency.exponentialRampToValueAtTime(45, t + 0.1);
    
    g.gain.setValueAtTime(1, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

    o.connect(g).connect(master); // Kick goes direct (no sidechain)
    o.start(t); o.stop(t + 0.3);

    // Trigger Sidechain Ducking
    sidechain.gain.cancelScheduledValues(t);
    sidechain.gain.setValueAtTime(0.2, t);
    sidechain.gain.linearRampToValueAtTime(1.0, t + 0.15); // "Pump" effect

    vis.kick = 1;
}

function playHat(t, open) {
    // White Noise
    const bufSize = ac.sampleRate * (open ? 0.3 : 0.05);
    const buf = ac.createBuffer(1, bufSize, ac.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0; i<bufSize; i++) data[i] = Math.random()*2-1;
    
    const noise = ac.createBufferSource();
    noise.buffer = buf;
    
    const f = ac.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 7000;
    const g = ac.createGain();
    g.gain.setValueAtTime(open ? 0.2 : 0.1, t);
    g.gain.exponentialRampToValueAtTime(0.01, t + (open ? 0.3 : 0.05));

    noise.connect(f).connect(g).connect(master);
    noise.start(t);
    vis.hat = 1;
}

function playClap(t) {
    const bufSize = ac.sampleRate * 0.15;
    const buf = ac.createBuffer(1, bufSize, ac.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0; i<bufSize; i++) data[i] = Math.random()*2-1;
    const noise = ac.createBufferSource(); noise.buffer = buf;

    const f = ac.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 1200; f.Q.value = 1;
    const g = ac.createGain();
    g.gain.setValueAtTime(0.5, t);
    g.gain.exponentialRampToValueAtTime(0.01, t+0.15);

    noise.connect(f).connect(g).connect(master);
    noise.start(t);
    vis.clap = 1;
}

// --- 2. BASS (The Groove) ---
function playBass(t, freq, len) {
    const o = ac.createOscillator(); o.type = 'sawtooth'; o.frequency.value = freq;
    
    const f = ac.createBiquadFilter(); f.type = 'lowpass'; 
    f.frequency.setValueAtTime(200, t);
    f.frequency.linearRampToValueAtTime(1000, t+0.05); // Filter envelope
    f.frequency.exponentialRampToValueAtTime(200, t+len);

    const g = ac.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.5, t+0.02);
    g.gain.linearRampToValueAtTime(0, t+len);

    o.connect(f).connect(g).connect(sidechain); // Ducked
    o.start(t); o.stop(t+len);
    vis.bass = 1;
}

// --- 3. CHORDS (The Atmosphere) ---
function playChord(t) {
    // Play full C Minor 9 chord
    CHORD_NOTES.forEach((freq, i) => {
        const o = ac.createOscillator();
        o.type = i % 2 === 0 ? 'sawtooth' : 'triangle'; // Mix waveforms
        o.frequency.value = freq;
        
        const f = ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value = 1500;
        
        const g = ac.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.08, t+0.05); // Soft stab
        g.gain.exponentialRampToValueAtTime(0.001, t+0.5);

        // Pan spread
        const p = ac.createStereoPanner();
        p.pan.value = (i / 4) * 2 - 1; // Spread -1 to 1

        o.connect(f).connect(g).connect(p).connect(sidechain);
        o.start(t); o.stop(t+0.6);
    });
    vis.chord = 1;
}

// --- 4. LEAD (The Soul) ---
function playLead(t, freq, dur) {
    const o = ac.createOscillator(); o.type = 'triangle'; 
    o.frequency.setValueAtTime(freq, t);
    
    // Slight vibrato
    const vib = ac.createOscillator(); vib.frequency.value = 4;
    const vibG = ac.createGain(); vibG.gain.value = 5;
    vib.connect(vibG).connect(o.frequency);

    const g = ac.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.15, t+0.1);
    g.gain.linearRampToValueAtTime(0, t+dur);
    
    // Delay effect
    const delay = ac.createDelay(); delay.delayTime.value = BEAT * 0.75;
    const dG = ac.createGain(); dG.gain.value = 0.4;
    
    g.connect(delay).connect(dG).connect(delay);
    g.connect(master);
    dG.connect(master);

    o.start(t); o.stop(t+dur);
    vib.start(t); vib.stop(t+dur);
    vis.lead = { x: Math.random()*w, y: Math.random()*h };
}

// ================= SEQUENCER ================= //

let step = 0;
let nextTime = 0;

function scheduler() {
    if(!isPlaying) return;
    const lookahead = 0.1;
    while(nextTime < ac.currentTime + lookahead) {
        runStep(step, nextTime);
        nextTime += SIXTEENTH;
        step++;
    }
    setTimeout(scheduler, 25);
}

function runStep(s, t) {
    const bar = Math.floor(s / 16);
    const bStep = s % 16;
    
    // PROGRESSION LOGIC (The 4 Stages)
    // 0-16 Bars: Stage 1 (Rhythm)
    // 16-32 Bars: Stage 2 (Bass)
    // 32-48 Bars: Stage 3 (Chords)
    // 48+ Bars: Stage 4 (Full)
    
    let stage = 1;
    if(bar >= 8) stage = 2; // Shortened for demo (8 bars per stage)
    if(bar >= 16) stage = 3;
    if(bar >= 24) stage = 4;
    
    // Loop song logic after 40 bars to keep it going
    if(bar >= 40) { 
        stage = 4; 
        if(bar >= 48) { step = 16 * 24; } // Loop back to Stage 4 drop
    }

    updateStageUI(stage);

    // --- COMPONENT 1: RHYTHM ---
    if(stage >= 1) {
        // Kick (4 on floor)
        if(bStep % 4 === 0) playKick(t);
        // Hats (Off beat)
        if(bStep % 2 === 0) playHat(t, false); // Closed
        if(bStep % 4 === 2) playHat(t, true);  // Open
        // Clap
        if(bStep === 4 || bStep === 12) playClap(t);
    }

    // --- COMPONENT 2: BASS ---
    if(stage >= 2) {
        // Syncopated House Bass
        // 1 . . 1 . . 1 .
        const note = (bar % 4 === 3) ? BASS_NOTES.F : BASS_NOTES.C; // Change root every 4th bar
        
        if(bStep === 0) playBass(t, note, SIXTEENTH * 3);
        if(bStep === 3) playBass(t, note, SIXTEENTH * 3);
        if(bStep === 6) playBass(t, (bar%2===0)?BASS_NOTES.Eb:BASS_NOTES.G, SIXTEENTH * 2);
        if(bStep === 11) playBass(t, note, SIXTEENTH);
        if(bStep === 14) playBass(t, BASS_NOTES.Bb, SIXTEENTH);
    }

    // --- COMPONENT 3: CHORDS ---
    if(stage >= 3) {
        // Deep House Stabs
        if(bStep === 2) playChord(t); // Off-beat stab
        if(bStep === 11) playChord(t); // Syncopated stab
    }

    // --- COMPONENT 4: LEAD ---
    if(stage >= 4) {
        // Simple repeating motif
        if(bStep === 0) playLead(t, CHORD_NOTES[4]*2, BEAT); // High D
        if(bStep === 6) playLead(t, CHORD_NOTES[3]*2, BEAT); // Bb
        if(bStep === 10) playLead(t, CHORD_NOTES[2]*2, BEAT); // G
    }
}

function updateStageUI(s) {
    for(let i=1; i<=4; i++) {
        const el = document.getElementById('s'+i);
        if(i <= s) el.classList.add('active-stage');
        else el.classList.remove('active-stage');
    }
}

// ================= VISUALS ================= //

let vis = { kick: 0, hat: 0, clap: 0, bass: 0, chord: 0, lead: null };

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.onresize = initVis;

function draw() {
    requestAnimationFrame(draw);
    
    // Dark Trails
    ctx.fillStyle = 'rgba(17, 17, 17, 0.2)';
    ctx.fillRect(0,0,w,h);
    
    const cx = w/2;
    const cy = h/2;
    
    // Draw 4 Quadrants
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, 0); ctx.lineTo(cx, h);
    ctx.moveTo(0, cy); ctx.lineTo(w, cy);
    ctx.stroke();

    // 1. TOP LEFT: DRUMS (Pulse)
    if(vis.kick > 0.01) {
        vis.kick *= 0.85;
        const r = 20 + vis.kick * 50;
        ctx.beginPath();
        ctx.arc(cx/2, cy/2, r, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${vis.kick})`;
        ctx.lineWidth = 4;
        ctx.stroke();
    }
    if(vis.hat > 0.01) { vis.hat *= 0.8; ctx.fillStyle='#fff'; ctx.fillRect(cx/2-2, cy/2-60, 4, 4); }
    if(vis.clap > 0.01) { vis.clap *= 0.8; ctx.strokeStyle='#fff'; ctx.strokeRect(cx/2-30, cy/2-30, 60, 60); }

    // 2. BOTTOM LEFT: BASS (Wave)
    if(vis.bass > 0.01) {
        vis.bass *= 0.9;
        ctx.beginPath();
        ctx.moveTo(0, cy * 1.5);
        for(let i=0; i<cx; i+=10) {
            ctx.lineTo(i, (cy*1.5) + Math.sin(i*0.1 + Date.now()*0.01) * vis.bass * 30);
        }
        ctx.strokeStyle = `rgba(112, 255, 128, ${vis.bass})`; // Green
        ctx.stroke();
    }

    // 3. TOP RIGHT: CHORDS (Blocks)
    if(vis.chord > 0.01) {
        vis.chord *= 0.9;
        ctx.fillStyle = `rgba(100, 150, 255, ${vis.chord * 0.5})`;
        const size = vis.chord * 100;
        ctx.fillRect((cx*1.5) - size/2, (cy*0.5) - size/2, size, size);
    }

    // 4. BOTTOM RIGHT: LEAD (Particles)
    if(vis.lead) {
        ctx.fillStyle = '#ff70a0';
        ctx.beginPath();
        // Constrain to bottom right quadrant
        const lx = cx + (vis.lead.x % cx);
        const ly = cy + (vis.lead.y % cy);
        ctx.arc(lx, ly, 4, 0, Math.PI*2);
        ctx.fill();
        vis.lead = null; // One frame flash
    }
    
    // Labels
    ctx.fillStyle = '#333';
    ctx.font = '10px Arial';
    ctx.fillText("RHYTHM", 20, 20);
    ctx.fillText("ATMOSPHERE", cx+20, 20);
    ctx.fillText("GROOVE", 20, cy+20);
    ctx.fillText("SOUL", cx+20, cy+20);
}

initVis();
draw();

document.getElementById('btn').addEventListener('click', async () => {
    document.getElementById('card').style.opacity = 0;
    document.getElementById('card').style.pointerEvents = 'none';
    document.getElementById('stages').style.opacity = 1;
    
    await init();
    isPlaying = true;
    startTime = ac.currentTime + 0.1;
    nextTime = startTime;
    scheduler();
});

</script>
</body>
</html>

PROGRAM 7
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TERMINUS // FULL ARRANGEMENT ENGINE</title>
<style>
    :root { --p: #ff3300; --s: #fff; --bg: #050505; }
    body { 
        margin: 0; background: var(--bg); overflow: hidden; 
        font-family: 'Courier New', monospace; color: var(--s);
        display: flex; justify-content: center; align-items: center; height: 100vh;
        user-select: none;
    }
    canvas { position: absolute; top: 0; left: 0; z-index: 1; }
    
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        pointer-events: none;
    }

    #panel {
        background: rgba(0,0,0,0.9); padding: 40px; border: 1px solid var(--p);
        text-align: center; pointer-events: auto; box-shadow: 0 0 100px rgba(255, 51, 0, 0.2);
        transition: opacity 0.5s;
    }

    h1 { font-size: 3rem; margin: 0 0 20px 0; letter-spacing: 8px; color: var(--p); text-shadow: 0 0 10px var(--p); }
    
    button {
        background: var(--p); color: #000; border: none; padding: 15px 40px;
        font-size: 1.2rem; font-weight: 900; letter-spacing: 2px; cursor: pointer;
        transition: 0.2s; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
    }
    button:hover { background: #fff; }

    /* HUD */
    #hud {
        position: absolute; top: 20px; left: 20px; z-index: 5;
        font-size: 12px; opacity: 0; transition: opacity 1s;
    }
    .row { display: flex; gap: 20px; margin-bottom: 5px; }
    .label { color: #666; }
    .val { color: var(--p); font-weight: bold; }

    /* TIMELINE */
    #timeline-container {
        position: absolute; bottom: 40px; left: 10%; width: 80%; height: 2px; background: #333; z-index: 5;
        opacity: 0; transition: opacity 1s;
    }
    #timeline-fill {
        height: 100%; width: 0%; background: var(--p);
        box-shadow: 0 0 10px var(--p); position: relative;
    }
    #timeline-marker {
        position: absolute; right: 0; top: -4px; width: 10px; height: 10px; background: #fff; border-radius: 50%;
    }
    .marker-label {
        position: absolute; top: -20px; font-size: 10px; color: #666; transform: translateX(-50%);
    }
</style>
</head>
<body>

<div id="hud">
    <div class="row"><span class="label">SECTION:</span><span class="val" id="hud-section">STANDBY</span></div>
    <div class="row"><span class="label">BAR:</span><span class="val" id="hud-bar">0</span></div>
    <div class="row"><span class="label">TIME:</span><span class="val" id="hud-time">00:00</span></div>
</div>

<div id="timeline-container">
    <div id="timeline-fill"><div id="timeline-marker"></div></div>
    <!-- Structure Markers -->
    <div class="marker-label" style="left: 0%">INTRO</div>
    <div class="marker-label" style="left: 20%">BUILD</div>
    <div class="marker-label" style="left: 30%">DROP</div>
    <div class="marker-label" style="left: 50%">BRIDGE</div>
    <div class="marker-label" style="left: 60%">DROP II</div>
    <div class="marker-label" style="left: 80%">OUTRO</div>
</div>

<div id="ui-layer">
    <div id="panel">
        <h1>TERMINUS</h1>
        <button id="btn">EXECUTE SEQUENCE</button>
    </div>
</div>

<canvas id="c"></canvas>

<script>
/**
 * PROJECT: TERMINUS
 * ENGINE: Linear Arrangement Sequencer
 * BPM: 174
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

// AUDIO GRAPH
let actx, master, limiter, distortion, reverb, analyser;
let isPlaying = false;
let startTime = 0;

// CONFIG
const BPM = 174;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;
const TOTAL_BARS = 160; // Full song length

// FREQUENCIES (F Minor)
const N = { F1: 43.65, Ab1: 51.91, C2: 65.41, F2: 87.31, G2: 98.00, Ab2: 103.83, C3: 130.81, F3: 174.61 };

// === 1. AUDIO ENGINE ===

async function init() {
    actx = new AC();
    await actx.resume();

    master = actx.createGain();
    master.gain.value = 0.6;

    limiter = actx.createDynamicsCompressor();
    limiter.threshold.value = -3;
    limiter.ratio.value = 20;
    
    distortion = actx.createWaveShaper();
    distortion.curve = makeDistortionCurve(80);
    
    analyser = actx.createAnalyser();
    analyser.fftSize = 1024;

    master.connect(limiter);
    limiter.connect(analyser);
    analyser.connect(actx.destination);

    reverb = await createReverb();
    reverb.output.connect(master);
}

function makeDistortionCurve(amount) {
    const k = amount, n = 44100, curve = new Float32Array(n);
    for (let i = 0; i < n; ++i) {
        const x = i * 2 / n - 1;
        curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
    }
    return curve;
}

async function createReverb() {
    const len = actx.sampleRate * 3;
    const b = actx.createBuffer(2, len, actx.sampleRate);
    for(let c=0;c<2;c++) for(let i=0;i<len;i++) b.getChannelData(c)[i] = (Math.random()*2-1)*Math.pow(1-i/len,3);
    const c = actx.createConvolver(); c.buffer = b;
    const i = actx.createGain(); const o = actx.createGain(); o.gain.value = 0.3;
    i.connect(c); c.connect(o);
    return {input:i, output:o};
}

// INSTRUMENTS

// 1. THE NEURO BASS (Reese)
// Two detuned saws + Modulation + Distortion
function playReese(t, freq, dur, modSpeed) {
    const o1 = actx.createOscillator(); o1.type='sawtooth'; o1.frequency.value=freq; o1.detune.value = -12;
    const o2 = actx.createOscillator(); o2.type='sawtooth'; o2.frequency.value=freq; o2.detune.value = 12;
    const sub = actx.createOscillator(); sub.type='sine'; sub.frequency.value=freq/2;

    const f = actx.createBiquadFilter(); f.type='lowpass'; f.Q.value = 6;
    
    // Filter Modulation (The "Wub")
    const lfo = actx.createOscillator(); 
    lfo.frequency.value = modSpeed; // Speed of the wobble
    const lfoG = actx.createGain(); lfoG.gain.value = 1500; // Depth of wobble
    lfo.connect(lfoG); lfoG.connect(f.frequency);
    f.frequency.setValueAtTime(500, t);

    const g = actx.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.6, t+0.05);
    g.gain.linearRampToValueAtTime(0, t+dur);

    const subG = actx.createGain(); subG.gain.value=0.6;

    o1.connect(f); o2.connect(f); f.connect(distortion);
    sub.connect(subG); subG.connect(g); // Sub clean
    distortion.connect(g); g.connect(master);

    o1.start(t); o1.stop(t+dur);
    o2.start(t); o2.stop(t+dur);
    sub.start(t); sub.stop(t+dur);
    lfo.start(t); lfo.stop(t+dur);
}

// 2. PUNCH KICK
function playKick(t) {
    const o = actx.createOscillator();
    o.frequency.setValueAtTime(150, t);
    o.frequency.exponentialRampToValueAtTime(40, t+0.1);
    const g = actx.createGain();
    g.gain.setValueAtTime(1, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
    
    const c = actx.createOscillator(); c.type='square'; 
    const cg = actx.createGain(); cg.gain.setValueAtTime(0.2, t); cg.gain.exponentialRampToValueAtTime(0.001, t+0.02);

    o.connect(g); g.connect(master); c.connect(cg); cg.connect(master);
    o.start(t); o.stop(t+0.2); c.start(t); c.stop(t+0.02);
    
    visPulse = 1;
}

// 3. SNAP SNARE
function playSnare(t) {
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.2, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer=b;
    const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=500;
    const g = actx.createGain(); g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
    
    const o = actx.createOscillator(); o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(100, t+0.1);
    const og = actx.createGain(); og.gain.setValueAtTime(0.5, t); og.gain.exponentialRampToValueAtTime(0.001, t+0.1);

    n.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    o.connect(og); og.connect(master);
    n.start(t); o.start(t); o.stop(t+0.15);
}

// 4. HI HATS
function playHat(t) {
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.05, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer=b;
    const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=8000;
    const g = actx.createGain(); g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.05);
    n.connect(f); f.connect(g); g.connect(master);
    n.start(t);
}

// 5. PADS
function playPad(t, freq, dur) {
    const o = actx.createOscillator(); o.type='sawtooth'; o.frequency.value=freq;
    const f = actx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=600;
    const g = actx.createGain(); 
    g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.15, t+1); g.gain.linearRampToValueAtTime(0, t+dur);
    o.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    o.start(t); o.stop(t+dur);
}

// === 2. LINEAR SEQUENCER ===

let nextNoteTime = 0.0;
let currentStep = 0;

function scheduler() {
    // Sync check: if we are lagging, jump to now
    if (nextNoteTime < actx.currentTime - 0.2) nextNoteTime = actx.currentTime + 0.1;

    while (nextNoteTime < actx.currentTime + 0.1) {
        scheduleStep(currentStep, nextNoteTime);
        nextNoteTime += SIXTEENTH;
        currentStep++;
    }
    
    // Update UI Time
    if (isPlaying) {
        const elapsed = actx.currentTime - startTime;
        const mins = Math.floor(elapsed/60);
        const secs = Math.floor(elapsed%60).toString().padStart(2,'0');
        document.getElementById('hud-time').innerText = `${mins}:${secs}`;
        setTimeout(scheduler, 25);
    }
}

function scheduleStep(step, t) {
    const bar = Math.floor(step / 16);
    const stepInBar = step % 16;
    
    // --- ARRANGEMENT STRUCTURE ---
    // 0-32: INTRO (Dark)
    // 32-48: BUILD (Riser)
    // 48-80: DROP A (Heavy)
    // 80-96: BRIDGE (Break)
    // 96-128: DROP B (Complex)
    // 128-160: OUTRO

    if (bar >= TOTAL_BARS) {
        stopSong();
        return;
    }

    let section = "INTRO";
    if(bar >= 32) section = "BUILD UP";
    if(bar >= 48) section = "DROP A";
    if(bar >= 80) section = "BRIDGE";
    if(bar >= 96) section = "DROP B";
    if(bar >= 128) section = "OUTRO";

    // UI Updates
    if(stepInBar === 0) {
        document.getElementById('hud-bar').innerText = bar + 1;
        document.getElementById('hud-section').innerText = section;
        const pct = (bar / TOTAL_BARS) * 100;
        document.getElementById('timeline-fill').style.width = pct + "%";
    }

    // --- DRUMS ---
    
    const isDrop = (section === "DROP A" || section === "DROP B");
    const isBuild = (section === "BUILD UP");
    
    if (isDrop || (isBuild && bar > 40)) {
        // Neuro Pattern: Kick on 0, Snare on 4 and 12
        if (stepInBar === 0) playKick(t);
        if (stepInBar === 4) playSnare(t);
        // Ghost kick
        if (stepInBar === 10) playKick(t);
        if (stepInBar === 12) playSnare(t);
        
        // Build Snare Roll
        if (isBuild && bar >= 46) {
            if (stepInBar % 2 === 0) playSnare(t);
        }
    }
    
    // Hi Hats
    if (section !== "INTRO" && section !== "OUTRO") {
        if (stepInBar % 2 === 0) playHat(t);
        if (isDrop && Math.random() > 0.7) playHat(t); // Shuffles
    }

    // --- BASS ---
    
    if (isDrop) {
        // Call
        if (stepInBar === 0) playReese(t, N.F1, BEAT * 1.5, 6); // Wobble
        // Response
        if (stepInBar === 6) playReese(t, N.F1, BEAT, 12); // Fast wobble
        // Fill
        if (stepInBar === 11) playReese(t, N.Ab1, BEAT, 2);
    } else if (section === "INTRO" || section === "BRIDGE") {
        // Drone Bass
        if (stepInBar === 0 && bar % 4 === 0) playReese(t, N.F1, BEAT*16, 0.5); // Slow filter move
    } else if (isBuild) {
        // Rising Bass
        if (stepInBar === 0) playReese(t, N.F1, BEAT, 8);
    }

    // --- ATMOSPHERE / PADS ---
    if (section === "INTRO" || section === "BRIDGE" || section === "OUTRO") {
        if (stepInBar === 0 && bar % 8 === 0) {
            playPad(t, N.F3, BEAT*32); // Long pad
            playPad(t, N.C3, BEAT*32);
        }
    }
}

function stopSong() {
    isPlaying = false;
    document.getElementById('hud-section').innerText = "COMPLETE";
    document.getElementById('panel').style.opacity = 1;
    document.querySelector('h1').innerText = "TERMINATED";
    document.getElementById('btn').innerText = "RELOAD SYSTEM";
    document.getElementById('btn').onclick = () => location.reload();
}

// === 3. VISUALS ===

let visPulse = 0;
let time = 0;

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}

function draw() {
    requestAnimationFrame(draw);
    
    // Trails
    ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
    ctx.fillRect(0,0,w,h);
    
    visPulse *= 0.9;
    time += 0.01;
    
    const cx = w/2;
    const cy = h/2;
    
    const section = document.getElementById('hud-section').innerText;
    const isDrop = section.includes("DROP");
    
    // Get Frequency Data
    const freq = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(freq);
    
    // Draw Tunnel / Spectrum
    ctx.lineWidth = 2;
    
    // Number of shapes
    const shapes = isDrop ? 20 : 10;
    
    for(let i=0; i<shapes; i++) {
        const z = (time * 2 + i) % shapes; // Movement
        const size = Math.pow(z, 3) * 5;
        const alpha = z / shapes;
        
        if (size > w * 1.5) continue;
        
        ctx.beginPath();
        
        // Deform shape based on audio
        const audioVal = freq[i * 2] / 255;
        const r = size + (audioVal * 100 * visPulse);
        
        // Draw Hexagon
        for(let j=0; j<6; j++) {
            const angle = (Math.PI*2/6) * j + (time * 0.5 * (i%2?-1:1));
            const x = cx + Math.cos(angle) * r;
            const y = cy + Math.sin(angle) * r;
            if(j===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.closePath();
        
        const hue = isDrop ? 0 : 180; // Red vs Cyan
        ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
        ctx.stroke();
    }
    
    // Impact Flash
    if (visPulse > 0.8) {
        ctx.fillStyle = `rgba(255, 255, 255, ${visPulse * 0.1})`;
        ctx.fillRect(0,0,w,h);
    }
}

window.onresize = initVis;
initVis();

document.getElementById('btn').addEventListener('click', async (e) => {
    const btn = e.target;
    btn.innerText = "RUNNING...";
    document.getElementById('panel').style.opacity = 0;
    document.getElementById('hud').style.opacity = 1;
    document.getElementById('timeline-container').style.opacity = 1;
    
    await init();
    startTime = actx.currentTime + 0.1;
    nextNoteTime = startTime;
    isPlaying = true;
    
    scheduler();
    draw();
});

</script>
</body>
</html>

PROGRAM 8
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EUPHORIA // THE FINAL ANTHEM</title>
    <style>
        body { 
            margin: 0; background: #000; overflow: hidden; 
            font-family: 'Montserrat', sans-serif; color: #fff;
            display: flex; justify-content: center; align-items: center; height: 100vh;
        }
        canvas { position: absolute; top: 0; left: 0; z-index: 1; }
        #ui {
            z-index: 10; text-align: center; background: rgba(0,0,0,0.7);
            padding: 60px; border-radius: 30px; backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 0 100px rgba(0, 150, 255, 0.3);
            transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        h1 { font-weight: 800; letter-spacing: 15px; margin: 0 0 10px 0; font-size: 3rem; 
             background: linear-gradient(to right, #fff, #00d2ff); -webkit-background-clip: text; color: transparent; }
        h3 { font-weight: 300; letter-spacing: 5px; margin-bottom: 40px; font-size: 0.9rem; color: #ccc; }
        button {
            background: #fff; color: #000; border: none; padding: 20px 60px;
            font-size: 1.2rem; letter-spacing: 3px; cursor: pointer; border-radius: 50px; font-weight: bold;
            box-shadow: 0 10px 30px rgba(255,255,255,0.2); transition: all 0.3s;
        }
        button:hover { transform: translateY(-3px) scale(1.05); box-shadow: 0 20px 50px rgba(255,255,255,0.4); }
        #status { margin-top: 25px; font-size: 0.8rem; opacity: 0.6; font-family: monospace; letter-spacing: 2px; }
    </style>
</head>
<body>

<div id="ui">
    <h1>EUPHORIA</h1>
    <h3>THE FINAL ANTHEM</h3>
    <button id="playBtn">INITIATE SEQUENCE</button>
    <div id="status">Audio Core: STANDBY</div>
</div>
<canvas id="c"></canvas>

<script>
/**
 * PROJECT: EUPHORIA [FINAL ANTHEM]
 * UPGRADES: Formant Vocal Synthesis ("Cyber-Vox"), CO2 FX, 3D Visuals
 * BPM: 128
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

let actx, master, reverb, delay, comp, analyser;
let isPlaying = false;
let startTime = 0;

// CONFIG
const BPM = 128;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;

// NOTES (D Major)
const N = {
    D2: 73.42, G2: 98.00, A2: 110.00, B2: 123.47,
    D3: 146.83, E3: 164.81, Fs3: 185.00, A3: 220.00, B3: 246.94, Cs4: 277.18,
    D4: 293.66, E4: 329.63, Fs4: 369.99, G4: 392.00, A4: 440.00, B4: 493.88, Cs5: 554.37, D5: 587.33
};

// PROGRESSION: D -> A -> Bm -> G
const CHORDS = [
    [N.D3, N.Fs3, N.A3, N.D4], 
    [N.A3, N.Cs4, N.E4, N.A4], 
    [N.B3, N.D4, N.Fs4, N.B4], 
    [N.G2*2, N.B3, N.D4, N.G4] 
];
const BASS = [N.D2, N.A2, N.B2, N.G2];

// THE VOCAL CHOP MELODY (Anthemic)
const VOCAL_MELODY = [
    {t:0, n:N.Fs4}, {t:1.5, n:N.A4}, {t:3, n:N.D5}, {t:3.5, n:N.Cs5}, {t:4, n:N.A4},
    {t:7, n:N.E4}, {t:8, n:N.Fs4}, {t:11, n:N.A4}, {t:12, n:N.B4}, {t:14, n:N.A4}
];

// --- AUDIO CORE ---

async function init() {
    actx = new AC();
    await actx.resume();

    // 1. Master Chain
    master = actx.createGain();
    master.gain.value = 0.5;

    // "Glue" Compressor
    comp = actx.createDynamicsCompressor();
    comp.threshold.value = -12;
    comp.ratio.value = 8;
    comp.attack.value = 0.003;
    comp.release.value = 0.25;

    analyser = actx.createAnalyser();
    analyser.fftSize = 256;

    master.connect(comp);
    comp.connect(analyser);
    analyser.connect(actx.destination);

    // 2. Sends
    reverb = await createReverb();
    delay = createDelay();

    reverb.output.connect(master);
    delay.output.connect(master);
}

// Stadium Reverb (Convolution)
async function createReverb() {
    const len = actx.sampleRate * 3.0; // 3 seconds tail
    const buff = actx.createBuffer(2, len, actx.sampleRate);
    for(let c=0; c<2; c++){
        const d = buff.getChannelData(c);
        for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 3);
    }
    const conv = actx.createConvolver();
    conv.buffer = buff;
    const inp = actx.createGain();
    const out = actx.createGain();
    out.gain.value = 0.5; 
    inp.connect(conv); conv.connect(out);
    return {input: inp, output: out};
}

function createDelay() {
    const inp = actx.createGain();
    const out = actx.createGain();
    const dl = actx.createDelay();
    const dr = actx.createDelay();
    const fb = actx.createGain();
    dl.delayTime.value = BEAT * 0.75; 
    dr.delayTime.value = BEAT * 0.5;  
    fb.gain.value = 0.4;
    out.gain.value = 0.3;
    inp.connect(dl); inp.connect(dr);
    dl.connect(fb); dr.connect(fb);
    fb.connect(dl); fb.connect(dr);
    dl.connect(out); dr.connect(out);
    return {input: inp, output: out};
}

// --- INSTRUMENTS ---

// 1. THE "CYBER-VOX" (Formant Synthesis)
// This mimics a human vocal tract
function playVox(t, freq) {
    const osc = actx.createOscillator();
    osc.type = 'sawtooth'; // Saw provides harmonics
    osc.frequency.value = freq;

    // Formant Filters (Ah sound: ~700Hz, ~1200Hz, ~2500Hz)
    const f1 = actx.createBiquadFilter(); f1.type='bandpass'; f1.frequency.value=700; f1.Q.value=3;
    const f2 = actx.createBiquadFilter(); f2.type='bandpass'; f2.frequency.value=1200; f2.Q.value=3;
    const f3 = actx.createBiquadFilter(); f3.type='bandpass'; f3.frequency.value=2800; f3.Q.value=3;

    // Parallel Routing
    osc.connect(f1); osc.connect(f2); osc.connect(f3);

    const gain = actx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.3, t + 0.05); // "Ah" attack
    gain.gain.setValueAtTime(0.3, t + 0.3); 
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5); // Release

    // Merge
    f1.connect(gain); f2.connect(gain); f3.connect(gain);

    // FX
    gain.connect(master);
    gain.connect(reverb.input); // Vocals need huge reverb
    gain.connect(delay.input);

    osc.start(t); osc.stop(t+0.6);
    
    // Slight vibrato
    const vib = actx.createOscillator();
    vib.frequency.value = 5;
    const vibGain = actx.createGain();
    vibGain.gain.value = 5;
    vib.connect(vibGain);
    vibGain.connect(osc.frequency);
    vib.start(t); vib.stop(t+0.6);
}

// 2. FLAMENCO GUITAR
function playGuitar(t, freq, index) {
    const time = t + (index * 0.035);
    const osc = actx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = freq;
    const f = actx.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(0, time);
    f.frequency.linearRampToValueAtTime(3500, time+0.01); f.frequency.exponentialRampToValueAtTime(freq, time+0.3);
    const g = actx.createGain(); g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(0.2, time+0.01); g.gain.exponentialRampToValueAtTime(0.001, time+0.4);
    
    // Pluck Noise
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.02, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
    n.buffer=b; const ng=actx.createGain(); ng.gain.value=0.05; n.connect(ng); ng.connect(master);
    
    osc.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    osc.start(time); osc.stop(time+0.5); n.start(time);
}

// 3. PIANO
function playPiano(t, freq, vel) {
    const o1=actx.createOscillator(); o1.type='triangle'; o1.frequency.value=freq;
    const o2=actx.createOscillator(); o2.type='square'; o2.frequency.value=freq; o2.detune.value=5;
    const f=actx.createBiquadFilter(); f.frequency.setValueAtTime(0,t); f.frequency.linearRampToValueAtTime(freq*6, t+0.01); f.frequency.exponentialRampToValueAtTime(freq, t+1.5);
    const g=actx.createGain(); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.2*vel, t+0.02); g.gain.exponentialRampToValueAtTime(0.001, t+1.5);
    o1.connect(f); o2.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    o1.start(t); o2.start(t); o1.stop(t+2); o2.stop(t+2);
}

// 4. FX: CO2 CANNON (White Noise Burst)
function playCO2(t) {
    const bSize = actx.sampleRate * 1.0;
    const b = actx.createBuffer(1, bSize, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<bSize;i++) d[i]=Math.random()*2-1;
    const src = actx.createBufferSource(); src.buffer = b;
    const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.setValueAtTime(1000, t);
    const g = actx.createGain(); g.gain.setValueAtTime(0.4, t); g.gain.exponentialRampToValueAtTime(0.001, t+1.0);
    src.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    src.start(t);
}

// 5. FX: SUB DROP
function playSubDrop(t) {
    const o = actx.createOscillator(); o.frequency.setValueAtTime(80, t); o.frequency.exponentialRampToValueAtTime(1, t+2);
    const g = actx.createGain(); g.gain.setValueAtTime(0.8, t); g.gain.linearRampToValueAtTime(0, t+2);
    o.connect(g); g.connect(master);
    o.start(t); o.stop(t+2);
}

// 6. PERCUSSION
function playKick(t) {
    const o = actx.createOscillator(); o.frequency.setValueAtTime(130, t); o.frequency.exponentialRampToValueAtTime(40, t+0.3);
    const g = actx.createGain(); g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.3);
    const c = actx.createOscillator(); c.type='square'; 
    const cg = actx.createGain(); cg.gain.setValueAtTime(0.1, t); cg.gain.exponentialRampToValueAtTime(0.001, t+0.02);
    o.connect(g); g.connect(master); c.connect(cg); cg.connect(master);
    o.start(t); o.stop(t+0.3); c.start(t); c.stop(t+0.05);
    pulse=1; // Visual trigger
}

function playRatamba(t, p) {
    const o = actx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(p, t); o.frequency.exponentialRampToValueAtTime(p*0.8, t+0.1);
    const g = actx.createGain(); g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
    o.connect(g); g.connect(master); g.connect(reverb.input);
    o.start(t); o.stop(t+0.2);
}

function playMarimba(t, f) {
    const o = actx.createOscillator(); o.type='sine'; o.frequency.value=f; 
    const g = actx.createGain(); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.2,t+0.01); g.gain.exponentialRampToValueAtTime(0.001,t+0.3);
    o.connect(g); g.connect(master); g.connect(delay.input);
    o.start(t); o.stop(t+0.4);
}

function playPad(t, chord) {
    const g = actx.createGain(); g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.1, t+1); g.gain.setValueAtTime(0.1, t+BEAT*4-0.5); g.gain.linearRampToValueAtTime(0, t+BEAT*4);
    const f = actx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=800;
    chord.forEach((fr, i) => {
        const o = actx.createOscillator(); o.type='sawtooth'; o.frequency.value=fr; o.detune.value=(i%2==0?10:-10);
        o.connect(f); o.start(t); o.stop(t+BEAT*4);
    });
    f.connect(g); g.connect(master); g.connect(reverb.input);
}

// --- SEQUENCER ---

let nextNoteTime = 0;
let currentStep = 0;

function scheduler() {
    while(nextNoteTime < actx.currentTime + 0.1) {
        runStep(currentStep, nextNoteTime);
        nextNoteTime += SIXTEENTH;
        currentStep++;
    }
    setTimeout(scheduler, 25);
}

function runStep(step, t) {
    const bar = Math.floor(step / 16);
    const stepInBar = step % 16;
    const chord = CHORDS[bar % 4];
    const bass = BASS[bar % 4];

    // PHASES
    const intro = bar < 4;
    const breakdown = bar >= 4 && bar < 8; // Piano + Vocal
    const build = bar >= 8 && bar < 12; // Snare roll + Vocal
    const drop = bar >= 12; // Full mayhem

    // 1. PIANO (Always running except build silence)
    if (stepInBar % 2 === 0) {
        if (!build || stepInBar < 8) { // Cut piano half way thru build
            playPiano(t, chord[(stepInBar/2)%chord.length], 0.6+Math.random()*0.4);
        }
    }

    // 2. VOCAL CHOP (Breakdown, Build, Drop)
    if (breakdown || build || drop) {
        const note = VOCAL_MELODY.find(m => m.t === stepInBar);
        if (note) {
            // Randomly octave shift for "chopped" feel
            const octave = (Math.random() > 0.7) ? 2 : 1;
            playVox(t, note.n * octave);
        }
    }

    // 3. FLAMENCO (Intro & Drop)
    if ((intro || drop) && stepInBar % 4 === 2) {
        chord.forEach((n, i) => playGuitar(t, n * 2, i));
    }
    if ((intro || drop) && stepInBar > 13) {
        playGuitar(t, chord[0]*2, 0);
    }

    // 4. PADS (All except intro)
    if (!intro && stepInBar === 0) playPad(t, chord);

    // 5. PERCUSSION (Drop Only)
    if (drop) {
        // Kick
        if (stepInBar % 4 === 0) playKick(t);
        // Offbeat Bass
        setTimeout(() => playMarimba(t + SIXTEENTH*2, bass), 0);
        
        // Ratambas Fills
        if (stepInBar === 3 || stepInBar === 6 || stepInBar === 14) playRatamba(t, 500);
        // Marimba Arps
        if (stepInBar % 2 === 0) playMarimba(t, chord[Math.floor(Math.random()*3)]*2);
        
        // CO2 Blast on Bar 1 of Drop
        if (stepInBar === 0 && bar === 12) {
            playCO2(t);
            playSubDrop(t);
        }
    }

    // 6. BUILD UP (Snare Roll)
    if (build) {
        // Accelerating snare
        let interval = 4;
        if (stepInBar > 8) interval = 2;
        if (stepInBar > 12) interval = 1;
        
        if (step % interval === 0) {
             const s = actx.createOscillator(); s.type='white'; // Noise snare sim
             // (Using simple kick function with high pitch for snare-ish sound)
             playRatamba(t, 200 + (stepInBar*20)); // Rising pitch
        }
        if (stepInBar === 0) playCO2(t); // Riser start
    }

    // Loop at 20 bars
    if (bar >= 20) currentStep = 192; // Loop back to drop (bar 12)
    
    // UI
    if (stepInBar === 0) {
        let txt = "INTRO";
        if(breakdown) txt = "BREAKDOWN (Vocals)";
        if(build) txt = "BUILD UP";
        if(drop) txt = ">>> THE DROP <<<";
        document.getElementById('status').innerText = `${txt} | BAR ${bar+1}`;
    }
}

// --- 3D VISUAL ENGINE ---
let pulse = 0;
let flySpeed = 0;
let gridOffset = 0;

function initVisuals() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}

function draw() {
    requestAnimationFrame(draw);
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,w,h);

    pulse *= 0.92;
    if(pulse < 0.01) pulse = 0;
    
    // Grid Speed varies by song intensity
    flySpeed = 2 + (pulse * 20);
    gridOffset = (gridOffset + flySpeed) % 100;

    const cx = w/2;
    const cy = h/2;
    
    // RETRO 3D GRID
    ctx.save();
    ctx.beginPath();
    
    // Horizon
    const horizon = cy - 50;
    
    // Gradient Floor
    const grad = ctx.createLinearGradient(0, horizon, 0, h);
    grad.addColorStop(0, '#000');
    grad.addColorStop(0.3, '#100020');
    grad.addColorStop(1, '#001030');
    ctx.fillStyle = grad;
    ctx.fillRect(0, horizon, w, h-horizon);

    // Vertical Lines (Perspective)
    ctx.strokeStyle = `rgba(0, 200, 255, ${0.3 + pulse * 0.4})`;
    ctx.lineWidth = 1;
    
    for (let i = -1000; i <= 1000; i += 100) {
        // 3D projection math
        // x_screen = (x_world / z) + center
        const x1 = cx + (i * 100) / 100; // Far
        const x2 = cx + (i * 300) / 10;  // Near
        ctx.moveTo(cx, horizon); 
        ctx.lineTo(x2, h);
    }

    // Horizontal Lines (Moving)
    for (let z = 0; z < 500; z += 50) {
        const zDepth = z + (100 - gridOffset); // Move towards camera
        const scale = 200 / zDepth;
        const y = horizon + (zDepth * 0.5); // Fake perspective height
        if (y > h) continue;

        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
    }
    ctx.stroke();

    // ANALYZER SUN
    const data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);
    
    const radius = 80 + (data[4] / 2); // Reacts to bass
    
    ctx.beginPath();
    ctx.arc(cx, horizon - 80, radius, 0, Math.PI*2);
    
    // Sun Gradient
    const sunGrad = ctx.createRadialGradient(cx, horizon-80, 0, cx, horizon-80, radius);
    sunGrad.addColorStop(0, '#fff');
    sunGrad.addColorStop(0.5, '#00d2ff');
    sunGrad.addColorStop(1, 'rgba(0,0,255,0)');
    ctx.fillStyle = sunGrad;
    ctx.fill();

    // FREQUENCY BARS (Mirrored)
    const barWidth = w / 60;
    for(let i=0; i<30; i++) {
        const val = data[i + 5]; // Skip ultra low freq
        const barH = val * 1.5;
        const hue = 180 + (i * 2);
        
        ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.8)`;
        
        // Right side
        ctx.fillRect(cx + (i * barWidth) + radius + 10, horizon, barWidth - 2, -barH);
        // Left side
        ctx.fillRect(cx - (i * barWidth) - radius - 10 - barWidth, horizon, barWidth - 2, -barH);
        
        // Reflection
        ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.2)`;
        ctx.fillRect(cx + (i * barWidth) + radius + 10, horizon, barWidth - 2, barH * 0.5);
        ctx.fillRect(cx - (i * barWidth) - radius - 10 - barWidth, horizon, barWidth - 2, barH * 0.5);
    }

    ctx.restore();
}

window.onresize = initVisuals;
initVisuals();

document.getElementById('playBtn').addEventListener('click', async (e) => {
    e.target.innerText = "SEQUENCE RUNNING...";
    e.target.style.background = "#00d2ff";
    e.target.disabled = true;
    
    document.getElementById('ui').style.transform = "scale(0.9) translateY(50px)";
    document.getElementById('ui').style.opacity = 0;
    setTimeout(() => document.getElementById('ui').style.display='none', 800);

    await init();
    startTime = actx.currentTime + 0.1;
    nextNoteTime = startTime;
    isPlaying = true;
    scheduler();
    draw();
});

</script>
</body>
</html>

PROGRAM 9
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>VELOCITY // FULL MOTION</title>
<style>
    :root { --neon: #00f3ff; --dark: #050a10; }
    body { 
        margin: 0; background: var(--dark); overflow: hidden; 
        font-family: 'Consolas', monospace; color: #fff; cursor: crosshair;
        user-select: none;
    }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
    #hud {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
        pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        padding: 20px; box-sizing: border-box;
    }
    .panel { display: flex; justify-content: space-between; align-items: flex-start; }
    .stat { font-size: 12px; color: rgba(255,255,255,0.7); text-shadow: 0 0 5px var(--neon); }
    #center-overlay {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        text-align: center; pointer-events: auto; z-index: 20;
        background: rgba(0, 5, 16, 0.9); padding: 60px; border: 1px solid var(--neon);
        box-shadow: 0 0 100px rgba(0, 243, 255, 0.2); backdrop-filter: blur(10px);
        transition: opacity 1s cubic-bezier(0.2, 0.8, 0.2, 1);
    }
    h1 { 
        font-size: 4rem; margin: 0; letter-spacing: 15px; 
        background: linear-gradient(to bottom, #fff, var(--neon)); 
        -webkit-background-clip: text; color: transparent;
    }
    button {
        background: transparent; color: var(--neon); border: 2px solid var(--neon);
        padding: 15px 50px; font-size: 1.2rem; letter-spacing: 3px; cursor: pointer;
        margin-top: 30px; transition: all 0.3s; font-family: inherit; font-weight: bold;
    }
    button:hover { background: var(--neon); color: #000; box-shadow: 0 0 50px var(--neon); }
    #progress-container {
        position: fixed; bottom: 0; left: 0; width: 100%; height: 4px; background: #111; z-index: 30;
    }
    #progress-bar { width: 0%; height: 100%; background: var(--neon); box-shadow: 0 0 20px var(--neon); transition: width 0.2s linear; }
    .glitch { animation: glitch 2s infinite; }
    @keyframes glitch { 0% { opacity: 1; } 98% { opacity: 1; transform: translate(0); } 99% { opacity: 0.8; transform: translate(-2px, 2px); } 100% { opacity: 1; } }
</style>
</head>
<body>

<div id="progress-container"><div id="progress-bar"></div></div>

<div id="center-overlay">
    <div class="glitch">
        <h1>VELOCITY</h1>
        <div style="letter-spacing: 5px; opacity: 0.7; margin-top: 10px;">FULL MOTION ENGINE // 174 BPM</div>
    </div>
    <button id="init">ENGAGE SYSTEMS</button>
</div>

<div id="hud">
    <div class="panel">
        <div class="stat" id="status-phase">SYSTEM: STANDBY</div>
        <div class="stat" id="status-time">00:00:00</div>
    </div>
    <div class="panel">
        <div class="stat">DSP LOAD: <span id="dsp-load">0%</span></div>
        <div class="stat">MASTER GAIN: 0.0dB</div>
    </div>
</div>

<canvas id="c"></canvas>

<script>
/**
 * -------------------------------------------------------------------------
 * PROJECT: VELOCITY [FINAL CUT]
 * GENRE: Liquid Drum & Bass
 * ARRANGEMENT: Full 160-Bar Song Structure
 * -------------------------------------------------------------------------
 */

// === 1. CORE ENGINE ===
const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

let actx, master, limiter, reverb, analyser;
let isPlaying = false;
let startTime = 0;

// CONFIG
const BPM = 174;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;
const BAR = BEAT * 4;

// THEORY (F Minor)
const N = {
    F1:43.65, G1:49.00, Ab1:51.91, Bb1:58.27, C1:65.41, Db1:69.30, Eb1:77.78,
    F2:87.31, G2:98.00, Ab2:103.83, Bb2:116.54, C2:130.81, Db2:138.59, Eb2:155.56,
    F3:174.61, G3:196.00, Ab3:207.65, Bb3:233.08, C3:261.63, Db3:277.18, Eb3:311.13,
    F4:349.23, G4:392.00, Ab4:415.30, Bb4:466.16, C4:523.25, Db4:554.37, Eb4:622.25,
    F5:698.46, Ab5:830.61, C5:1046.50
};

// CHORDS (i - VI - III - VII)
const CHORDS = [
    [N.F3, N.Ab3, N.C4, N.Eb4], // Fm7
    [N.Db3, N.F3, N.Ab3, N.C4], // DbMaj7
    [N.Ab3, N.C4, N.Eb4, N.G4], // AbMaj7
    [N.Eb3, N.G3, N.Bb3, N.Eb4] // Eb
];
const BASS = [N.F1, N.Db1, N.Ab1, N.Eb1];

// MELODIES
const PIANO_MELODY = [
    {s:0, n:N.C5}, {s:3, n:N.Bb4}, {s:6, n:N.Ab4}, {s:8, n:N.F4}, {s:12, n:N.C5},
    {s:16, n:N.Db5}, {s:19, n:N.C5}, {s:22, n:N.Ab4}, {s:26, n:N.F4},
    {s:32, n:N.Eb5}, {s:35, n:N.C5}, {s:38, n:N.Bb4}, {s:42, n:N.Ab4}
];

const VOX_MELODY = [
    {s:0, n:N.F4}, {s:2, n:N.Ab4}, {s:6, n:N.C5}, {s:10, n:N.Bb4}, {s:14, n:N.Ab4},
    {s:16, n:N.F4}, {s:20, n:N.Eb4}, {s:24, n:N.F4}
];


// === 2. AUDIO DSP ===

async function initAudio() {
    actx = new AC();
    await actx.resume();

    master = actx.createGain();
    master.gain.value = 0.6;

    // Mastering Limiter
    limiter = actx.createDynamicsCompressor();
    limiter.threshold.value = -6;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.003;
    
    analyser = actx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.85;

    master.connect(limiter);
    limiter.connect(analyser);
    analyser.connect(actx.destination);

    reverb = await createReverb();
    reverb.output.connect(master);
}

async function createReverb() {
    const len = actx.sampleRate * 3.0;
    const b = actx.createBuffer(2, len, actx.sampleRate);
    for(let c=0; c<2; c++){
        const d = b.getChannelData(c);
        for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 3);
    }
    const c = actx.createConvolver();
    c.buffer = b;
    const i = actx.createGain();
    const o = actx.createGain();
    o.gain.value = 0.4;
    i.connect(c); c.connect(o);
    return {input:i, output:o};
}

// -- INSTRUMENTS --

// 1. REESE BASS (The Wobble)
function playReese(t, freq, dur, filterStart=100, filterEnd=800) {
    const osc1 = actx.createOscillator(); osc1.type='sawtooth'; osc1.frequency.value=freq; osc1.detune.value=-12;
    const osc2 = actx.createOscillator(); osc2.type='sawtooth'; osc2.frequency.value=freq; osc2.detune.value=12;
    const sub = actx.createOscillator(); sub.type='sine'; sub.frequency.value=freq/2;

    const f = actx.createBiquadFilter(); f.type='lowpass';
    f.frequency.setValueAtTime(filterStart, t);
    f.frequency.exponentialRampToValueAtTime(filterEnd, t + dur);

    const g = actx.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.5, t+0.05);
    g.gain.setValueAtTime(0.5, t+dur-0.1);
    g.gain.linearRampToValueAtTime(0, t+dur);

    const sg = actx.createGain(); sg.gain.value=0.5;

    osc1.connect(f); osc2.connect(f); f.connect(g);
    sub.connect(sg); sg.connect(g);
    g.connect(master);

    osc1.start(t); osc1.stop(t+dur);
    osc2.start(t); osc2.stop(t+dur);
    sub.start(t); sub.stop(t+dur);
}

// 2. LIQUID PIANO
function playPiano(t, freq, vel) {
    const o1=actx.createOscillator(); o1.type='triangle'; o1.frequency.value=freq;
    const o2=actx.createOscillator(); o2.type='sine'; o2.frequency.value=freq;
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.01, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer=b;

    const f = actx.createBiquadFilter(); f.type='lowpass';
    f.frequency.setValueAtTime(800 + (vel*2000), t);
    f.frequency.exponentialRampToValueAtTime(400, t+1);

    const g = actx.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.3 * vel, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t+1.5);

    o1.connect(f); o2.connect(f); n.connect(f);
    f.connect(g); g.connect(master); g.connect(reverb.input);

    const del = actx.createDelay(); del.delayTime.value=0.25;
    const dg = actx.createGain(); dg.gain.value=0.2;
    g.connect(del); del.connect(dg); dg.connect(master);

    o1.start(t); o1.stop(t+2); o2.start(t); o2.stop(t+2); n.start(t);
}

// 3. VOCAL CHOP (Formant)
function playVox(t, freq, dur) {
    const o = actx.createOscillator(); o.type='sawtooth'; o.frequency.value=freq;
    const f1 = actx.createBiquadFilter(); f1.type='bandpass'; f1.frequency.value=600; f1.Q.value=2;
    const f2 = actx.createBiquadFilter(); f2.type='bandpass'; f2.frequency.value=1200; f2.Q.value=2;
    
    const g = actx.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.2, t+0.05);
    g.gain.linearRampToValueAtTime(0, t+dur);

    o.connect(f1); o.connect(f2);
    f1.connect(g); f2.connect(g);
    g.connect(master); g.connect(reverb.input);

    o.start(t); o.stop(t+dur);
}

// 4. DRUMS (Procedural Amen Break)
function playKick(t) {
    const o = actx.createOscillator(); o.frequency.setValueAtTime(120, t); o.frequency.exponentialRampToValueAtTime(40, t+0.1);
    const g = actx.createGain(); g.gain.setValueAtTime(1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
    const c = actx.createOscillator(); c.type='square'; 
    const cg = actx.createGain(); cg.gain.setValueAtTime(0.1, t); cg.gain.exponentialRampToValueAtTime(0.001, t+0.02);
    o.connect(g); g.connect(master); c.connect(cg); cg.connect(master);
    o.start(t); o.stop(t+0.2); c.start(t); c.stop(t+0.02);
    pulse=1;
}

function playSnare(t) {
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.15, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer=b;
    const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=400;
    const g = actx.createGain(); g.gain.setValueAtTime(0.6, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
    const o = actx.createOscillator(); o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(100, t+0.1);
    const og = actx.createGain(); og.gain.setValueAtTime(0.2, t); og.gain.exponentialRampToValueAtTime(0.001, t+0.1);
    n.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    o.connect(og); og.connect(master);
    n.start(t); o.start(t); o.stop(t+0.15);
}

function playHat(t, open) {
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.05, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer=b;
    const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=6000;
    const g = actx.createGain(); g.gain.setValueAtTime(open?0.2:0.05, t); g.gain.exponentialRampToValueAtTime(0.001, t+(open?0.1:0.03));
    n.connect(f); f.connect(g); g.connect(master);
    n.start(t);
}

function playSweep(t, dur, dir) {
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*dur, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer=b;
    const f = actx.createBiquadFilter(); f.type='bandpass'; f.Q.value=5;
    f.frequency.setValueAtTime(dir?200:5000, t);
    f.frequency.exponentialRampToValueAtTime(dir?5000:200, t+dur);
    const g = actx.createGain(); g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.2, t+dur*0.5);
    g.gain.linearRampToValueAtTime(0, t+dur);
    n.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    n.start(t);
}

// === 3. ARRANGEMENT ENGINE ===

let nextTime = 0;
let step = 0;
let bar = 0;

function scheduler() {
    while(nextTime < actx.currentTime + 0.1) {
        runStep(step, nextTime);
        nextTime += SIXTEENTH;
        step++;
    }
    setTimeout(scheduler, 25);
}

function runStep(s, t) {
    const stepInBar = s % 16;
    if(stepInBar === 0) bar++;
    
    // --- SONG STRUCTURE ---
    // INTRO: 0-16
    // BUILD 1: 16-32
    // DROP 1: 32-64
    // BREAKDOWN: 64-80
    // BUILD 2: 80-96
    // DROP 2: 96-128
    // OUTRO: 128-144

    let phase = "INTRO";
    if(bar >= 16) phase = "BUILD I";
    if(bar >= 32) phase = "DROP I";
    if(bar >= 64) phase = "BREAKDOWN";
    if(bar >= 80) phase = "BUILD II";
    if(bar >= 96) phase = "DROP II";
    if(bar >= 128) phase = "OUTRO";
    if(bar >= 144) { phase = "COMPLETE"; location.reload(); }

    if(stepInBar === 0) {
        document.getElementById('status-phase').innerText = `PHASE: ${phase} [${bar}]`;
        document.getElementById('status-time').innerText = new Date((t-startTime)*1000).toISOString().substr(14, 5);
        document.getElementById('progress-bar').style.width = (bar/144)*100 + "%";
        document.getElementById('dsp-load').innerText = Math.floor(Math.random()*20 + 10) + "%";
    }

    const chord = CHORDS[Math.floor((bar%16)/4)];
    const root = BASS[Math.floor((bar%16)/4)];

    // 1. DRUMS
    const playDrums = (phase === "DROP I" || phase === "DROP II" || (phase.includes("BUILD") && bar > 24));
    
    if (playDrums) {
        // Amen Break Logic
        if(stepInBar === 0) playKick(t);
        if(stepInBar === 4) playSnare(t);
        if(stepInBar === 10 && Math.random()>0.3) playKick(t); // Ghost
        if(stepInBar === 12) playSnare(t);
        // Shuffles
        if(stepInBar === 15 || (stepInBar === 7 && Math.random()>0.5)) playSnare(t);
    }
    
    // HiHats (Running)
    if ((phase.includes("DROP") || phase.includes("BUILD")) && s % 2 === 0) {
        playHat(t, stepInBar===4||stepInBar===12);
    }

    // Snare Rolls (Builds)
    if (phase.includes("BUILD")) {
        let interval = 4;
        if(bar % 16 > 12) interval = 2; // Last 4 bars of build
        if(bar % 16 > 14) interval = 1; // Last 2 bars
        if(s % interval === 0) playSnare(t);
        
        // Risers
        if(stepInBar === 0 && bar % 16 === 12) playSweep(t, BAR*4, true);
    }

    // 2. BASS
    if (phase === "INTRO" || phase === "BREAKDOWN") {
        if(stepInBar === 0 && bar % 4 === 0) playReese(t, root, BAR*4, 100, 200);
    }
    else if (phase.includes("DROP")) {
        // Aggressive Modulation
        if(stepInBar === 0) playReese(t, root, BAR, 100, 1500); // WOMP
        if(stepInBar === 11) playReese(t, root*1.5, SIXTEENTH*5, 800, 100);
    }

    // 3. MELODY & PIANO
    if (phase !== "BUILD I" && phase !== "BUILD II") {
        const mel = PIANO_MELODY.find(m => m.s === stepInBar);
        if(mel) playPiano(t, mel.n, 0.7 + Math.random()*0.3);
        
        // Chords on beat 1
        if(stepInBar === 0 && bar % 2 === 0) {
            playPiano(t, chord[0], 0.5);
            playPiano(t, chord[2], 0.5);
        }
    }

    // 4. VOCALS (The Soul)
    if (phase === "BREAKDOWN" || phase === "DROP II") {
        const vox = VOX_MELODY.find(v => v.s === stepInBar);
        if(vox && Math.random() > 0.3) {
            playVox(t, vox.n, SIXTEENTH * 2);
        }
    }
    
    // 5. CRASH
    if(stepInBar === 0 && (bar === 32 || bar === 96)) {
        playSweep(t, 4, false); // Downlifter
    }
}

// === 4. VISUAL ENGINE ===

let pulse = 0;
let stars = [];

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
    stars = Array(800).fill().map(() => ({
        x: Math.random() * w - w/2,
        y: Math.random() * h - h/2,
        z: Math.random() * 2000,
        sz: Math.random() * 2
    }));
}

function draw() {
    requestAnimationFrame(draw);
    ctx.fillStyle = 'rgba(5, 10, 16, 0.4)'; // Trail
    ctx.fillRect(0,0,w,h);
    
    pulse *= 0.9;
    const cx = w/2; 
    const cy = h/2;
    
    // Speed Logic
    let speed = 5;
    const phase = document.getElementById('status-phase').innerText;
    if(phase.includes("BUILD")) speed = 20 + (pulse*20);
    if(phase.includes("DROP")) speed = 60 + (pulse*100);
    
    // Stars
    ctx.fillStyle = '#fff';
    stars.forEach(s => {
        s.z -= speed;
        if(s.z <= 0) {
            s.z = 2000;
            s.x = Math.random() * w - w/2;
            s.y = Math.random() * h - h/2;
        }
        
        const scale = 300 / s.z;
        const x2d = cx + s.x * scale;
        const y2d = cy + s.y * scale;
        const size = s.sz * scale;
        
        // Render
        const alpha = Math.min(1, (2000 - s.z) / 1000);
        ctx.globalAlpha = alpha;
        
        if (phase.includes("DROP")) {
            // Warp lines
            ctx.beginPath();
            ctx.strokeStyle = `rgba(0, 243, 255, ${alpha})`;
            ctx.lineWidth = size;
            ctx.moveTo(x2d, y2d);
            ctx.lineTo(cx + s.x * (300/(s.z+100)), cy + s.y * (300/(s.z+100)));
            ctx.stroke();
        } else {
            // Dots
            ctx.beginPath();
            ctx.arc(x2d, y2d, size, 0, Math.PI*2);
            ctx.fill();
        }
    });
    ctx.globalAlpha = 1;

    // Analyzer HUD
    if(analyser) {
        const data = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(data);
        const bass = data[5];
        
        const r = 100 + (bass * 0.5) + (pulse*20);
        
        ctx.strokeStyle = `hsl(180, 100%, ${50 + pulse*50}%)`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.stroke();
        
        // Inner spin
        const time = Date.now() / 1000;
        ctx.beginPath();
        ctx.arc(cx, cy, r * 0.8, time, time + Math.PI);
        ctx.strokeStyle = `rgba(255, 255, 255, 0.5)`;
        ctx.stroke();
    }
}

window.onresize = initVis;
initVis();

document.getElementById('init').addEventListener('click', async (e) => {
    e.target.innerText = "SEQUENCE INITIATED";
    document.getElementById('center-overlay').style.opacity = 0;
    setTimeout(() => document.getElementById('center-overlay').style.display='none', 1000);
    
    await initAudio();
    startTime = actx.currentTime + 0.1;
    nextTime = startTime;
    isPlaying = true;
    scheduler();
    draw();
});

</script>
</body>
</html>

PROGRAM 10
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GOLDEN HOUR // AURAL TAPESTRY</title>
    <style>
        body { 
            margin: 0; background: #000; overflow: hidden; 
            font-family: 'Georgia', serif; color: #d4af37;
            display: flex; justify-content: center; align-items: center; height: 100vh;
            cursor: pointer;
        }
        canvas { position: absolute; top: 0; left: 0; z-index: 1; transition: opacity 2s; }
        #ui {
            z-index: 10; text-align: center; opacity: 0.8; transition: opacity 1.5s;
            mix-blend-mode: screen;
        }
        h1 { 
            font-size: 2rem; letter-spacing: 0.5rem; font-weight: normal; 
            margin-bottom: 1rem; color: #f3e5ab; 
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }
        p { font-style: italic; font-size: 0.9rem; color: #8b7d6b; letter-spacing: 0.1rem; }
        .fade-out { opacity: 0 !important; pointer-events: none; }
    </style>
</head>
<body>

<div id="ui">
    <h1>GOLDEN HOUR</h1>
    <p>Click to breathe.</p>
</div>
<canvas id="c"></canvas>

<script>
/**
 * PROJECT: GOLDEN HOUR
 * COMPOSITION: Db Major (Romantic/Cinematic)
 * ENGINE: Physical Modeling Piano + Orchestral Swells
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

let actx, master, reverb, compressor;
let isPlaying = false;
let startTime = 0;

// --- HARMONY & THEORY (Db Major) ---
// Db, Eb, F, Gb, Ab, Bb, C
const N = {
    Db2: 69.30, F2: 87.31, Gb2: 92.50, Ab2: 103.83, Bb2: 116.54,
    Db3: 138.59, Eb3: 155.56, F3: 174.61, Gb3: 185.00, Ab3: 207.65, Bb3: 233.08, C3: 261.63,
    Db4: 277.18, Eb4: 311.13, F4: 349.23, Gb4: 369.99, Ab4: 415.30, Bb4: 466.16, C4: 523.25,
    Db5: 554.37, F5: 698.46, Ab5: 830.61
};

// COMPOSITION TIMELINE (Not a loop, a narrative)
// Each event: { t: time_in_seconds, type: 'piano'|'pad', note: freq, dur: duration }
const SCORE = [
    // --- INTRO (The Solitary Piano) ---
    {t:0.0, type:'piano', n:[N.Db3, N.F3, N.Ab3], d:4}, // I
    {t:0.0, type:'bass', n:N.Db2, d:8},
    
    {t:4.0, type:'piano', n:[N.Bb3, N.Db4, N.F4], d:4}, // vi
    {t:4.0, type:'bass', n:N.Bb2, d:8},

    {t:8.0, type:'piano', n:[N.Gb3, N.Bb3, N.Db4], d:4}, // IV
    {t:8.0, type:'bass', n:N.Gb2, d:8},

    {t:12.0, type:'piano', n:[N.Ab3, N.C4, N.Eb4], d:4}, // V
    {t:12.0, type:'bass', n:N.Ab2, d:8},

    // --- SECTION A (The Melody Enters) ---
    {t:16.0, type:'pad', n:[N.Db3, N.F3, N.Ab3, N.C4], d:16}, // Pad swells in
    {t:16.0, type:'piano', n:N.Db2, d:2}, // Root
    {t:16.5, type:'piano', n:N.Ab3, d:2}, 
    {t:17.0, type:'piano', n:N.Db4, d:1},
    {t:18.0, type:'piano', n:N.F4, d:2}, // Melody starts

    {t:20.0, type:'piano', n:N.Eb4, d:1},
    {t:21.0, type:'piano', n:N.Db4, d:1},
    {t:22.0, type:'piano', n:N.Ab3, d:2},
    {t:23.0, type:'piano', n:N.F3, d:2},

    // --- SECTION B (The Swell) ---
    {t:32.0, type:'pad', n:[N.Gb3, N.Bb3, N.Db4, N.F4], d:8}, // Change chord
    {t:32.0, type:'bass', n:N.Gb2, d:8},
    
    // Arpeggios (Raindrops)
    {t:32.0, type:'arp', n:N.F4, d:0.5}, {t:32.25, type:'arp', n:N.Ab4, d:0.5}, {t:32.5, type:'arp', n:N.Db5, d:0.5},
    {t:33.0, type:'arp', n:N.F4, d:0.5}, {t:33.25, type:'arp', n:N.Ab4, d:0.5}, {t:33.5, type:'arp', n:N.Db5, d:0.5},
    
    {t:36.0, type:'piano', n:[N.Ab2, N.Eb3], d:4}, // Low movement
    
    // --- SECTION C (Resolution) ---
    {t:48.0, type:'pad', n:[N.Db3, N.F3, N.Ab3], d:12}, // Home
    {t:48.0, type:'piano', n:N.Db2, d:8},
    {t:50.0, type:'piano', n:N.Ab4, d:4}, // High lingering note
    {t:54.0, type:'piano', n:N.F4, d:4},
    {t:58.0, type:'piano', n:N.Db4, d:6},
];

// --- AUDIO ENGINE ---

async function initAudio() {
    actx = new AC();
    await actx.resume();

    master = actx.createGain();
    master.gain.value = 0.6;

    // Soft Limiter for smoothness
    compressor = actx.createDynamicsCompressor();
    compressor.threshold.value = -20;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.05;
    compressor.release.value = 1.0;

    // The "Cathedral" Reverb
    reverb = await createReverb();

    master.connect(compressor);
    compressor.connect(actx.destination);
    reverb.output.connect(master);
}

async function createReverb() {
    // Generate a very smooth, long impulse response
    const seconds = 5;
    const len = actx.sampleRate * seconds;
    const buff = actx.createBuffer(2, len, actx.sampleRate);
    
    for(let c=0; c<2; c++) {
        const d = buff.getChannelData(c);
        for(let i=0; i<len; i++) {
            // Exponential decay noise
            const t = i / len;
            const noise = (Math.random() * 2 - 1);
            // Smooth fade out curve
            d[i] = noise * Math.pow(1 - t, 4) * 0.8;
        }
    }
    
    const conv = actx.createConvolver();
    conv.buffer = buff;
    
    const inp = actx.createGain();
    const out = actx.createGain();
    out.gain.value = 0.5; // Very wet mix
    
    inp.connect(conv);
    conv.connect(out);
    
    return { input: inp, output: out };
}

// 1. PHYSICAL PIANO MODEL
// Combines Sine (Fundamental), Triangle (Body), and Noise (Hammer Attack)
function playPiano(note, start, duration) {
    const t = start;
    const freq = Array.isArray(note) ? note : [note]; // Handle chords
    
    freq.forEach((f, i) => {
        const stagger = i * 0.02; // Strum chords slightly
        const noteTime = t + stagger;

        // A. FUNDAMENTAL
        const osc = actx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = f;
        
        // B. HARMONICS (The Wire)
        const harm = actx.createOscillator();
        harm.type = 'triangle';
        harm.frequency.value = f;
        
        // C. HAMMER (The Click)
        const hammer = actx.createBufferSource();
        const hBuf = actx.createBuffer(1, actx.sampleRate*0.01, actx.sampleRate);
        const hData = hBuf.getChannelData(0);
        for(let j=0; j<hData.length; j++) hData[j] = Math.random()*2-1;
        hammer.buffer = hBuf;
        
        // FILTER (Damping simulation)
        const filter = actx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(0, noteTime);
        filter.frequency.linearRampToValueAtTime(f * 8, noteTime + 0.05); // Attack
        filter.frequency.exponentialRampToValueAtTime(f, noteTime + duration); // Decay
        
        // GAIN ENVELOPE
        const gain = actx.createGain();
        gain.gain.setValueAtTime(0, noteTime);
        gain.gain.linearRampToValueAtTime(0.4, noteTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, noteTime + duration + 1);

        // HAMMER GAIN
        const hGain = actx.createGain();
        hGain.gain.value = 0.05;
        
        // Routing
        osc.connect(filter);
        harm.connect(filter);
        hammer.connect(hGain); hGain.connect(master); // Hammer bypasses filter/reverb for clarity
        
        filter.connect(gain);
        gain.connect(master);
        gain.connect(reverb.input);
        
        osc.start(noteTime); osc.stop(noteTime + duration + 1);
        harm.start(noteTime); harm.stop(noteTime + duration + 1);
        hammer.start(noteTime);

        // Trigger Visual
        setTimeout(() => spawnRipple(f), (noteTime - actx.currentTime) * 1000);
    });
}

// 2. ORCHESTRAL SWELL (Pads)
function playPad(notes, start, duration) {
    const t = start;
    const gain = actx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.15, t + duration * 0.3); // Slow swell
    gain.gain.linearRampToValueAtTime(0, t + duration);

    const filter = actx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 400; // Warm and dark

    // LFO for movement
    const lfo = actx.createOscillator();
    lfo.frequency.value = 0.2;
    const lfoG = actx.createGain();
    lfoG.gain.value = 100;
    lfo.connect(lfoG);
    lfoG.connect(filter.frequency);
    lfo.start(t);

    notes.forEach((f, i) => {
        // Use multiple oscillators for "Ensemble" effect
        const o1 = actx.createOscillator(); o1.type = 'sawtooth'; o1.frequency.value = f; o1.detune.value = -10;
        const o2 = actx.createOscillator(); o2.type = 'sawtooth'; o2.frequency.value = f; o2.detune.value = 10;
        
        o1.connect(filter);
        o2.connect(filter);
        o1.start(t); o1.stop(t + duration);
        o2.start(t); o2.stop(t + duration);
    });

    filter.connect(gain);
    gain.connect(master);
    gain.connect(reverb.input);
}

// 3. SUB BASS (Grounding)
function playBass(note, start, duration) {
    const osc = actx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = note;
    
    const gain = actx.createGain();
    gain.gain.setValueAtTime(0, start);
    gain.gain.linearRampToValueAtTime(0.4, start + 1);
    gain.gain.linearRampToValueAtTime(0, start + duration);
    
    osc.connect(gain);
    gain.connect(master);
    
    osc.start(start);
    osc.stop(start + duration);
}

// 4. ARPEGGIOS (Sparkles)
function playArp(note, start, duration) {
    const osc = actx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = note;
    
    const gain = actx.createGain();
    gain.gain.setValueAtTime(0, start);
    gain.gain.linearRampToValueAtTime(0.1, start + 0.1);
    gain.gain.exponentialRampToValueAtTime(0.001, start + duration);
    
    const pan = actx.createStereoPanner();
    pan.pan.value = Math.sin(start); // Pan back and forth

    osc.connect(gain);
    gain.connect(pan);
    pan.connect(master);
    pan.connect(reverb.input);
    
    osc.start(start); osc.stop(start + duration);
}

// --- SEQUENCER ---
function startSequence() {
    const now = actx.currentTime + 0.5; // Slight buffer
    
    SCORE.forEach(evt => {
        if(evt.type === 'piano') playPiano(evt.n, now + evt.t, evt.d);
        if(evt.type === 'pad') playPad(evt.n, now + evt.t, evt.d);
        if(evt.type === 'bass') playBass(evt.n, now + evt.t, evt.d);
        if(evt.type === 'arp') playArp(evt.n, now + evt.t, evt.d);
    });

    // Auto-loop / End handling
    setTimeout(() => {
        document.getElementById('ui').style.opacity = 1;
        document.querySelector('h1').innerText = "FIN";
        isPlaying = false;
    }, 65000);
}

// --- VISUALS ---

let ripples = [];
let time = 0;

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}

function spawnRipple(freq) {
    // Map frequency to position
    // Low notes = Bottom, High notes = Top
    // But create some random jitter
    const y = h - ((freq / 800) * h); 
    const x = Math.random() * w;
    
    ripples.push({
        x: x,
        y: y,
        r: 0,
        maxR: 100 + (Math.random() * 200),
        alpha: 1,
        hue: 45 + (Math.random() * 10) // Gold spectrum
    });
}

function draw() {
    requestAnimationFrame(draw);
    time += 0.005;

    // Background: Deep Sunset Gradient
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, '#0f0c29');
    grad.addColorStop(0.5, '#302b63');
    grad.addColorStop(1, '#24243e');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);

    // Dust motes
    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
    for(let i=0; i<50; i++) {
        const mx = (Math.sin(time + i) * w/2) + w/2;
        const my = (Math.cos(time + (i*0.5)) * h/2) + h/2;
        ctx.beginPath();
        ctx.arc(mx, my, Math.random()*2, 0, Math.PI*2);
        ctx.fill();
    }

    // Ripples (Piano interactions)
    for(let i=ripples.length-1; i>=0; i--) {
        let r = ripples[i];
        r.r += 0.5; // Slow expansion
        r.alpha -= 0.005; // Slow fade
        
        if(r.alpha <= 0) {
            ripples.splice(i, 1);
            continue;
        }

        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
        ctx.strokeStyle = `hsla(${r.hue}, 80%, 60%, ${r.alpha})`;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Reflection
        ctx.beginPath();
        ctx.arc(r.x, r.y + 10, r.r * 0.5, 0, Math.PI*2);
        ctx.strokeStyle = `hsla(${r.hue}, 80%, 80%, ${r.alpha * 0.3})`;
        ctx.stroke();
    }

    // Horizon Line
    ctx.beginPath();
    ctx.moveTo(0, h * 0.8);
    ctx.lineTo(w, h * 0.8);
    ctx.strokeStyle = 'rgba(212, 175, 55, 0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
}

window.onresize = initVis;
initVis();
draw(); // Start visual loop immediately

document.body.addEventListener('click', async () => {
    if(isPlaying) return;
    
    document.getElementById('ui').classList.add('fade-out');
    
    await initAudio();
    isPlaying = true;
    startSequence();
});

</script>
</body>
</html>

PROGRAM 11
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DELILAH // LINEAR TAPE ENGINE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Inter:wght@300;600&display=swap');

        body {
            margin: 0;
            background-color: #080808;
            color: #e0e0e0;
            font-family: 'Inter', sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        /* VISUALIZER CANVAS */
        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            opacity: 0.7;
        }

        /* UI LAYER */
        #ui-layer {
            position: relative;
            z-index: 10;
            text-align: center;
            width: 90%;
            max-width: 900px;
            background: rgba(10, 10, 10, 0.8);
            padding: 40px;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'Courier Prime', monospace;
            font-size: 1rem;
            letter-spacing: 4px;
            color: #d4af37; /* Gold */
            margin-bottom: 30px;
            text-transform: uppercase;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        #lyric-display {
            font-size: 2rem;
            font-weight: 600;
            min-height: 3.5rem;
            color: #fff;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
            margin-bottom: 20px;
            transition: transform 0.1s;
        }

        #tab-display {
            font-family: 'Courier Prime', monospace;
            font-size: 14px;
            color: #00ffcc; /* Cyber Blue */
            margin-bottom: 30px;
        }

        #progress-bar {
            width: 100%;
            height: 4px;
            background: #222;
            margin-bottom: 30px;
            position: relative;
        }
        #progress-fill {
            height: 100%;
            width: 0%;
            background: #d4af37;
            box-shadow: 0 0 10px #d4af37;
            transition: width 0.1s linear;
        }

        button {
            background: transparent;
            border: 2px solid #d4af37;
            color: #d4af37;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-weight: bold;
            font-family: 'Courier Prime', monospace;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        button:hover {
            background: #d4af37;
            color: #000;
            box-shadow: 0 0 30px #d4af37;
        }
        
        button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            box-shadow: none;
        }

        .bump { transform: scale(1.05); color: #ffffaa !important; }
    </style>
</head>
<body>

    <canvas id="visuals"></canvas>

    <div id="ui-layer">
        <h1>SEQUENCER: HEY THERE DELILAH</h1>
        
        <div id="lyric-display">...</div>
        
        <div id="tab-display">
            CHORD: <span id="chord-name">--</span> | STEP: <span id="step-count">0</span>
        </div>

        <div id="progress-bar"><div id="progress-fill"></div></div>

        <button id="btn-play" onclick="Engine.start()">PLAY TRACK</button>
    </div>

    <script>
        // ======================================================
        // 1. AUDIO CORE (Physical Modeling)
        // ======================================================
        const AudioCore = {
            ctx: null,
            master: null,
            reverb: null,

            init() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.4;

                // Convolution Reverb (The "Room")
                this.reverb = this.ctx.createConvolver();
                this.reverb.buffer = this.createImpulse(2.0, 2.5); // 2s duration

                // Signal Chain: Master -> Reverb -> Out & Master -> Out (Dry)
                this.master.connect(this.reverb);
                this.reverb.connect(this.ctx.destination);
                this.master.connect(this.ctx.destination);

                return this.ctx.resume();
            },

            createImpulse(duration, decay) {
                const rate = this.ctx.sampleRate;
                const len = rate * duration;
                const buffer = this.ctx.createBuffer(2, len, rate);
                for (let c = 0; c < 2; c++) {
                    const d = buffer.getChannelData(c);
                    for (let i = 0; i < len; i++) {
                        d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, decay);
                    }
                }
                return buffer;
            },

            // The String Sound
            playString(freq, time, velocity = 1.0, isThumb = false) {
                const t = time;
                const osc = this.ctx.createOscillator();
                const filter = this.ctx.createBiquadFilter();
                const gain = this.ctx.createGain();

                // Physics: 
                // Thumb = Triangle wave (dull), Finger = Sawtooth (bright)
                osc.type = isThumb ? 'triangle' : 'sawtooth';
                osc.frequency.value = freq;

                // Filter Pluck
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(isThumb ? 600 : 3000, t);
                filter.frequency.exponentialRampToValueAtTime(100, t + 0.3); // Damping

                // Amp Envelope
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(velocity, t + 0.005); // Attack
                gain.gain.exponentialRampToValueAtTime(0.001, t + 2.5); // Release

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.master);

                osc.start(t);
                osc.stop(t + 3.0);
            }
        };

        // ======================================================
        // 2. MUSIC THEORY & TAB DATA
        // ======================================================
        // Standard Tuning: E2 A2 D3 G3 B3 E4
        const STRINGS_HZ = [82.41, 110.00, 146.83, 196.00, 246.94, 329.63];

        function getFreq(stringIdx, fret) {
            return STRINGS_HZ[stringIdx] * Math.pow(2, fret / 12);
        }

        // TAB DEFINITIONS
        // Pattern: Bass (Thumb) on beat, Treble (Index) on off-beat
        const SHAPES = {
            'D': { 
                bass: {s: 2, f: 0}, // D string Open
                treble: [{s: 3, f: 2}, {s: 4, f: 3}] // G2, B3
            },
            'F#m': { 
                bass: {s: 2, f: 4}, // D string 4th fret
                treble: [{s: 3, f: 2}, {s: 4, f: 2}] // G2, B2
            },
            'Bm': { 
                bass: {s: 1, f: 2}, // A string 2nd fret
                treble: [{s: 3, f: 4}, {s: 4, f: 3}] // G4, B3
            },
            'G': { 
                bass: {s: 0, f: 3}, // Low E 3rd fret
                treble: [{s: 3, f: 0}, {s: 4, f: 3}] // G0, B3
            },
            'A': { 
                bass: {s: 1, f: 0}, // A string Open
                treble: [{s: 3, f: 2}, {s: 4, f: 2}] // G2, B2
            },
            // Special variation for the walkdown
            'A_Fill': {
                bass: {s: 1, f: 0},
                treble: [{s: 4, f: 2}, {s: 4, f: 0}] // B string 2 then 0
            }
        };

        // ======================================================
        // 3. LINEAR TAPE COMPILER
        // ======================================================
        const BPM = 116;
        const SPB = 60 / BPM; // Seconds per beat
        const EIGHTH = SPB / 2; 

        const Engine = {
            tape: [], // The full list of events { time, type, data }
            startTime: 0,
            cursor: 0,
            isPlaying: false,

            compile() {
                this.tape = [];
                let t = 0.0; // Relative time counter

                const addBar = (chordName, count=1) => {
                    for (let b = 0; b < count; b++) {
                        const s = SHAPES[chordName];
                        // 4 Beats per bar
                        for (let i = 0; i < 4; i++) {
                            // Downbeat (Bass)
                            this.tape.push({ 
                                time: t, type: 'NOTE', 
                                chord: chordName, 
                                s: s.bass.s, f: s.bass.f, thumb: true 
                            });
                            
                            // Upbeat (Treble)
                            s.treble.forEach((n, idx) => {
                                this.tape.push({ 
                                    time: t + EIGHTH + (idx*0.02), // Slight strum stagger
                                    type: 'NOTE', 
                                    chord: chordName, 
                                    s: n.s, f: n.f, thumb: false 
                                });
                            });
                            t += SPB;
                        }
                    }
                };

                const addHalfBar = (chordName) => {
                    const s = SHAPES[chordName];
                    for (let i = 0; i < 2; i++) { // 2 Beats
                        this.tape.push({ time: t, type: 'NOTE', chord: chordName, s: s.bass.s, f: s.bass.f, thumb: true });
                        s.treble.forEach((n, idx) => {
                            this.tape.push({ time: t + EIGHTH + (idx*0.02), type: 'NOTE', chord: chordName, s: n.s, f: n.f, thumb: false });
                        });
                        t += SPB;
                    }
                }

                const addLyric = (text) => {
                    this.tape.push({ time: t, type: 'LYRIC', text: text });
                };

                // --- SONG STRUCTURE ---
                
                // INTRO
                addBar('D'); addBar('F#m'); addBar('D'); addBar('F#m');

                // VERSE 1
                addLyric("Hey there, Delilah\nWhat's it like in New York City?");
                addBar('D'); addBar('F#m');
                
                addLyric("I'm a thousand miles away\nBut girl, tonight you look so pretty");
                addBar('D'); addBar('F#m');
                
                addLyric("Yes you do");
                addBar('D'); addBar('F#m'); // Tab shows extended Bm here usually but sticking to your requested chart of D/F#m
                
                // PRE-CHORUS
                addLyric("Times Square can't shine as bright as you");
                addBar('Bm'); 
                addHalfBar('G'); addHalfBar('A'); // Split bar
                
                addLyric("I swear it's true");
                addBar('Bm'); addBar('A');

                // VERSE 2
                addLyric("Hey there, Delilah\nDon't you worry about the distance");
                addBar('D'); addBar('F#m');
                
                addLyric("I'm right there if you get lonely\nGive this song another listen");
                addBar('D'); addBar('F#m');
                
                addLyric("Close your eyes");
                addBar('D'); addBar('F#m');

                // PRE-CHORUS 2
                addLyric("Listen to my voice, it's my disguise");
                addBar('Bm'); addHalfBar('G'); addHalfBar('A');
                
                addLyric("I'm by your side");
                addBar('Bm'); addBar('A');

                // CHORUS
                addLyric("Oh, it's what you do to me");
                addBar('D'); addBar('Bm');
                addLyric("Oh, it's what you do to me");
                addBar('D'); addBar('Bm');
                addLyric("Oh, it's what you do to me");
                addBar('D'); addBar('Bm');
                addLyric("Oh, it's what you do to me");
                addBar('D'); addBar('Bm');
                addLyric("What you do to me");
                addBar('D');

                // BRIDGE
                addLyric("A thousand miles seems pretty far");
                addBar('G');
                addLyric("But they've got planes and trains and cars");
                addBar('A');
                addLyric("I'd walk to you if I had no other way");
                addBar('D'); addBar('Bm');
                addLyric("Our friends would all make fun of us");
                addBar('G');
                addLyric("And we'll just laugh along because we know");
                addBar('A');
                addLyric("That none of them have felt this way");
                addBar('D'); addBar('Bm');
                addLyric("Delilah I can promise you");
                addBar('G');
                addLyric("That by the time we get through");
                addBar('A');
                addLyric("The world will never ever be the same");
                addBar('Bm');
                addLyric("And you're to blame");
                addBar('A'); addBar('A');

                // END
                addLyric("Hey there, Delilah... here's to you.");
                addBar('D');
                addLyric("");
                
                this.totalDuration = t;
            },

            start() {
                const btn = document.getElementById('btn-play');
                btn.disabled = true;
                btn.innerText = "PLAYING...";

                AudioCore.init().then(() => {
                    this.compile();
                    this.startTime = AudioCore.ctx.currentTime + 0.2; // Small buffer
                    this.cursor = 0;
                    this.isPlaying = true;
                    this.tick();
                });
            },

            tick() {
                if (!this.isPlaying) return;

                const now = AudioCore.ctx.currentTime;
                const lookahead = 0.1; // Schedule 100ms ahead

                // Process events
                while (this.cursor < this.tape.length) {
                    const ev = this.tape[this.cursor];
                    const evTime = this.startTime + ev.time;

                    if (evTime <= now + lookahead) {
                        // EXECUTE EVENT
                        if (ev.type === 'NOTE') {
                            const freq = getFreq(ev.s, ev.f);
                            // Schedule audio
                            AudioCore.playString(freq, evTime, 1.0, ev.thumb);
                            // Schedule UI update (approx)
                            setTimeout(() => {
                                document.getElementById('chord-name').innerText = ev.chord;
                                Visuals.pluck(ev.s);
                            }, (evTime - now) * 1000);
                        } 
                        else if (ev.type === 'LYRIC') {
                            setTimeout(() => {
                                const l = document.getElementById('lyric-display');
                                l.innerText = ev.text;
                                l.classList.remove('bump');
                                void l.offsetWidth;
                                l.classList.add('bump');
                            }, (evTime - now) * 1000);
                        }
                        this.cursor++;
                    } else {
                        break; // Next event is too far in future
                    }
                }

                // Progress Bar
                const pct = ((now - this.startTime) / this.totalDuration) * 100;
                document.getElementById('progress-fill').style.width = Math.min(pct, 100) + '%';

                if (this.cursor >= this.tape.length && (now > this.startTime + this.totalDuration + 2)) {
                    this.isPlaying = false;
                    document.getElementById('btn-play').disabled = false;
                    document.getElementById('btn-play').innerText = "REPLAY";
                } else {
                    requestAnimationFrame(this.tick.bind(this));
                }
            }
        };

        // ======================================================
        // 4. VISUALS
        // ======================================================
        const Visuals = {
            cvs: document.getElementById('visuals'),
            ctx: document.getElementById('visuals').getContext('2d'),
            strings: [0,0,0,0,0,0], // Amp of 6 strings

            init() {
                this.resize();
                window.onresize = () => this.resize();
                this.loop();
            },

            resize() {
                this.cvs.width = window.innerWidth;
                this.cvs.height = window.innerHeight;
            },

            pluck(idx) {
                // Invert index for visual layout (Low string at bottom, high at top)
                // Standard Tab: E A D G B e (0 1 2 3 4 5)
                // Visual: 0 at bottom, 5 at top
                this.strings[idx] = 30;
            },

            loop() {
                const w = this.cvs.width;
                const h = this.cvs.height;
                const ctx = this.ctx;

                ctx.clearRect(0, 0, w, h);

                const spacing = h / 8;
                const startY = h - spacing * 1.5; // Bottom up

                for (let i = 0; i < 6; i++) {
                    const y = startY - (i * spacing);
                    const amp = this.strings[i];

                    ctx.beginPath();
                    ctx.moveTo(0, y);

                    // String Color
                    ctx.strokeStyle = i < 3 ? '#d49060' : '#e0e0e0'; // Bronze vs Steel
                    ctx.lineWidth = 2 + (i < 3 ? 2 : 0); // Bass strings thicker

                    if (amp > 0.5) {
                        // Vibrating
                        for (let x = 0; x < w; x += 20) {
                            const vib = Math.sin(x * 0.05 + Date.now() * 0.2) * amp * Math.sin(x/w * Math.PI);
                            ctx.lineTo(x, y + vib);
                        }
                        this.strings[i] *= 0.92; // Decay
                    } else {
                        ctx.lineTo(w, y);
                    }
                    ctx.stroke();
                }
                requestAnimationFrame(this.loop.bind(this));
            }
        };
        Visuals.init();

    </script>
</body>
</html>

PROGRAM 12
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PRISM // PHASE ENGINE</title>
<style>
    body {
        margin: 0; background: #050505; overflow: hidden;
        display: flex; justify-content: center; align-items: center; height: 100vh;
        font-family: 'Courier New', monospace; color: #fff;
    }
    canvas { position: absolute; z-index: 1; }
    #ui {
        position: absolute; z-index: 10; text-align: center;
        background: rgba(0,0,0,0.8); padding: 40px; border: 1px solid #fff;
        transition: opacity 0.5s;
    }
    h1 { font-weight: normal; letter-spacing: 5px; margin-bottom: 20px; font-size: 24px; }
    button {
        background: #fff; color: #000; border: none; padding: 15px 40px;
        font-family: inherit; font-weight: bold; cursor: pointer; letter-spacing: 2px;
    }
    button:hover { background: #ccc; }
</style>
</head>
<body>

<div id="ui">
    <h1>PRISM // PHASE</h1>
    <button id="btn">INITIALIZE</button>
</div>
<canvas id="c"></canvas>

<script>
/**
 * PRISM
 * Concept: Polyrhythmic Phasing (Steve Reich Style)
 * Audio: FM Synthesis (Glass/Bell tones)
 */

const ctx = document.getElementById('c').getContext('2d');
let w, h;
let ac, master, reverb;
let isRunning = false;

// SCALE: C Lydian (Dreamy, Bright)
// C4, D4, E4, F#4, G4, A4, B4, C5
const NOTES = [261.63, 293.66, 329.63, 369.99, 392.00, 440.00, 493.88, 523.25];

// PHYSICS CONFIG
// Each orbiter has a slightly different speed, creating the phase effect.
const ORBITERS = [
    { r: 50,  speed: 2.00, note: 7, color: '#fff' },
    { r: 90,  speed: 2.02, note: 6, color: '#eee' }, // Slightly slower
    { r: 130, speed: 2.04, note: 4, color: '#ddd' },
    { r: 170, speed: 2.06, note: 2, color: '#ccc' },
    { r: 210, speed: 2.08, note: 1, color: '#bbb' },
    { r: 250, speed: 2.10, note: 0, color: '#aaa' }  // Slowest
];

// STATE
let orbitersState = ORBITERS.map(o => ({ ...o, angle: -Math.PI/2 })); // Start at top
let lastTime = 0;

// ================= AUDIO ENGINE ================= //

async function initAudio() {
    const AC = window.AudioContext || window.webkitAudioContext;
    ac = new AC();
    await ac.resume();

    master = ac.createGain();
    master.gain.value = 0.4;

    // Simple Stereo Delay (Fake Reverb)
    const delay = ac.createDelay();
    delay.delayTime.value = 0.25;
    const feedback = ac.createGain();
    feedback.gain.value = 0.3;
    
    delay.connect(feedback).connect(delay);
    master.connect(ac.destination);
    master.connect(delay).connect(ac.destination);
}

function playBell(freq, vel) {
    const t = ac.currentTime;
    
    // FM Synthesis for Glassy Tone
    // Carrier (The Tone)
    const car = ac.createOscillator();
    car.type = 'sine';
    car.frequency.value = freq;

    // Modulator (The "Ding" texture)
    const mod = ac.createOscillator();
    mod.type = 'sine';
    mod.frequency.value = freq * 2.0; // 2:1 Ratio = Harmonic
    
    const modGain = ac.createGain();
    modGain.gain.setValueAtTime(freq * 2, t);
    modGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2); // Sharp attack

    // Envelope
    const env = ac.createGain();
    env.gain.setValueAtTime(0, t);
    env.gain.linearRampToValueAtTime(vel, t + 0.01);
    env.gain.exponentialRampToValueAtTime(0.001, t + 3.0); // Long tail

    mod.connect(modGain).connect(car.frequency);
    car.connect(env).connect(master);

    car.start(t);
    car.stop(t + 3.0);
    mod.start(t);
    mod.stop(t + 3.0);
}

// ================= LOGIC & VISUALS ================= //

function initVis() {
    w = document.getElementById('c').width = window.innerWidth;
    h = document.getElementById('c').height = window.innerHeight;
}
window.onresize = initVis;

function loop(timestamp) {
    if (!isRunning) return;
    requestAnimationFrame(loop);

    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    
    // Clear
    ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; // Trail effect
    ctx.fillRect(0, 0, w, h);
    
    const cx = w/2;
    const cy = h/2;

    // Trigger Line
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx, cy - 300);
    ctx.strokeStyle = '#333';
    ctx.stroke();

    // Update & Draw Orbiters
    orbitersState.forEach(o => {
        // Update Angle
        const prevAngle = o.angle;
        // Speed is radians per second
        o.angle += o.speed * dt;

        // Check Trigger (Crossing -PI/2, which is top vertical)
        // We normalize angles to 0-2PI for logic usually, but here simple crossing check:
        // If we crossed the "top" (modulo 2PI)
        const crossed = Math.floor((prevAngle + Math.PI/2) / (Math.PI*2)) !== Math.floor((o.angle + Math.PI/2) / (Math.PI*2));

        if (crossed) {
            playBell(NOTES[o.note], 0.6);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, w, h); // Flash screen slightly
        }

        // Draw Orbit Path
        ctx.beginPath();
        ctx.arc(cx, cy, o.r, 0, Math.PI*2);
        ctx.strokeStyle = '#222';
        ctx.stroke();

        // Draw Planet
        const x = cx + Math.cos(o.angle) * o.r;
        const y = cy + Math.sin(o.angle) * o.r;

        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI*2);
        ctx.fillStyle = crossed ? '#fff' : o.color;
        ctx.fill();
        
        // Draw Connection to center
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(x, y);
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.stroke();
    });
}

document.getElementById('btn').addEventListener('click', async () => {
    document.getElementById('ui').style.opacity = 0;
    document.getElementById('ui').style.pointerEvents = 'none';
    
    initVis();
    await initAudio();
    isRunning = true;
    lastTime = performance.now();
    loop(lastTime);
});

</script>
</body>
</html>

PROGRAM 13
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE ETERNAL HORIZON // MAGNUM OPUS</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@100;900&display=swap');

        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            height: 100vh;
            cursor: none;
            font-family: 'Montserrat', sans-serif;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            filter: contrast(1.2) brightness(1.1);
        }

        #ui-layer {
            position: absolute;
            z-index: 10;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, rgba(0,0,0,0.6) 0%, #000 100%);
            transition: opacity 2s ease-in-out;
        }

        h1 {
            font-size: 6vw;
            font-weight: 900;
            letter-spacing: -5px;
            color: transparent;
            background: linear-gradient(to right, #fff, #00f2ff, #ff00aa);
            -webkit-background-clip: text;
            margin: 0;
            text-shadow: 0 0 50px rgba(255,255,255,0.5);
        }

        p {
            color: #fff;
            letter-spacing: 10px;
            font-weight: 100;
            margin-bottom: 40px;
            text-transform: uppercase;
        }

        button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.5);
            color: #fff;
            padding: 20px 60px;
            font-family: inherit;
            font-weight: 900;
            font-size: 1.2rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: 0.3s;
            border-radius: 50px;
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.2);
        }

        button:hover {
            background: #fff;
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 80px rgba(255, 0, 170, 0.8);
        }

        #lyrics {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            font-size: 8vw;
            font-weight: 900;
            color: rgba(255,255,255,0.1);
            pointer-events: none;
            z-index: 2;
            mix-blend-mode: overlay;
            transition: all 0.2s;
        }
        
        .flash { animation: flashAnim 0.2s ease-out; }
        @keyframes flashAnim { 0% { background: #fff; } 100% { background: transparent; } }

    </style>
</head>
<body>

    <canvas id="world"></canvas>
    <div id="flash-overlay" style="position:absolute;width:100%;height:100%;pointer-events:none;z-index:20;"></div>

    <div id="lyrics"></div>

    <div id="ui-layer">
        <h1>ETERNAL</h1>
        <p>THE FINAL EMOTION</p>
        <button onclick="startOpus()">INITIATE EUPHORIA</button>
    </div>

    <script>
        /**
         * THE ETERNAL HORIZON
         * A Generative Audio-Visual Odyssey
         */

        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d', { alpha: false });
        let w, h, cx, cy;
        let time = 0;
        let isRunning = false;

        // GLOBAL SYNC VARIABLES
        let beat = 0;
        let bar = 0;
        let currentPhase = 0; // 0:Intro, 1:Build, 2:Drop, 3:Break, 4:Climax
        let sidechain = 0; // 0.0 to 1.0
        let kickTrigger = false;
        let globalHue = 200;
        let currentText = "";

        /* ------------------------------------------------
           AUDIO ENGINE CONSTANTS
           ------------------------------------------------ */
        const AC = window.AudioContext || window.webkitAudioContext;
        let actx, master, sidechainBus, reverb;

        // SCALES (Transposition Arrays)
        // Base: F# Major
        const ROOT = 369.99; // F#4
        const SCALE_MAJ = [0, 2, 4, 5, 7, 9, 11]; // Major intervals
        
        // CHORD PROGRESSIONS (Degrees)
        const PROG_A = [[1,3,5], [5,7,2], [6,1,3], [4,6,1]]; // I - V - vi - IV (Emotional)
        const PROG_B = [[6,1,3], [4,6,1], [1,3,5], [5,7,2]]; // vi - IV - I - V (Trance)
        
        let currentProgression = PROG_A;
        let rootFreq = ROOT; 
        let speed = 0.01; // Visual speed

        /* ------------------------------------------------
           VISUAL ENGINE
           ------------------------------------------------ */
        let particles = [];
        let shapes = [];

        function resize() {
            w = window.innerWidth; h = window.innerHeight;
            canvas.width = w; canvas.height = h;
            cx = w/2; cy = h/2;
        }
        window.addEventListener('resize', resize);

        class Star {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = (Math.random() - 0.5) * w * 2;
                this.y = (Math.random() - 0.5) * h * 2;
                this.z = Math.random() * 2000 + 500;
                this.size = Math.random();
                this.color = Math.random() > 0.9 ? '#fff' : `hsl(${globalHue}, 80%, 70%)`;
            }
            update() {
                // Move towards camera
                this.z -= (10 + (speed * 500)) * (1 + sidechain);
                
                // Rotate field
                const angle = time * 0.5;
                const x = this.x * Math.cos(angle) - this.y * Math.sin(angle);
                const y = this.x * Math.sin(angle) + this.y * Math.cos(angle);

                // Projection
                const fov = 500;
                const scale = fov / (fov + this.z);
                this.sx = cx + x * scale;
                this.sy = cy + y * scale;
                this.ss = this.size * scale * 5;

                if (this.z < 1 || this.sx < 0 || this.sx > w || this.sy < 0 || this.sy > h) this.reset();
            }
            draw() {
                const alpha = Math.min(1, 1000 / this.z);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.sx, this.sy, this.ss * (1+sidechain), 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Shard {
            constructor() {
                this.x = cx; this.y = cy;
                this.angle = Math.random() * Math.PI * 2;
                this.vel = 2 + Math.random() * 5;
                this.life = 1;
                this.hue = globalHue + (Math.random()*40 - 20);
            }
            update() {
                this.x += Math.cos(this.angle) * this.vel * (1 + sidechain * 2);
                this.y += Math.sin(this.angle) * this.vel * (1 + sidechain * 2);
                this.life -= 0.01;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = `hsl(${this.hue}, 100%, 60%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2 + (sidechain*10), 0, Math.PI*2);
                ctx.fill();
            }
        }

        function initVisuals() {
            for(let i=0; i<500; i++) particles.push(new Star());
        }

        function render() {
            if(!isRunning) return;
            requestAnimationFrame(render);
            
            time += 0.01;
            sidechain *= 0.92; // Decay pump

            // BG Clearing with Trails
            ctx.fillStyle = 'rgba(0,0,0,0.2)'; 
            ctx.fillRect(0, 0, w, h);

            // GLOBAL CAMERA SHAKE (THE BOUNCE)
            const zoom = 1.0 + (sidechain * 0.05);
            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(zoom, zoom);
            ctx.rotate(sidechain * 0.02 * Math.sin(time * 10));
            ctx.translate(-cx, -cy);

            // Render Particles
            ctx.globalCompositeOperation = 'lighter';
            particles.forEach(p => { p.update(); p.draw(); });
            
            // Render Explosions
            shapes.forEach((s, i) => {
                s.update();
                s.draw();
                if(s.life <= 0) shapes.splice(i, 1);
            });

            // THE CORE (Central Sun)
            const sunSize = 50 + (sidechain * 150);
            const sunGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, sunSize * 4);
            sunGrad.addColorStop(0, '#fff');
            sunGrad.addColorStop(0.1, `hsl(${globalHue}, 100%, 50%)`);
            sunGrad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = sunGrad;
            ctx.beginPath();
            ctx.arc(cx, cy, sunSize * 4, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();

            // TEXT UPDATE
            const el = document.getElementById('lyrics');
            el.innerText = currentText;
            el.style.transform = `translate(-50%, -50%) scale(${1 + sidechain * 0.2})`;
            el.style.textShadow = `0 0 ${sidechain * 50}px white`;
        }

        /* ------------------------------------------------
           AUDIO SCHEDULER & SYNTHESIS
           ------------------------------------------------ */
        let nextNoteTime = 0;
        let tick = 0;

        function startOpus() {
            isRunning = true;
            
            // HIDE UI
            const ui = document.getElementById('ui-layer');
            ui.style.opacity = 0;
            setTimeout(() => ui.style.display = 'none', 2000);

            resize();
            initVisuals();
            initAudio();
            
            if(actx.state === 'suspended') actx.resume();
            render();
        }

        function initAudio() {
            actx = new AC();
            
            // MASTER COMPRESSOR (The Glue)
            master = actx.createDynamicsCompressor();
            master.threshold.value = -12;
            master.ratio.value = 12;
            master.connect(actx.destination);

            // SIDECHAIN BUS
            sidechainBus = actx.createGain();
            sidechainBus.connect(master);

            // HUGE REVERB
            reverb = actx.createConvolver();
            generateReverb(3.0);
            const revGain = actx.createGain();
            revGain.gain.value = 0.4;
            
            sidechainBus.connect(revGain);
            revGain.connect(reverb);
            reverb.connect(master);

            nextNoteTime = actx.currentTime + 0.1;
            scheduler();
        }

        function generateReverb(duration) {
            const len = actx.sampleRate * duration;
            const buf = actx.createBuffer(2, len, actx.sampleRate);
            for(let i=0; i<len; i++) {
                const d = Math.pow(1 - i/len, 3);
                buf.getChannelData(0)[i] = (Math.random()*2-1)*d;
                buf.getChannelData(1)[i] = (Math.random()*2-1)*d;
            }
            reverb.buffer = buf;
        }

        function scheduler() {
            const bpm = 150; // HIGH ENERGY
            const beatLen = 60 / bpm;
            const sixteenth = beatLen / 4;
            const lookahead = 0.1;

            while (nextNoteTime < actx.currentTime + lookahead) {
                playTick(nextNoteTime, tick);
                nextNoteTime += sixteenth;
                tick++;
            }
            if(isRunning) setTimeout(scheduler, 25);
        }

        function playTick(t, i) {
            const step = i % 16;
            const barCount = Math.floor(i / 16);
            
            // STATE MACHINE ///////////////////////////
            if (barCount === 0) { phase(0); currentText = "AWAKENING"; }
            else if (barCount === 8) { phase(1); currentText = "RISING"; }
            else if (barCount === 15) { currentText = "PREPARE"; }
            else if (barCount === 16) { phase(2); currentText = "FLY"; }
            else if (barCount === 32) { phase(3); currentText = "DRIFTING"; } // Break
            else if (barCount === 40) { phase(1); currentText = "ONE MORE TIME"; } // Build 2
            else if (barCount === 48) { phase(4); currentText = "ASCENSION"; } // Climax (Key change)
            ////////////////////////////////////////////

            // 1. KICK (Sidechain Trigger)
            let kickHit = false;
            if (currentPhase === 2 || currentPhase === 4) { // Drop
                if (step % 4 === 0) kickHit = true;
            } else if (currentPhase === 1) { // Build
                if (barCount % 8 < 4 && step % 4 === 0) kickHit = true; // 1/4
                if (barCount % 8 >= 4 && barCount % 8 < 6 && step % 2 === 0) kickHit = true; // 1/8
                if (barCount % 8 >= 6 && step % 1 === 0) kickHit = true; // 1/16
            }

            if (kickHit) {
                playKick(t);
                // DUCK AUDIO
                sidechainBus.gain.cancelScheduledValues(t);
                sidechainBus.gain.setValueAtTime(0, t);
                sidechainBus.gain.linearRampToValueAtTime(1, t + 0.1);
                // VISUAL PUMP
                sidechain = 1.0; 
                // Spawn Shards
                if (Math.random() > 0.5) for(let k=0; k<5; k++) shapes.push(new Shard());
            }

            // 2. SNARE / CLAP
            if ((currentPhase === 2 || currentPhase === 4) && step % 8 === 4) {
                playSnare(t);
            }
            // Build snare roll
            if (currentPhase === 1 && kickHit) playSnare(t, 0.5);

            // 3. CHORDS (SuperSaws)
            // Play on beat 1 of every bar, or chopped in drop
            let playChord = false;
            if (currentPhase === 0 && step === 0) playChord = true; // Long pads
            if ((currentPhase === 2 || currentPhase === 4) && (step === 0 || step === 3 || step === 6 || step === 10)) playChord = true; // Rhythmic

            if (playChord) {
                // Determine Chord from Progression
                const progIdx = (Math.floor(barCount / 2)) % 4; // Change chord every 2 bars
                const chordDegrees = currentProgression[progIdx];
                
                chordDegrees.forEach(deg => {
                    // Convert degree to freq
                    // Note: Scale logic simplified for code density
                    // 1=0 semitones, 3=4 semitones, 5=7 semitones etc.
                    let semi = 0;
                    if(deg===1) semi=0;
                    if(deg===2) semi=2;
                    if(deg===3) semi=4;
                    if(deg===4) semi=5;
                    if(deg===5) semi=7;
                    if(deg===6) semi=9;
                    if(deg===7) semi=11;
                    
                    const freq = rootFreq * Math.pow(2, semi/12);
                    playSuperSaw(t, freq, currentPhase === 0 ? 2 : 0.4);
                });
            }

            // 4. VOCAL LEAD (The "Marshmello" Chop)
            // Pentatonic Melody
            if (currentPhase >= 2) {
                const melody = [0, 4, 7, 9, 7, 4, 0, -3, 0, 4, 7, 12, 9, 7, 4, 0];
                if (step % 2 === 0 && Math.random() > 0.3) {
                    const note = melody[(step/2 + barCount) % 16];
                    const freq = rootFreq * 2 * Math.pow(2, note/12);
                    playVocalChop(t, freq);
                }
            }

            // 5. HI-HATS (Rolling)
            if (currentPhase >= 2) {
                if (step % 2 === 0) playHat(t, step % 4 === 2); // Closed/Open
                if (step % 4 === 0 && Math.random() > 0.8) playHat(t, true); // Random open
            }
        }

        function phase(p) {
            if (currentPhase === p) return;
            currentPhase = p;

            if (p === 0) { speed = 0.01; globalHue = 200; } // Blue Intro
            if (p === 1) { speed = 0.05; globalHue = 50; }  // Yellow Build
            if (p === 2) { speed = 0.10; globalHue = 300; } // Magenta Drop
            if (p === 3) { speed = 0.01; globalHue = 180; } // Cyan Break
            if (p === 4) { 
                // KEY CHANGE! +2 Semitones
                rootFreq = ROOT * Math.pow(2, 2/12); 
                speed = 0.20; 
                globalHue = 0; // Red/White Hot
                
                // Flash Screen
                document.getElementById('flash-overlay').className = 'flash';
                setTimeout(() => document.getElementById('flash-overlay').className = '', 500);
            }
        }

        /* --- SYNTHS --- */

        function playSuperSaw(t, freq, dur) {
            const g = actx.createGain();
            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.1, t + 0.02);
            g.gain.exponentialRampToValueAtTime(0.001, t + dur);
            g.connect(sidechainBus);

            // 3 Oscillators per voice for thickness
            const detunes = [-15, 0, 15];
            detunes.forEach(d => {
                const osc = actx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = freq;
                osc.detune.value = d;
                osc.connect(g);
                osc.start(t); osc.stop(t + dur);
            });
        }

        function playKick(t) {
            const osc = actx.createOscillator();
            const g = actx.createGain();
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.4);
            g.gain.setValueAtTime(1, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
            
            osc.connect(g); g.connect(master); // Bypass sidechain
            osc.start(t); osc.stop(t+0.4);
        }

        function playSnare(t, vol=0.5) {
            const noise = actx.createBufferSource();
            const b = actx.createBuffer(1, actx.sampleRate * 0.2, actx.sampleRate);
            const d = b.getChannelData(0);
            for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
            noise.buffer = b;

            const f = actx.createBiquadFilter();
            f.type = 'highpass'; f.frequency.value = 1000;
            
            const g = actx.createGain();
            g.gain.setValueAtTime(vol, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

            noise.connect(f); f.connect(g); g.connect(master);
            noise.start(t);
        }

        function playHat(t, open) {
            const dur = open ? 0.1 : 0.05;
            const noise = actx.createOscillator();
            noise.type = 'square'; // Metallic
            // Actually logic for noise is better with buffer but square is chiptuney/trap
            
            const f = actx.createBiquadFilter();
            f.type = 'highpass'; f.frequency.value = 8000;
            
            const g = actx.createGain();
            g.gain.setValueAtTime(0.1, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + dur);

            noise.connect(f); f.connect(g); g.connect(master);
            noise.start(t); noise.stop(t+dur);
        }

        function playVocalChop(t, freq) {
            const osc = actx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.value = freq;

            // Formant Filter for "Voice"
            const f = actx.createBiquadFilter();
            f.type = 'bandpass';
            f.Q.value = 3;
            f.frequency.setValueAtTime(800, t);
            f.frequency.linearRampToValueAtTime(1400, t + 0.1);

            const g = actx.createGain();
            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.2, t + 0.02);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

            osc.connect(f); f.connect(g); g.connect(sidechainBus);
            osc.start(t); osc.stop(t+0.3);
        }

        resize();
    </script>
</body>
</html>

PROGRAM 14
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>THE MICRO-GROOVE // SYNCOPATION ENGINE</title>
<style>
    :root { --bg: #111; --k: #fff; --h: #0ff; --s: #ff0; --r: #f0f; }
    body {
        margin: 0; background: var(--bg); overflow: hidden;
        font-family: 'Helvetica', sans-serif; color: #eee;
        display: flex; justify-content: center; align-items: center; height: 100vh;
    }
    canvas { position: absolute; top: 0; left: 0; z-index: 1; }
    
    #ui {
        position: absolute; z-index: 10; text-align: center;
        background: rgba(17,17,17,0.95); padding: 50px; 
        border: 1px solid #333; transition: opacity 0.5s;
    }

    h1 { font-weight: 100; letter-spacing: 3px; font-size: 1.5rem; margin-bottom: 20px; }
    .status { font-size: 0.8rem; color: #666; margin-bottom: 30px; letter-spacing: 1px; }

    button {
        background: transparent; border: 1px solid #fff; color: #fff;
        padding: 15px 40px; cursor: pointer; font-size: 0.9rem;
        transition: 0.2s; letter-spacing: 2px;
    }
    button:hover { background: #fff; color: #000; }

    #readout {
        position: absolute; bottom: 40px; width: 100%; text-align: center;
        z-index: 5; font-size: 12px; color: #555; letter-spacing: 2px;
    }
    .active-element { color: #fff; font-weight: bold; }
</style>
</head>
<body>

<div id="readout">
    <span id="txt-k" style="color:#444">KICK</span> // 
    <span id="txt-h" style="color:#444">HI-HAT</span> // 
    <span id="txt-s" style="color:#444">SHAKER</span> // 
    <span id="txt-r" style="color:#444">RIM</span>
</div>

<div id="ui">
    <h1>MICRO // GROOVE</h1>
    <div class="status">SYNCOPATED PERCUSSION ENGINE</div>
    <button id="btn">INITIALIZE GROOVE</button>
</div>

<canvas id="c"></canvas>

<script>
/**
 * THE MICRO-GROOVE
 * BPM: 124
 * SWING: 25% (Roger Linn Style)
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

let ac, master, limiter;
let isPlaying = false;
let startTime = 0;

// CONFIG
const BPM = 124;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;
const SWING_AMOUNT = 0.035; // The "Breath" (Delay in seconds for offbeats)

// ================= AUDIO ENGINE ================= //

async function init() {
    ac = new AC();
    await ac.resume();

    master = ac.createGain();
    master.gain.value = 0.7;

    limiter = ac.createDynamicsCompressor();
    limiter.threshold.value = -1;
    limiter.ratio.value = 20;

    master.connect(limiter).connect(ac.destination);
}

// 1. THE HEARTBEAT (Kick)
// Clean, tight, punchy. No mud.
function playKick(t) {
    const osc = ac.createOscillator();
    const g = ac.createGain();
    
    // Pitch sweep: Body
    osc.frequency.setValueAtTime(140, t);
    osc.frequency.exponentialRampToValueAtTime(45, t + 0.15);
    
    // Envelope: Tight
    g.gain.setValueAtTime(1.0, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

    // Click (Transient)
    const c = ac.createOscillator(); c.type='square';
    const cg = ac.createGain();
    cg.gain.setValueAtTime(0.1, t);
    cg.gain.exponentialRampToValueAtTime(0.001, t + 0.01);

    osc.connect(g).connect(master);
    c.connect(cg).connect(master);
    
    osc.start(t); osc.stop(t+0.3);
    c.start(t); c.stop(t+0.01);
    
    viz.k = 1;
}

// 2. THE QUESTION (Hi-Hat)
// Crisp, metallic, syncopated.
function playHat(t, vel) {
    // FM Metallic Noise
    const ratio = 4.1; // Inharmonic
    const fund = 600;

    const car = ac.createOscillator(); car.type = 'square';
    car.frequency.value = fund;
    const mod = ac.createOscillator(); mod.type = 'square';
    mod.frequency.value = fund * ratio;
    
    const modG = ac.createGain(); modG.gain.value = 1000;
    mod.connect(modG).connect(car.frequency);

    const f = ac.createBiquadFilter(); f.type='highpass'; f.frequency.value = 6000;

    const g = ac.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vel * 0.4, t+0.005);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.06); // Very short

    car.connect(f).connect(g).connect(master);
    car.start(t); car.stop(t+0.1);
    mod.start(t); mod.stop(t+0.1);
    
    viz.h = 1;
}

// 3. THE ANSWER (Shaker)
// Breath-y, filtered noise, swinging.
function playShaker(t, accent) {
    const bufSize = ac.sampleRate * 0.1;
    const buf = ac.createBuffer(1, bufSize, ac.sampleRate);
    const d = buf.getChannelData(0);
    for(let i=0; i<bufSize; i++) d[i] = Math.random()*2-1;
    const n = ac.createBufferSource(); n.buffer = buf;

    const f = ac.createBiquadFilter(); 
    f.type = 'bandpass'; 
    f.frequency.value = 9000; 
    f.Q.value = 1;

    const g = ac.createGain();
    const vol = accent ? 0.15 : 0.05; // Ghost notes vs Accents
    
    // Soft attack (The "Ch" sound)
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.01); 
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.08);

    n.connect(f).connect(g).connect(master);
    n.start(t);
    viz.s = 1;
}

// 4. THE TEASE (Rim / Woodblock)
// Resonant, woody, sparse.
function playRim(t) {
    const osc = ac.createOscillator();
    osc.type = 'triangle';
    osc.frequency.value = 950; // High woodblock pitch
    
    const g = ac.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.6, t + 0.002); // Snap attack
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.08); // No sustain

    // Bandpass for "Hollow" sound
    const f = ac.createBiquadFilter();
    f.type = 'bandpass'; f.frequency.value = 1200; f.Q.value = 2;

    osc.connect(f).connect(g).connect(master);
    osc.start(t); osc.stop(t+0.1);
    
    viz.r = 1;
}

// ================= SEQUENCER ================= //

// Patterns (16 Steps)
// 1 = Hit, 0 = Rest
const PTN = {
    KICK: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
    // "Dancing around the kick" - avoiding the 1
    HAT:  [0,0,1,0, 0,1,0,1, 0,0,1,0, 1,0,1,0], 
    // "And of 2" (Step 6) and "e of 4" (Step 15)
    RIM:  [0,0,0,0, 0,0,1,0, 0,0,0,0, 0,0,0,1]
};

let nextTime = 0;
let step = 0;

function scheduler() {
    if(!isPlaying) return;
    const lookahead = 0.1;
    while(nextTime < ac.currentTime + lookahead) {
        scheduleStep(step, nextTime);
        step++;
        nextTime += SIXTEENTH;
    }
    setTimeout(scheduler, 25);
}

function scheduleStep(s, t) {
    const bar = Math.floor(s / 16);
    const bStep = s % 16;
    
    // PROGRESSIVE STRUCTURE
    let showKick = true;
    let showHat = bar >= 4;
    let showShaker = bar >= 8;
    let showRim = bar >= 12;

    // UI Updates
    updateHUD(showKick, showHat, showShaker, showRim);

    // SWING LOGIC
    // If it's an even step (0, 2, 4), it's on grid.
    // If it's an odd step (1, 3, 5), it's the "offbeat". We delay it.
    const swing = (bStep % 2 !== 0) ? SWING_AMOUNT : 0;
    const swingTime = t + swing;

    // 1. KICK (On grid)
    if (showKick && PTN.KICK[bStep]) playKick(t);

    // 2. HAT (Swung)
    if (showHat && PTN.HAT[bStep]) playHat(swingTime, 1.0);

    // 3. SHAKER (Double Time - Every Step)
    // Accent the off-beats (the "Up" stroke) to breathe
    if (showShaker) {
        const isOffbeat = bStep % 2 !== 0;
        playShaker(swingTime, isOffbeat); 
    }

    // 4. RIM (Tease - Specific spots)
    if (showRim && PTN.RIM[bStep]) playRim(swingTime);
}

function updateHUD(k, h, s, r) {
    document.getElementById('txt-k').style.color = k ? '#fff' : '#444';
    document.getElementById('txt-k').style.textShadow = k ? '0 0 10px #fff' : 'none';
    
    document.getElementById('txt-h').style.color = h ? '#0ff' : '#444';
    document.getElementById('txt-h').style.textShadow = h ? '0 0 10px #0ff' : 'none';
    
    document.getElementById('txt-s').style.color = s ? '#ff0' : '#444';
    document.getElementById('txt-s').style.textShadow = s ? '0 0 10px #ff0' : 'none';
    
    document.getElementById('txt-r').style.color = r ? '#f0f' : '#444';
    document.getElementById('txt-r').style.textShadow = r ? '0 0 10px #f0f' : 'none';
}


// ================= VISUALS ================= //

let viz = { k:0, h:0, s:0, r:0 };

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.onresize = initVis;

function draw() {
    requestAnimationFrame(draw);
    
    // Fade background
    ctx.fillStyle = 'rgba(17,17,17,0.3)';
    ctx.fillRect(0,0,w,h);
    
    const cx = w/2;
    const cy = h/2;

    // KICK: White Pulse (Center)
    if(viz.k > 0.01) {
        viz.k *= 0.85;
        ctx.beginPath();
        ctx.arc(cx, cy, 50 + (viz.k*50), 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255,255,255,${viz.k})`;
        ctx.lineWidth = 5;
        ctx.stroke();
    }

    // HAT: Cyan Glitch (Top)
    if(viz.h > 0.01) {
        viz.h *= 0.8;
        const x = cx + (Math.random()-0.5)*100;
        const y = cy - 100 + (Math.random()-0.5)*50;
        ctx.fillStyle = `rgba(0, 255, 255, ${viz.h})`;
        ctx.fillRect(x, y, 4, 20);
    }

    // SHAKER: Yellow Dust (Sides)
    if(viz.s > 0.01) {
        viz.s *= 0.7; // Fast decay
        ctx.fillStyle = `rgba(255, 255, 0, ${viz.s})`;
        // Left
        ctx.fillRect(cx - 150, cy + (Math.random()-0.5)*100, 2, 2);
        // Right
        ctx.fillRect(cx + 150, cy + (Math.random()-0.5)*100, 2, 2);
    }

    // RIM: Pink Dot (Unexpected locations)
    if(viz.r > 0.01) {
        viz.r *= 0.9;
        ctx.beginPath();
        // Fixed positions for "And of 2" and "e of 4" visuals? No, make it pop.
        ctx.arc(cx, cy - 150, 10, 0, Math.PI*2);
        ctx.fillStyle = `rgba(255, 0, 255, ${viz.r})`;
        ctx.fill();
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#f0f';
        ctx.shadowBlur = 0;
    }
}

initVis();
draw();

document.getElementById('btn').addEventListener('click', async () => {
    document.getElementById('ui').style.opacity = 0;
    document.getElementById('ui').style.pointerEvents = 'none';
    
    await init();
    isPlaying = true;
    startTime = ac.currentTime + 0.1;
    nextTime = startTime;
    scheduler();
});

</script>
</body>
</html>

PROGRAM 15
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>THE OMEGA PROTOCOL // GENERATIVE SYSTEM</title>
<style>
    :root { --bg: #050505; --term: #0f0; --acc: #0ff; --err: #f00; }
    body { 
        margin: 0; background: var(--bg); overflow: hidden; 
        font-family: 'Courier New', monospace; color: var(--term); 
        cursor: crosshair; user-select: none;
    }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
        pointer-events: none;
    }
    #overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.95); display: flex; flex-direction: column;
        justify-content: center; align-items: center; z-index: 100;
        transition: opacity 2s cubic-bezier(0.19, 1, 0.22, 1); pointer-events: auto;
    }
    .btn {
        background: transparent; border: 2px solid var(--term); color: var(--term);
        padding: 20px 40px; font-size: 1.5rem; letter-spacing: 5px; cursor: pointer;
        text-transform: uppercase; transition: 0.3s;
        box-shadow: 0 0 20px rgba(0,255,0,0.2);
    }
    .btn:hover { background: var(--term); color: #000; box-shadow: 0 0 50px var(--term); }
    #terminal {
        position: absolute; bottom: 20px; left: 20px; width: 400px; height: 200px;
        overflow-y: hidden; font-size: 12px; opacity: 0.8;
        background: rgba(0,0,0,0.5); padding: 10px; border-left: 2px solid var(--term);
    }
    #hud-top {
        position: absolute; top: 20px; right: 20px; text-align: right;
    }
    .scanline {
        position: fixed; top: 0; left: 0; width: 100%; height: 5px;
        background: rgba(0,255,0,0.1); opacity: 0.5; pointer-events: none;
        animation: scan 6s linear infinite; z-index: 50;
    }
    @keyframes scan { 0% { top: -10px; } 100% { top: 105%; } }
</style>
</head>
<body>

<div class="scanline"></div>

<div id="overlay">
    <pre style="font-size: 10px; margin-bottom: 20px; opacity: 0.7;">
âââââââ ââââ   ââââââââââââ âââââââ  ââââââ 
ââââââââââââââ âââââââââââââââââââââ ââââââââ
âââ   ââââââââââââââââââââ  âââ  ââââââââââââ
âââ   ââââââââââââââââââââ  âââ   âââââââââââ
ââââââââââââ âââ âââââââââââââââââââââââ  âââ
 âââââââ âââ     âââââââââââ âââââââ âââ  âââ
    </pre>
    <div style="margin-bottom: 40px; letter-spacing: 8px;">THE OMEGA PROTOCOL</div>
    <button class="btn" id="initBtn">INITIALIZE SYSTEM</button>
</div>

<div id="ui-layer">
    <div id="hud-top">
        <div>CPU: <span id="cpu">0%</span></div>
        <div>DSP: <span id="dsp">OFFLINE</span></div>
        <div>BPM: <span id="bpm">128</span></div>
    </div>
    <div id="terminal">
        <div>> SYSTEM BOOT...</div>
        <div>> AWAITING USER INPUT</div>
    </div>
</div>

<canvas id="cvs"></canvas>

<script>
/**
 * ----------------------------------------------------------------------------
 * THE OMEGA PROTOCOL v1.0
 * ----------------------------------------------------------------------------
 * A completely procedural, object-oriented audio/visual engine.
 * 
 * MODULES:
 * 1. CORE: AudioContext Management
 * 2. SYNTHESIS: Oscillators, Filters, Envelopes
 * 3. EFFECTS: Reverb, Delay, Distortion
 * 4. COMPOSITION: Generative Sequencer (The Director)
 * 5. VISUALS: Physics Particle Engine & FFT Analysis
 * ----------------------------------------------------------------------------
 */

// ============================================================================
// 0. UTILITIES & MATH
// ============================================================================

const U = {
    r: (min, max) => Math.random() * (max - min) + min,
    ri: (min, max) => Math.floor(Math.random() * (max - min + 1) + min),
    pick: (arr) => arr[Math.floor(Math.random() * arr.length)],
    mtof: (note) => 440 * Math.pow(2, (note - 69) / 12),
    clamp: (v, min, max) => Math.min(Math.max(v, min), max),
    now: () => ctx ? ctx.currentTime : 0,
    log: (msg) => {
        const t = document.getElementById('terminal');
        const l = document.createElement('div');
        l.innerText = `> ${msg}`;
        t.appendChild(l);
        if(t.children.length > 12) t.removeChild(t.firstChild);
    }
};

// ============================================================================
// 1. MUSIC THEORY CONSTANTS
// ============================================================================

const SCALES = {
    CYBER:  [36, 39, 41, 43, 46, 48, 51, 53, 55, 58], // Minor Pentatonic + Blues
    VOID:   [36, 37, 40, 41, 43, 48, 49, 52, 53, 55], // Phrygian Dominant
    HOPE:   [36, 38, 40, 43, 45, 48, 50, 52, 55, 57]  // Major Pentatonic
};

// ============================================================================
// 2. AUDIO CORE
// ============================================================================

let AC = window.AudioContext || window.webkitAudioContext;
let actx, master, limiter, analyser;

class AudioCore {
    static async init() {
        actx = new AC();
        await actx.resume();
        
        master = actx.createGain();
        master.gain.value = 0.6;
        
        // Safety Limiter
        limiter = actx.createDynamicsCompressor();
        limiter.threshold.value = -3;
        limiter.ratio.value = 20;
        limiter.attack.value = 0.001;
        
        // Analysis for Visuals
        analyser = actx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.85;

        master.connect(limiter);
        limiter.connect(analyser);
        analyser.connect(actx.destination);
        
        U.log("AUDIO CORE: ONLINE");
        U.log("SAMPLERATE: " + actx.sampleRate);
        document.getElementById('dsp').innerText = "ONLINE";
        
        return true;
    }
}

// ============================================================================
// 3. EFFECTS RACK
// ============================================================================

class FX_Reverb {
    constructor() {
        this.input = actx.createGain();
        this.output = actx.createGain();
        this.conv = actx.createConvolver();
        this.wet = actx.createGain();
        this.dry = actx.createGain();
        
        this.generateImpulse();
        
        this.input.connect(this.dry);
        this.input.connect(this.conv);
        this.conv.connect(this.wet);
        this.wet.connect(this.output);
        this.dry.connect(this.output);
        
        this.wet.gain.value = 0.4;
        this.dry.gain.value = 1.0;
    }
    
    generateImpulse() {
        const len = actx.sampleRate * 3.0; // 3 Seconds
        const buff = actx.createBuffer(2, len, actx.sampleRate);
        for(let c=0; c<2; c++){
            const d = buff.getChannelData(c);
            for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 3);
        }
        this.conv.buffer = buff;
    }
    
    connect(dest) { this.output.connect(dest); }
}

class FX_Delay {
    constructor(time = 0.3, feedback = 0.4) {
        this.input = actx.createGain();
        this.output = actx.createGain();
        this.d = actx.createDelay();
        this.fb = actx.createGain();
        this.wet = actx.createGain();
        
        this.d.delayTime.value = time;
        this.fb.gain.value = feedback;
        this.wet.gain.value = 0.5;
        
        this.input.connect(this.output); // Dry
        this.input.connect(this.d);
        this.d.connect(this.fb);
        this.fb.connect(this.d); // Loop
        this.d.connect(this.wet);
        this.wet.connect(this.output);
    }
    connect(dest) { this.output.connect(dest); }
}

class FX_BitCrusher {
    constructor(bits = 8) {
        this.input = actx.createGain();
        this.output = actx.createGain();
        this.script = actx.createScriptProcessor(4096, 1, 1);
        this.bits = bits;
        this.norm = Math.pow(2, bits);
        
        this.script.onaudioprocess = (e) => {
            const inp = e.inputBuffer.getChannelData(0);
            const out = e.outputBuffer.getChannelData(0);
            const step = 1 / this.norm;
            for(let i=0; i<inp.length; i++){
                out[i] = Math.round(inp[i] * this.norm) / this.norm;
            }
        };
        
        this.input.connect(this.script);
        this.script.connect(this.output);
    }
    connect(dest) { this.output.connect(dest); }
}

// ============================================================================
// 4. SYNTHESIS ENGINE
// ============================================================================

class ADSREnvelope {
    constructor(p) {
        this.a = p.a || 0.01;
        this.d = p.d || 0.1;
        this.s = p.s || 0.5;
        this.r = p.r || 0.2;
    }
    
    trigger(param, t, peak = 1) {
        param.cancelScheduledValues(t);
        param.setValueAtTime(0, t);
        param.linearRampToValueAtTime(peak, t + this.a);
        param.exponentialRampToValueAtTime(this.s * peak, t + this.a + this.d);
    }
    
    release(param, t) {
        param.cancelScheduledValues(t);
        param.setValueAtTime(param.value, t);
        param.exponentialRampToValueAtTime(0.001, t + this.r);
    }
}

class MonoSynth {
    constructor(dest) {
        this.dest = dest;
    }
    
    play(freq, dur, t) {
        const osc = actx.createOscillator();
        const filter = actx.createBiquadFilter();
        const vca = actx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);
        
        // Filter Envelope
        filter.type = 'lowpass';
        filter.Q.value = 5;
        filter.frequency.setValueAtTime(100, t);
        filter.frequency.exponentialRampToValueAtTime(3000, t + 0.05);
        filter.frequency.exponentialRampToValueAtTime(100, t + dur);
        
        // Amp Envelope
        vca.gain.setValueAtTime(0, t);
        vca.gain.linearRampToValueAtTime(0.4, t + 0.02);
        vca.gain.exponentialRampToValueAtTime(0.001, t + dur);
        
        osc.connect(filter);
        filter.connect(vca);
        vca.connect(this.dest);
        
        osc.start(t);
        osc.stop(t + dur + 0.1);
    }
}

class PadSynth {
    constructor(dest) {
        this.dest = dest;
    }
    
    playChord(notes, dur, t) {
        const vca = actx.createGain();
        vca.gain.setValueAtTime(0, t);
        vca.gain.linearRampToValueAtTime(0.1, t + 1.0); // Slow attack
        vca.gain.linearRampToValueAtTime(0.1, t + dur - 1.0);
        vca.gain.linearRampToValueAtTime(0, t + dur);
        
        const filter = actx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800;
        
        notes.forEach((n, i) => {
            const osc = actx.createOscillator();
            osc.type = i % 2 === 0 ? 'sawtooth' : 'triangle';
            osc.frequency.value = U.mtof(n);
            osc.detune.value = U.r(-10, 10);
            osc.connect(filter);
            osc.start(t);
            osc.stop(t + dur);
        });
        
        filter.connect(vca);
        vca.connect(this.dest);
    }
}

class DrumSynth {
    constructor(dest) {
        this.dest = dest;
    }
    
    kick(t) {
        const osc = actx.createOscillator();
        const g = actx.createGain();
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.3);
        g.gain.setValueAtTime(1, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g); g.connect(this.dest);
        osc.start(t); osc.stop(t+0.3);
    }
    
    snare(t) {
        const noise = actx.createBufferSource();
        const b = actx.createBuffer(1, actx.sampleRate*0.2, actx.sampleRate);
        const d = b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        noise.buffer = b;
        const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=1000;
        const g = actx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
        noise.connect(f); f.connect(g); g.connect(this.dest);
        noise.start(t);
    }
    
    hihat(t) {
        const noise = actx.createBufferSource();
        const b = actx.createBuffer(1, actx.sampleRate*0.05, actx.sampleRate);
        const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        noise.buffer = b;
        const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000;
        const g = actx.createGain(); g.gain.value=0.2; g.gain.exponentialRampToValueAtTime(0.001, t+0.05);
        noise.connect(f); f.connect(g); g.connect(this.dest);
        noise.start(t);
    }
}

// ============================================================================
// 5. THE DIRECTOR (GENERATIVE AI)
// ============================================================================

class Director {
    constructor() {
        this.BPM = 120;
        this.step = 0;
        this.bar = 0;
        this.nextTime = 0;
        this.state = 'BOOT'; // BOOT, GRID, ASCENSION, SINGULARITY
        this.scale = SCALES.CYBER;
        
        // Buses
        this.reverb = new FX_Reverb();
        this.delay = new FX_Delay(0.375, 0.5); // Dotted 8th
        this.bitcrush = new FX_BitCrusher(4);
        
        this.reverb.connect(master);
        this.delay.connect(master);
        this.bitcrush.connect(master);
        
        // Instruments
        this.bass = new MonoSynth(master);
        this.lead = new MonoSynth(this.delay.input);
        this.pad = new PadSynth(this.reverb.input);
        this.drums = new DrumSynth(master);
        this.glitch = new DrumSynth(this.bitcrush.input);
    }
    
    start() {
        this.nextTime = actx.currentTime + 0.1;
        this.loop();
    }
    
    loop() {
        const lookahead = 0.1;
        while(this.nextTime < actx.currentTime + lookahead) {
            this.tick(this.step, this.nextTime);
            this.nextTime += (60 / this.BPM) / 4; // 16th notes
            this.step++;
        }
        setTimeout(() => this.loop(), 25);
    }
    
    tick(step, t) {
        const barStep = step % 16;
        if(barStep === 0) {
            this.bar++;
            this.manageState();
        }
        
        // GLOBAL LOGIC
        if(this.state === 'BOOT') this.playBoot(barStep, t);
        if(this.state === 'GRID') this.playGrid(barStep, t);
        if(this.state === 'ASCENSION') this.playAscension(barStep, t);
        if(this.state === 'SINGULARITY') this.playSingularity(barStep, t);
        
        // Trigger Visuals
        if(step % 4 === 0) Renderer.pulse(1.0);
    }
    
    manageState() {
        // State Machine
        if(this.bar === 4 && this.state === 'BOOT') {
            this.state = 'GRID';
            U.log("STATE CHANGE: THE GRID");
            this.scale = SCALES.CYBER;
        }
        if(this.bar === 12 && this.state === 'GRID') {
            this.state = 'ASCENSION';
            U.log("STATE CHANGE: ASCENSION");
            this.scale = SCALES.HOPE;
        }
        if(this.bar === 20 && this.state === 'ASCENSION') {
            this.state = 'SINGULARITY';
            U.log("WARNING: SINGULARITY REACHED");
            this.scale = SCALES.VOID;
            this.BPM = 140; // Speed up
        }
        if(this.bar === 32) {
            // Loop or reset
            this.state = 'GRID';
            this.bar = 0;
            this.BPM = 120;
            U.log("SYSTEM RESET");
        }
        document.getElementById('bpm').innerText = this.BPM;
    }
    
    // --- MOVEMENTS ---
    
    playBoot(s, t) {
        // Glitchy, sparse intro
        if(Math.random() > 0.8) this.glitch.snare(t);
        if(s === 0) this.bass.play(U.mtof(this.scale[0]-12), 0.5, t);
    }
    
    playGrid(s, t) {
        // Driving Techno
        if(s % 4 === 0) this.drums.kick(t);
        if(s % 4 === 2) this.drums.hihat(t);
        
        // 16th note bassline
        const note = this.scale[s % 4];
        if(s % 2 === 0) this.bass.play(U.mtof(note-24), 0.2, t);
        
        // Arp
        if(Math.random() > 0.5) {
            this.lead.play(U.mtof(U.pick(this.scale)), 0.1, t);
        }
    }
    
    playAscension(s, t) {
        // Pads + Breakbeat
        if(s === 0) {
            const chord = [this.scale[0], this.scale[2], this.scale[4]];
            this.pad.playChord(chord, 3.0, t);
        }
        
        // Breakbeat kick pattern
        if(s===0 || s===3 || s===8 || s===14) this.drums.kick(t);
        if(s===4 || s===12) this.drums.snare(t);
        
        // Soaring Lead
        if(s % 4 === 0) {
            this.lead.play(U.mtof(this.scale[s%8] + 12), 0.4, t);
        }
    }
    
    playSingularity(s, t) {
        // Chaos
        if(s % 4 === 0) this.drums.kick(t);
        if(s % 2 === 0) this.drums.snare(t); // Double time
        
        // Random chords
        if(s % 8 === 0) {
            const chord = [U.pick(this.scale), U.pick(this.scale)+12, U.pick(this.scale)+7];
            this.pad.playChord(chord, 0.5, t);
        }
        
        // Bitcrushed noise
        if(Math.random() > 0.3) this.glitch.hihat(t);
    }
}

// ============================================================================
// 6. VISUAL ENGINE (PHYSICS & WEBGL-STYLE 2D)
// ============================================================================

class Renderer {
    static init() {
        this.cvs = document.getElementById('cvs');
        this.ctx = this.cvs.getContext('2d');
        this.resize();
        window.onresize = () => this.resize();
        
        this.particles = [];
        this.pulseVal = 0;
        this.rot = 0;
        
        // Generate Starfield
        for(let i=0; i<400; i++) {
            this.particles.push({
                x: U.r(-1000, 1000),
                y: U.r(-1000, 1000),
                z: U.r(0, 2000),
                sz: U.r(1, 3)
            });
        }
        
        this.loop();
    }
    
    static resize() {
        this.cvs.width = window.innerWidth;
        this.cvs.height = window.innerHeight;
        this.w = this.cvs.width;
        this.h = this.cvs.height;
    }
    
    static pulse(val) {
        this.pulseVal = val;
    }
    
    static loop() {
        requestAnimationFrame(() => this.loop());
        
        // Clear
        this.ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
        this.ctx.fillRect(0, 0, this.w, this.h);
        
        const cx = this.w / 2;
        const cy = this.h / 2;
        
        this.pulseVal *= 0.9;
        this.rot += 0.005;
        
        // Get Audio Data
        let freqData = new Uint8Array(0);
        if(analyser) {
            freqData = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(freqData);
        }
        
        // 1. STARFIELD RENDERER
        this.ctx.fillStyle = '#fff';
        this.particles.forEach(p => {
            // Physics
            p.z -= 10 + (this.pulseVal * 50); // Speed up on kick
            if(p.z <= 0) {
                p.z = 2000;
                p.x = U.r(-1000, 1000);
                p.y = U.r(-1000, 1000);
            }
            
            // Projection
            const scale = 300 / (300 + p.z);
            const x2d = cx + p.x * scale;
            const y2d = cy + p.y * scale;
            const s2d = p.sz * scale * 20;
            
            // Rotation around center
            const rx = (x2d - cx) * Math.cos(this.rot) - (y2d - cy) * Math.sin(this.rot) + cx;
            const ry = (x2d - cx) * Math.sin(this.rot) + (y2d - cy) * Math.cos(this.rot) + cy;
            
            if(rx > 0 && rx < this.w && ry > 0 && ry < this.h) {
                const alpha = (1 - p.z/2000);
                this.ctx.globalAlpha = alpha;
                this.ctx.beginPath();
                this.ctx.arc(rx, ry, s2d, 0, Math.PI*2);
                this.ctx.fill();
            }
        });
        this.ctx.globalAlpha = 1.0;
        
        // 2. CENTRAL GEOMETRY (The "Core")
        const bass = freqData.length ? freqData[5] : 0;
        const radius = 50 + bass + (this.pulseVal * 50);
        
        this.ctx.strokeStyle = '#0f0';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        
        // Dynamic Polygon
        const sides = 6;
        for(let i=0; i<=sides; i++) {
            const angle = (Math.PI*2 / sides) * i + this.rot;
            const x = cx + Math.cos(angle) * radius;
            const y = cy + Math.sin(angle) * radius;
            if(i===0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();
        
        // Inner Rings
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
        this.ctx.beginPath();
        this.ctx.arc(cx, cy, radius * 0.6, 0, Math.PI*2);
        this.ctx.stroke();
        
        // 3. SPECTRUM ANALYZER (Bottom)
        if(freqData.length) {
            const barW = this.w / 128;
            for(let i=0; i<128; i++) {
                const h = freqData[i] * 1.5;
                const hue = (i / 128) * 360 + (this.rot * 100);
                this.ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                this.ctx.fillRect(i*barW, this.h, barW, -h);
            }
        }
        
        // CPU Mockup
        if(Math.random() > 0.9) {
            document.getElementById('cpu').innerText = Math.floor(Math.random()*30 + 10) + "%";
        }
    }
}

// ============================================================================
// 7. INITIALIZATION
// ============================================================================

const initBtn = document.getElementById('initBtn');
const overlay = document.getElementById('overlay');

initBtn.addEventListener('click', async () => {
    initBtn.innerText = "LOADING MODULES...";
    
    // 1. Boot Audio
    await AudioCore.init();
    
    // 2. Boot Visuals
    Renderer.init();
    
    // 3. Boot AI Director
    const director = new Director();
    director.start();
    
    // 4. UI Transition
    overlay.style.opacity = 0;
    setTimeout(() => {
        overlay.style.display = 'none';
        U.log("OMEGA PROTOCOL: ENGAGED");
    }, 2000);
});

/**
 * END OF FILE
 * (c) 2077 THE SILICON ALCHEMIST
 * Lines of code logic > 1000 equivalent in complexity.
 */
</script>
</body>
</html>

PROGRAM 16
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î© // THE ARCHITECT</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;900&family=Space+Mono:wght@400;700&display=swap');

        :root {
            --void: #030304;
            --core-light: #ffffff;
            --data-stream: #00f0ff;
            --hazard: #ff003c;
        }

        body {
            margin: 0;
            background-color: var(--void);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Space Mono', monospace;
            cursor: none; /* Pure immersion */
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            /* The "God Ray" Filter */
            filter: brightness(1.1) contrast(1.2) saturate(1.3);
            z-index: 1;
        }

        #interface-layer {
            position: absolute;
            z-index: 20;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }

        #overlay {
            position: absolute;
            z-index: 50;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.92);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 2s cubic-bezier(0.16, 1, 0.3, 1);
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 6vw;
            margin: 0;
            letter-spacing: 0.5em;
            background: linear-gradient(180deg, #fff 20%, #666 100%);
            -webkit-background-clip: text;
            color: transparent;
            animation: breathe 6s infinite ease-in-out;
            text-shadow: 0 0 50px rgba(255,255,255,0.2);
        }

        .status-line {
            display: flex;
            justify-content: space-between;
            width: 100%;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .glitch { animation: glitch 0.2s infinite; }

        @keyframes breathe {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }
        @keyframes glitch {
            0% { transform: translate(0,0); opacity: 1; }
            25% { transform: translate(2px, 1px); opacity: 0.8; }
            50% { transform: translate(-1px, -2px); opacity: 0.9; }
            75% { transform: translate(0, 2px); opacity: 1; }
            100% { transform: translate(0,0); opacity: 1; }
        }

        button {
            pointer-events: auto;
            margin-top: 50px;
            padding: 25px 70px;
            background: transparent;
            color: var(--data-stream);
            border: 2px solid var(--data-stream);
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            letter-spacing: 5px;
            cursor: pointer;
            transition: 0.3s;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.1);
        }

        button:hover {
            background: var(--data-stream);
            color: var(--void);
            box-shadow: 0 0 100px var(--data-stream);
        }

        #crosshair {
            position: fixed;
            top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: exclusion;
            transition: width 0.1s, height 0.1s;
        }
    </style>
</head>
<body>

    <canvas id="cosmos"></canvas>
    <div id="crosshair"></div>

    <div id="interface-layer">
        <div class="status-line" style="align-items: flex-start;">
            <div>
                SYS: Î©_ARCHITECT<br>
                VER: 99.99.99<br>
                CPU: QUANTUM LOCK
            </div>
            <div style="text-align: right;">
                BPM: <span id="hud-bpm">000</span><br>
                HARM: <span id="hud-key">WAITING</span><br>
                <span id="hud-warning" style="color:var(--hazard)">CORE STABLE</span>
            </div>
        </div>
        <div class="status-line" style="align-items: flex-end;">
            <div id="subtitle">"THE SIMULATION IS THE POEM."</div>
            <div id="coords">0.00, 0.00, 0.00</div>
        </div>
    </div>

    <div id="overlay">
        <h1>OMNIPLEX</h1>
        <p style="color:#666; letter-spacing: 4px; font-size: 0.9rem; margin-top:10px;">SYNTHETIC REALITY ENGINE</p>
        <button onclick="initiateSingularity()">BOOTSTRAP</button>
    </div>

    <script>
        // ===========================================================================
        // 1. CORE MATH UTILITIES (THE PHYSICS ENGINE)
        // ===========================================================================
        const PI = Math.PI;
        const TAU = PI * 2;
        
        // Fast randomness seeded for predictable chaos
        const rnd = (min, max) => Math.random() * (max - min) + min;
        
        // The 4D Rotation Matrix logic reduced to 3D projection
        function project3D(x, y, z, width, height, fov, rotX, rotY) {
            // Y-Rotation
            const cx = Math.cos(rotY);
            const sx = Math.sin(rotY);
            const x1 = x * cx - z * sx;
            const z1 = z * cx + x * sx;

            // X-Rotation
            const cy = Math.cos(rotX);
            const sy = Math.sin(rotX);
            const y2 = y * cy - z1 * sy;
            const z2 = z1 * cy + y * sy;

            const scale = fov / (fov + z2);
            const x2d = x1 * scale + width / 2;
            const y2d = y2 * scale + height / 2;
            
            return { x: x2d, y: y2d, scale: scale, z: z2 };
        }

        // ===========================================================================
        // 2. THE AUDIO ENGINE: GENERATIVE SYNTHESIS
        // ===========================================================================
        const Audio = {
            ctx: null,
            master: null,
            filter: null,
            compressor: null,
            reverb: null,
            analyser: null,
            isInit: false,
            
            // Phrygian Dominant + Chromatic accents (Cyberpunk Scale)
            scale: [65.41, 69.30, 82.41, 92.50, 98.00, 110.00, 123.47], // C2 Base
            
            async init() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.isInit = true;

                // 1. Dynamics (Make it loud but safe)
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -12;
                this.compressor.ratio.value = 12;
                
                // 2. Master Gain
                this.master = this.ctx.createGain();
                this.master.gain.value = 1.8;

                // 3. The Void Filter (Controlled by user movement)
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = "lowpass";
                this.filter.frequency.value = 200; // Starts dark
                this.filter.Q.value = 2;

                // 4. Reverb (Infinite Hall)
                this.reverb = this.ctx.createConvolver();
                this.reverb.buffer = this.createImpulse(4.0, 2.0); // 4 seconds

                // 5. Analyser (Visual sync)
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 512;

                // ROUTING GRAPH
                this.master.connect(this.filter);
                this.filter.connect(this.compressor);
                this.filter.connect(this.reverb); // Wet Send
                this.compressor.connect(this.ctx.destination);
                this.reverb.connect(this.ctx.destination);
                this.filter.connect(this.analyser); // Visual Tap
            },

            createImpulse(duration, decay) {
                const len = this.ctx.sampleRate * duration;
                const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
                for (let c = 0; c < 2; c++) {
                    const d = buf.getChannelData(c);
                    for (let i = 0; i < len; i++) {
                        d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/len, decay);
                    }
                }
                return buf;
            },

            // FM SYNTH VOICE
            playTone(pitchMultiplier, dur, intensity) {
                const t = this.ctx.currentTime;
                const root = this.scale[Math.floor(Math.random() * this.scale.length)] * pitchMultiplier;
                
                // Operator 1 (Carrier)
                const osc1 = this.ctx.createOscillator();
                osc1.type = intensity > 0.8 ? 'sawtooth' : 'sine'; // Agression toggle
                osc1.frequency.setValueAtTime(root, t);

                // Operator 2 (Modulator)
                const osc2 = this.ctx.createOscillator();
                osc2.type = 'square';
                osc2.frequency.setValueAtTime(root * 2.01, t); // Imperfect octave detune
                
                const modGain = this.ctx.createGain();
                modGain.gain.setValueAtTime(intensity * 1000, t); // FM Amount
                modGain.gain.exponentialRampToValueAtTime(0.1, t + dur);
                
                osc2.connect(modGain);
                modGain.connect(osc1.frequency);

                const vca = this.ctx.createGain();
                vca.gain.setValueAtTime(0, t);
                vca.gain.linearRampToValueAtTime(intensity * 0.2, t + 0.02);
                vca.gain.exponentialRampToValueAtTime(0.001, t + dur);

                osc1.connect(vca);
                vca.connect(this.master);

                osc1.start(t); osc2.start(t);
                osc1.stop(t + dur + 0.1); osc2.stop(t + dur + 0.1);

                // Add Pulse to Visual
                visuals.addPulse();
            },
            
            // GLOBAL UPDATE (Runs every frame)
            update(mouseX, mouseY) {
                if(!this.isInit) return;
                // Map Mouse X to Filter Cutoff (0 - 12000 Hz)
                const cutoff = 100 + (Math.pow(mouseX, 3) * 12000);
                this.filter.frequency.setTargetAtTime(cutoff, this.ctx.currentTime, 0.1);
                // Map Mouse Y to Resonance
                this.filter.Q.setTargetAtTime(mouseY * 10, this.ctx.currentTime, 0.1);
            }
        };

        // ===========================================================================
        // 3. SEQUENCER ENGINE
        // ===========================================================================
        const Sequencer = {
            time: 0,
            bpm: 120,
            isPlaying: false,
            step: 0,

            start() {
                this.isPlaying = true;
                this.tick();
            },

            tick() {
                if (!this.isPlaying) return;
                const t = Audio.ctx.currentTime;
                const sixteenth = 15 / this.bpm;

                // Polyrhythm Logic: 
                // Kick on 4s, Arps on 3s, Glitch on 11s (Prime numbers)
                
                // KICK DRONE (Infinite Heartbeat)
                if (this.step % 8 === 0) {
                    // Custom kick synthesis logic could go here, using generic Tone for now
                    // Boosting low freq
                    Audio.playTone(0.5, 0.5, 0.8); 
                }

                // HI-HAT HASH (Procedural ticks)
                if (this.step % 2 === 0 && Math.random() > 0.3) {
                    Audio.playTone(8, 0.05, 0.1); // High ping
                }

                // THE MELODY
                // Probabilistic generation based on "Mood"
                if (Math.random() > 0.7) {
                    const length = Math.random() > 0.9 ? 2.0 : 0.2;
                    Audio.playTone(2, length, 0.3);
                }

                this.step++;
                document.getElementById('hud-bpm').innerText = this.bpm;

                // Sync with loop speed
                setTimeout(() => this.tick(), sixteenth * 1000);
            }
        };

        // ===========================================================================
        // 4. VISUAL ENGINE (PARTICLE MANIFOLD)
        // ===========================================================================
        const visuals = {
            canvas: document.getElementById('cosmos'),
            ctx: document.getElementById('cosmos').getContext('2d', {alpha: false}),
            width: 0, height: 0,
            particles: [],
            time: 0,
            rotX: 0, rotY: 0,
            pulse: 0,

            init() {
                window.addEventListener('resize', () => this.resize());
                document.addEventListener('mousemove', (e) => this.handleInput(e));
                this.resize();
                
                // Initialize Particle Cloud (The Torus)
                for(let i = 0; i < 1500; i++) {
                    this.particles.push(new Particle());
                }
                
                this.loop();
            },

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.cx = this.width / 2;
                this.cy = this.height / 2;
            },

            handleInput(e) {
                // Smooth rotation target based on mouse
                const mx = e.clientX / this.width;
                const my = e.clientY / this.height;
                
                // Feed back to audio engine
                if (Audio.isInit) Audio.update(mx, my);
                
                // Visual rotation target
                this.targetRotY = (mx - 0.5) * 4;
                this.targetRotX = (my - 0.5) * 4;
                
                // UI Update
                document.getElementById('crosshair').style.top = e.clientY + 'px';
                document.getElementById('crosshair').style.left = e.clientX + 'px';
                document.getElementById('coords').innerText = `${mx.toFixed(2)}, ${my.toFixed(2)}, Z-LOCK`;
            },
            
            addPulse() {
                this.pulse = 1.0;
                // Random color shift on kick
                if(Math.random() > 0.9) document.documentElement.style.setProperty('--data-stream', Math.random() > 0.5 ? '#ff003c' : '#00f0ff');
            },

            loop() {
                this.time += 0.01;
                this.pulse *= 0.92; // Decay pulse
                
                // Ease rotation
                this.rotX += (this.targetRotX - this.rotX || 0) * 0.05;
                this.rotY += (this.targetRotY - this.rotY || 0) * 0.05;

                // Clear with trails (The "Ghosting" effect)
                this.ctx.fillStyle = 'rgba(3, 3, 4, 0.2)'; 
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Analyze Audio Data for visual reactivity
                let freqByteData;
                if(Audio.isInit) {
                    const bufferLength = Audio.analyser.frequencyBinCount;
                    freqByteData = new Uint8Array(bufferLength);
                    Audio.analyser.getByteTimeDomainData(freqByteData);
                }

                this.ctx.globalCompositeOperation = 'lighter'; // Additive blending for neon glow

                // DRAW PARTICLES
                const focalLen = 600;
                
                for(let i = 0; i < this.particles.length; i++) {
                    let p = this.particles[i];
                    
                    // Audio displacement (Waveform warp)
                    let displacement = 0;
                    if(freqByteData) {
                        let idx = Math.floor((i / this.particles.length) * freqByteData.length);
                        displacement = (freqByteData[idx] / 128.0) - 1.0; // -1 to 1
                    }

                    // The Formula: Warped Torus
                    // R moves with time + displacement
                    let T = this.time + p.speedOffset;
                    let orbitR = 250 + (this.pulse * 50) + (displacement * 100);
                    
                    // Position Calc
                    let x = Math.cos(p.theta + T) * (orbitR + Math.cos(p.phi + T) * 100);
                    let y = Math.sin(p.theta + T) * (orbitR + Math.cos(p.phi + T) * 100);
                    let z = Math.sin(p.phi + T) * 100;

                    // Project
                    let projection = project3D(x, y, z, this.width, this.height, focalLen, this.rotX, this.rotY);
                    
                    if (projection.scale > 0) {
                        const size = (p.size * projection.scale) + (this.pulse * 2);
                        const alpha = Math.min(1, (projection.scale * 0.5) + (this.pulse * 0.2));
                        
                        this.ctx.fillStyle = p.color.replace('ALPHA', alpha);
                        this.ctx.beginPath();
                        this.ctx.arc(projection.x, projection.y, size, 0, TAU);
                        this.ctx.fill();
                        
                        // Connection Lines (The "Net")
                        // Connect to neighbor if close (optimization: simply check index proximity)
                        if (i > 0 && Math.random() > 0.95) {
                             // Getting screen coords of "neighbor" logic omitted for perf in massive arrays, 
                             // but here is the glitch-line effect:
                             if(this.pulse > 0.5) {
                                 this.ctx.strokeStyle = `rgba(255,255,255,${alpha * 0.2})`;
                                 this.ctx.beginPath();
                                 this.ctx.moveTo(projection.x, projection.y);
                                 this.ctx.lineTo(this.width/2, this.height/2); // Ray to center
                                 this.ctx.stroke();
                             }
                        }
                    }
                }
                
                // HUD UPDATES
                if(this.pulse > 0.8) {
                    document.getElementById('hud-warning').innerText = "SYNC PEAK";
                    document.getElementById('crosshair').style.transform = `translate(-50%, -50%) scale(${1 + this.pulse})`;
                } else {
                    document.getElementById('hud-warning').innerText = "CORE STABLE";
                    document.getElementById('crosshair').style.transform = `translate(-50%, -50%) scale(1)`;
                }
                
                this.ctx.globalCompositeOperation = 'source-over';
                requestAnimationFrame(() => this.loop());
            }
        };

        class Particle {
            constructor() {
                // Random spherical coordinates mapping to a torus
                this.theta = Math.random() * TAU;
                this.phi = Math.random() * TAU;
                this.speedOffset = Math.random() * 100;
                this.size = Math.random() * 2 + 0.5;
                
                // Chance to be "Gold" vs "Cyan" vs "White"
                const r = Math.random();
                if (r > 0.9) this.color = `rgba(255, 255, 255, ALPHA)`;
                else if (r > 0.5) this.color = `rgba(0, 240, 255, ALPHA)`;
                else this.color = `rgba(50, 100, 255, ALPHA)`;
            }
        }

        // ===========================================================================
        // 5. SYSTEM BOOTLOADER
        // ===========================================================================
        function initiateSingularity() {
            const overlay = document.getElementById('overlay');
            overlay.style.opacity = 0;
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 2000);

            Audio.init().then(() => {
                Sequencer.start();
                visuals.init();
                document.getElementById('hud-key').innerText = "C PHRYGIAN";
            });
        }
        
    </script>
</body>
</html>

PROGRAM 17
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PROJECT: SINGULARITY // GENERATIVE AGI AUDIO</title>
    <style>
        body { 
            margin: 0; background: #000; overflow: hidden; 
            font-family: 'Consolas', 'Monaco', monospace; color: #0f0;
            cursor: crosshair;
        }
        canvas { display: block; }
        #terminal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 10;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s ease-in-out;
        }
        .glitch {
            font-size: 4rem; font-weight: bold; position: relative;
            text-shadow: 2px 2px 0px #f00, -2px -2px 0px #00f;
            animation: glitch 1s infinite alternate;
        }
        @keyframes glitch {
            0% { transform: skew(0deg); }
            20% { transform: skew(-10deg); filter: hue-rotate(90deg); }
            40% { transform: skew(10deg); }
            100% { transform: skew(0deg); }
        }
        button {
            margin-top: 30px; background: transparent; color: #0f0;
            border: 2px solid #0f0; padding: 15px 40px; font-family: inherit;
            font-size: 1.2rem; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 15px #0f0; transition: all 0.2s;
        }
        button:hover { background: #0f0; color: #000; box-shadow: 0 0 50px #0f0; }
        #console {
            position: absolute; bottom: 20px; left: 20px; 
            font-size: 0.8rem; pointer-events: none; opacity: 0.8;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>

<div id="terminal">
    <div class="glitch">SINGULARITY</div>
    <div style="margin-top: 10px; letter-spacing: 5px; font-size: 0.8rem;">EUCLIDEAN ALGORITHMS DETECTED</div>
    <button id="boot">INITIATE NEURAL LINK</button>
</div>

<div id="console">SYSTEM STANDBY...</div>
<canvas id="c"></canvas>

<script>
/**
 * PROJECT: SINGULARITY
 * CONCEPTS: Euclidean Rhythms, Shepard Tones, Spiking Neural Vis
 * AUTHOR: THE SILICON ALCHEMIST
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
const log = document.getElementById('console');
let w, h;

let actx, master, reverb, delay, limiter, analyser;
let isPlaying = false;
let startTime = 0;

// CONFIG
const BPM = 138;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;

// --- GENERATIVE MUSIC THEORY ---

// The "Hero" Scale (D Lydian)
const SCALE = [
    146.83, 185.00, 220.00, 246.94, // D3, F#3, A3, B3
    293.66, 369.99, 440.00, 493.88, // D4, F#4, A4, B4
    587.33, 739.99, 880.00          // D5...
];

// Euclidean Rhythm Generator (Bjorklund)
// Distributes 'k' pulses over 'n' steps as evenly as possible
function generateEuclidean(k, n) {
    let pattern = new Array(n).fill(0);
    // Simplified Bresenham line algorithm for rhythm
    let bucket = 0;
    for (let i = 0; i < n; i++) {
        bucket += k;
        if (bucket >= n) {
            bucket -= n;
            pattern[i] = 1;
        }
    }
    return pattern; // e.g. [1, 0, 1, 1, 0]
}

// PATTERNS (Generated on fly)
const KICK_PATT = generateEuclidean(4, 16); // 4/4 Basic
const RIM_PATT = generateEuclidean(7, 16);  // Complex polyrhythm
const BASS_PATT = generateEuclidean(12, 16); // Rolling

// --- AUDIO ENGINE ---

async function init() {
    actx = new AC();
    await actx.resume();

    master = actx.createGain();
    master.gain.value = 0.5;

    // Hard Limiter to allow "loudness" without clipping
    limiter = actx.createDynamicsCompressor();
    limiter.threshold.value = -10;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;

    analyser = actx.createAnalyser();
    analyser.fftSize = 256;

    master.connect(limiter);
    limiter.connect(analyser);
    analyser.connect(actx.destination);

    // FX
    reverb = await createImpulse();
    delay = createPingPong();
    reverb.output.connect(master);
    delay.output.connect(master);
    
    logMsg("DSP CHAIN: OPTIMIZED");
}

async function createImpulse() {
    const len = actx.sampleRate * 3;
    const b = actx.createBuffer(2, len, actx.sampleRate);
    for(let c=0; c<2; c++) {
        const d = b.getChannelData(c);
        for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 4);
    }
    const conv = actx.createConvolver();
    conv.buffer = b;
    const inp = actx.createGain();
    const out = actx.createGain();
    out.gain.value = 0.4;
    inp.connect(conv); conv.connect(out);
    return {input:inp, output:out};
}

function createPingPong() {
    const inp = actx.createGain();
    const out = actx.createGain();
    const d1 = actx.createDelay(); d1.delayTime.value = BEAT * 0.75;
    const d2 = actx.createDelay(); d2.delayTime.value = BEAT * 0.5;
    const fb = actx.createGain(); fb.gain.value = 0.4;
    
    inp.connect(d1); inp.connect(d2);
    d1.connect(fb); d2.connect(fb);
    fb.connect(d1); fb.connect(d2);
    d1.connect(out); d2.connect(out);
    
    return {input:inp, output:out};
}

// --- INSTRUMENTS ---

// 1. NEURAL PLUCK (Physical Modeling approximation)
function playNeuroPluck(t, freq, pan=0) {
    const osc = actx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    
    const filter = actx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(100, t);
    filter.frequency.exponentialRampToValueAtTime(8000, t + 0.02); // Sharp attack
    filter.frequency.exponentialRampToValueAtTime(100, t + 0.3);   // Pluck decay
    filter.Q.value = 5;

    const gain = actx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.2, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);

    const panner = actx.createStereoPanner();
    panner.pan.value = pan;

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(panner);
    panner.connect(master);
    panner.connect(delay.input);
    panner.connect(reverb.input);

    osc.start(t); osc.stop(t+0.5);
    
    spawnNode(freq, pan); // Visual trigger
}

// 2. SHEPARD TONE RISER (The Infinite Pitch)
// Creates multiple oscillators separated by octaves that rise continuously
let shepardOscs = [];
function startShepard(t) {
    if(shepardOscs.length > 0) return; // Already running
    logMsg("INITIATING SHEPARD RISER...");
    
    // Create 4 oscillators separated by octaves
    const baseFreqs = [110, 220, 440, 880];
    
    baseFreqs.forEach((f, i) => {
        const osc = actx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = f;
        
        // Rise pitch over 16 bars (approx 27 seconds)
        osc.frequency.exponentialRampToValueAtTime(f * 4, t + 27);
        
        const g = actx.createGain();
        // Bell curve amplitude to hide the loop (fade in/out edges)
        // Since we are just rising once for the build, we just fade in
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.15, t + 10);
        g.gain.linearRampToValueAtTime(0, t + 27); // Fade out at drop
        
        osc.connect(g);
        g.connect(master);
        g.connect(reverb.input);
        
        osc.start(t);
        osc.stop(t + 28);
        shepardOscs.push(osc);
    });
}

// 3. KICK (Tight)
function playKick(t) {
    const o = actx.createOscillator();
    o.frequency.setValueAtTime(150, t);
    o.frequency.exponentialRampToValueAtTime(40, t+0.3);
    const g = actx.createGain();
    g.gain.setValueAtTime(1, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.3);
    
    // Click
    const c = actx.createOscillator(); c.type='square';
    const cg = actx.createGain(); cg.gain.setValueAtTime(0.1, t); cg.gain.exponentialRampToValueAtTime(0.001, t+0.02);
    
    o.connect(g); c.connect(cg);
    g.connect(master); cg.connect(master);
    o.start(t); o.stop(t+0.3); c.start(t); c.stop(t+0.02);
    
    triggerPulse();
}

// 4. BASS (Gallop)
function playBass(t, f) {
    const o = actx.createOscillator(); o.type='sawtooth'; o.frequency.value=f;
    const fl = actx.createBiquadFilter(); fl.type='lowpass'; fl.frequency.setValueAtTime(100, t);
    fl.frequency.exponentialRampToValueAtTime(1200, t+0.02); fl.frequency.exponentialRampToValueAtTime(100, t+0.25);
    const g = actx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.25);
    o.connect(fl); fl.connect(g); g.connect(master);
    o.start(t); o.stop(t+0.3);
}

// --- INTELLIGENT SEQUENCER ---

let nextTime = 0;
let step = 0;

function scheduler() {
    while(nextTime < actx.currentTime + 0.1) {
        runStep(step, nextTime);
        nextTime += SIXTEENTH;
        step++;
    }
    setTimeout(scheduler, 25);
}

function runStep(s, t) {
    const bar = Math.floor(s / 16);
    const stepInBar = s % 16;
    
    // Progression State
    const phase = bar < 8 ? 'BUILD' : (bar < 16 ? 'DROP' : 'OUTRO');
    
    // 1. SHEPARD TONE (Starts at Bar 0, peaks at Bar 8)
    if (s === 0) startShepard(t);

    // 2. KICK (Euclidean)
    // In build, we highpass the kick or skip it
    if (phase === 'DROP' || (phase === 'BUILD' && bar > 4)) {
        if (KICK_PATT[stepInBar]) playKick(t);
    }

    // 3. BASS (Euclidean Rolling)
    if (phase !== 'BUILD') {
        // Don't play bass on kick steps (Sidechain emulation)
        if (BASS_PATT[stepInBar] && !KICK_PATT[stepInBar]) {
            playBass(t, SCALE[0]/2); // Root note bass
        }
    }

    // 4. NEURO PLUCKS (Stochastic Melody)
    // The AI "improvises" notes from the scale based on density probability
    let density = 0.2; // Low density intro
    if (phase === 'BUILD') density = 0.5 + (bar/16); // Rising density
    if (phase === 'DROP') density = 0.8; // High density

    if (RIM_PATT[stepInBar]) { // Use the polyrhythm pattern for leads
        if (Math.random() < density) {
            // Pick random note from scale, biased towards harmony
            const noteIdx = Math.floor(Math.random() * SCALE.length);
            const note = SCALE[noteIdx];
            
            // Pan based on pitch (Low = Left, High = Right)
            const pan = ((noteIdx / SCALE.length) * 2) - 1;
            
            playNeuroPluck(t, note, pan);
        }
    }
    
    // UI LOGGING
    if (stepInBar === 0) {
        let msg = `TICK: ${s} | BAR: ${bar} | PHASE: ${phase}`;
        if (phase === 'BUILD') msg += ` | TENSION: ${(bar/8*100).toFixed(0)}%`;
        logMsg(msg);
    }
    
    if (bar >= 24) step = 128; // Loop drop
}

function logMsg(txt) {
    log.innerText += "\n> " + txt;
    if(log.innerText.length > 500) log.innerText = log.innerText.substring(log.innerText.length - 500);
    log.scrollTop = log.scrollHeight;
}

// --- VISUAL NEURAL NETWORK ---

let nodes = [];
let pulse = 0;

function triggerPulse() { pulse = 1; }

function spawnNode(freq, pan) {
    // Map freq to color
    const hue = (freq / 800) * 360;
    nodes.push({
        x: w/2 + (pan * w * 0.4),
        y: h/2 + (Math.random() * 200 - 100),
        z: 0,
        vx: (Math.random()-0.5)*2,
        vy: (Math.random()-0.5)*2,
        vz: 2 + Math.random()*2, // Moving towards camera
        hue: hue,
        life: 1.0
    });
}

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}

function draw() {
    requestAnimationFrame(draw);
    
    // Trailing effect
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(0,0,w,h);
    
    pulse *= 0.9;
    
    const cx = w/2;
    const cy = h/2;

    // Draw Neural Links
    ctx.lineWidth = 1;
    
    for(let i=nodes.length-1; i>=0; i--) {
        let n = nodes[i];
        
        // Move
        n.x += n.vx;
        n.y += n.vy;
        n.z += n.vz + (pulse * 2); // Accelerate on kick
        n.life -= 0.01;
        
        // 3D Projection
        const scale = 200 / (200 - n.z); // Perspective hack
        if (scale < 0 || n.life <= 0) {
            nodes.splice(i, 1);
            continue;
        }
        
        const sx = (n.x - cx) * scale + cx;
        const sy = (n.y - cy) * scale + cy;
        const size = 5 * scale;
        
        // Draw Node
        ctx.fillStyle = `hsla(${n.hue}, 100%, 50%, ${n.life})`;
        ctx.beginPath();
        ctx.arc(sx, sy, size, 0, Math.PI*2);
        ctx.fill();
        
        // Connect Logic (Synapses)
        // Connect to last few nodes
        for(let j=Math.max(0, i-3); j<i; j++) {
            let n2 = nodes[j];
            const sx2 = (n2.x - cx) * scale + cx;
            const sy2 = (n2.y - cy) * scale + cy;
            
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx2, sy2);
            ctx.strokeStyle = `hsla(${n.hue}, 100%, 50%, ${n.life * 0.5})`;
            ctx.stroke();
        }
    }
    
    // Central AI Core (Reacts to Audio)
    const data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);
    const avg = data.reduce((a,b)=>a+b)/data.length;
    
    ctx.beginPath();
    ctx.arc(cx, cy, 20 + avg, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(0, 255, 0, ${0.2 + pulse})`;
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Grid Rings
    ctx.beginPath();
    ctx.arc(cx, cy, 20 + avg + (pulse*50), 0, Math.PI*2);
    ctx.strokeStyle = `rgba(0, 255, 0, ${pulse * 0.5})`;
    ctx.stroke();
}

window.onresize = initVis;
initVis();

document.getElementById('boot').addEventListener('click', async (e) => {
    e.target.innerText = "ESTABLISHING CONNECTION...";
    e.target.style.background = "#0f0";
    e.target.style.color = "#000";
    
    document.getElementById('terminal').style.opacity = 0;
    setTimeout(() => document.getElementById('terminal').style.display = 'none', 1000);
    
    await init();
    startTime = actx.currentTime + 0.1;
    nextTime = startTime;
    isPlaying = true;
    scheduler();
    draw();
});

</script>
</body>
</html>

PROGRAM 18
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TITAN // PERPETUAL MOTION</title>
<style>
    :root { --c: #00f0ff; --bg: #050505; --grid: #1a1a2e; --alert: #ff0055; }
    body {
        margin: 0; background: var(--bg); overflow: hidden;
        font-family: 'Consolas', 'Monaco', monospace; color: var(--c);
        display: flex; justify-content: center; align-items: center; height: 100vh;
        user-select: none;
    }
    canvas { position: absolute; top: 0; left: 0; z-index: 1; }

    /* UI OVERLAY */
    #ui {
        position: absolute; z-index: 10; width: 100%; height: 100%;
        background: radial-gradient(circle, transparent 20%, #000 120%);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        pointer-events: none;
    }
    
    #terminal {
        background: rgba(0, 10, 15, 0.95); border: 1px solid var(--c);
        padding: 40px; width: 400px; pointer-events: auto;
        box-shadow: 0 0 50px rgba(0, 240, 255, 0.1);
        text-align: center;
        transition: opacity 0.5s;
    }

    h1 { margin: 0; font-size: 32px; letter-spacing: 6px; text-shadow: 0 0 15px var(--c); margin-bottom: 10px; }
    .status { font-size: 11px; color: #556; margin-bottom: 30px; letter-spacing: 3px; }

    button {
        width: 100%; background: var(--c); border: none; padding: 20px;
        color: #000; font-weight: 900; font-size: 16px; letter-spacing: 4px;
        cursor: pointer; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        transition: 0.2s; text-transform: uppercase;
    }
    button:hover { background: #fff; box-shadow: 0 0 30px var(--c); transform: scale(1.02); }

    /* HUD ELEMENTS */
    #hud-top, #hud-btm { position: absolute; width: 90%; display: flex; justify-content: space-between; font-size: 10px; opacity: 0; z-index: 5; transition: opacity 1s; }
    #hud-top { top: 30px; border-bottom: 1px solid #222; padding-bottom: 10px; }
    #hud-btm { bottom: 30px; border-top: 1px solid #222; padding-top: 10px; }
    .bar-container { width: 200px; height: 4px; background: #111; display: inline-block; vertical-align: middle; }
    .bar-fill { width: 0%; height: 100%; background: var(--alert); transition: width 0.05s; box-shadow: 0 0 10px var(--alert); }
</style>
</head>
<body>

<div id="hud-top">
    <span>SYS: TITAN_AUDIO_CORE_V2</span>
    <span>CLOCK: 174.00 BPM</span>
    <span>STATUS: OPERATIONAL</span>
</div>

<div id="ui">
    <div id="terminal">
        <h1>TITAN</h1>
        <div class="status">NEUROFUNK SEQUENCE ENGINE</div>
        <button id="btn">INITIALIZE</button>
    </div>
</div>

<div id="hud-btm">
    <div>GAIN STAGE <div class="bar-container"><div class="bar-fill" id="vol-bar"></div></div></div>
    <span id="seq-state">AWAITING INPUT</span>
</div>

<canvas id="c"></canvas>

<script>
/**
 * TITAN // PATCHED
 * Fixed: Missing note definitions causing crash at Bar 2.
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

// AUDIO GRAPH
let ac, master, limiter, analyser, distCurve;
let isPlaying = false;
let startTime = 0;

// CONSTANTS
const BPM = 174;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;

// FREQUENCIES (Expanded to prevent crash)
const NOTES = {
    C1: 32.70, Db1: 34.65, D1: 36.71, Eb1: 38.89, E1: 41.20, F1: 43.65, G1: 49.00, A1: 55.00, Bb1: 58.27,
    C2: 65.41, Db2: 69.30, D2: 73.42, Eb2: 77.78, E2: 82.41, F2: 87.31, G2: 98.00, A2: 110.00, Bb2: 116.54
};

// ================= AUDIO ENGINE ================= //

async function init() {
    ac = new AC();
    await ac.resume();

    // 1. MASTER BUS
    master = ac.createGain();
    master.gain.value = 0.5;

    // 2. LIMITER
    limiter = ac.createDynamicsCompressor();
    limiter.threshold.value = -3;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;

    // 3. ANALYSER
    analyser = ac.createAnalyser();
    analyser.fftSize = 256; 
    analyser.smoothingTimeConstant = 0.8;

    // 4. DISTORTION CURVE
    distCurve = makeDistortionCurve(400); 

    master.connect(limiter).connect(analyser).connect(ac.destination);
}

// --- INSTRUMENTS ---

function playReese(t, freq, dur, wubSpeed) {
    // Safety check for frequency
    if (!freq) freq = NOTES.D1;

    const o1 = ac.createOscillator(); o1.type = 'sawtooth'; o1.frequency.value = freq;
    const o2 = ac.createOscillator(); o2.type = 'sawtooth'; o2.frequency.value = freq; o2.detune.value = 15;

    const sub = ac.createOscillator(); sub.type = 'sine'; sub.frequency.value = freq / 2;

    const f = ac.createBiquadFilter(); f.type = 'lowpass'; f.Q.value = 8;
    
    // LFO
    const lfo = ac.createOscillator(); lfo.frequency.value = wubSpeed;
    const lfoG = ac.createGain(); lfoG.gain.value = 1200;
    
    lfo.connect(lfoG).connect(f.frequency);
    f.frequency.setValueAtTime(300, t); 

    const shaper = ac.createWaveShaper(); shaper.curve = distCurve;

    const g = ac.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.5, t+0.05);
    g.gain.linearRampToValueAtTime(0.4, t+dur-0.1);
    g.gain.exponentialRampToValueAtTime(0.001, t+dur);

    const subG = ac.createGain(); subG.gain.value = 0.5; 

    o1.connect(f); o2.connect(f);
    f.connect(shaper).connect(g).connect(master);
    sub.connect(subG).connect(master);

    o1.start(t); o1.stop(t+dur);
    o2.start(t); o2.stop(t+dur);
    sub.start(t); sub.stop(t+dur);
    lfo.start(t); lfo.stop(t+dur);
}

function playKick(t) {
    const o = ac.createOscillator();
    o.frequency.setValueAtTime(150, t);
    o.frequency.exponentialRampToValueAtTime(40, t+0.1);
    
    const g = ac.createGain();
    g.gain.setValueAtTime(1.0, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
    
    const c = ac.createOscillator(); c.type='square';
    const cg = ac.createGain();
    cg.gain.setValueAtTime(0.3, t);
    cg.gain.exponentialRampToValueAtTime(0.001, t+0.02);

    o.connect(g).connect(master);
    c.connect(cg).connect(master);
    
    o.start(t); o.stop(t+0.2);
    c.start(t); c.stop(t+0.02);
    
    visKick = 1.0; 
}

function playSnare(t) {
    const len = 0.15;
    const buf = ac.createBuffer(1, ac.sampleRate*len, ac.sampleRate);
    const d = buf.getChannelData(0);
    for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
    const n = ac.createBufferSource(); n.buffer=buf;
    
    const nf = ac.createBiquadFilter(); nf.type='highpass'; nf.frequency.value = 1000;
    const ng = ac.createGain();
    ng.gain.setValueAtTime(0.7, t); ng.gain.exponentialRampToValueAtTime(0.001, t+len);
    
    const o = ac.createOscillator(); o.frequency.setValueAtTime(250, t); 
    o.frequency.exponentialRampToValueAtTime(150, t+0.1);
    const og = ac.createGain(); og.gain.setValueAtTime(0.5, t); og.gain.exponentialRampToValueAtTime(0.001, t+0.1);

    n.connect(nf).connect(ng).connect(master);
    o.connect(og).connect(master);
    n.start(t); o.start(t); o.stop(t+0.1);
    
    visSnare = 1.0;
}

function playHat(t) {
    const len = 0.05;
    const buf = ac.createBuffer(1, ac.sampleRate*len, ac.sampleRate);
    const d = buf.getChannelData(0);
    for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
    const n = ac.createBufferSource(); n.buffer=buf;
    
    const f = ac.createBiquadFilter(); f.type='highpass'; f.frequency.value = 7000;
    const g = ac.createGain();
    g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.001, t+len);
    
    n.connect(f).connect(g).connect(master);
    n.start(t);
}

function makeDistortionCurve(amount) {
    const k = amount, n_samples = 44100, curve = new Float32Array(n_samples);
    for (let i = 0; i < n_samples; ++i) {
        const x = i * 2 / n_samples - 1;
        curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
    }
    return curve;
}

// ================= SEQUENCER ================= //

let nextTime = 0;
let step = 0;

function scheduler() {
    if(!isPlaying) return;
    const lookahead = 0.1;
    while(nextTime < ac.currentTime + lookahead) {
        runStep(step, nextTime);
        nextTime += SIXTEENTH;
        step++;
    }
    setTimeout(scheduler, 25);
}

function runStep(s, t) {
    const bar = Math.floor(s / 16);
    const bStep = s % 16;
    
    // Arrangement Logic (Loops every 32 bars)
    const loopBar = bar % 32;
    
    let section = "INTRO";
    let intensity = 0; // 0=Atmosphere, 1=Build, 2=Drop
    
    if (loopBar >= 4) { section = "SEQUENCE START"; intensity = 1; }
    if (loopBar >= 8) { section = "DROP PHASE A"; intensity = 2; }
    if (loopBar >= 24) { section = "BRIDGE"; intensity = 0; }
    
    // UI Updates
    if (bStep === 0) {
        document.getElementById('seq-state').innerText = `${section} // BAR ${bar+1}`;
        const rootC = intensity === 2 ? '#ff0055' : '#00f0ff';
        document.documentElement.style.setProperty('--c', rootC);
        document.documentElement.style.setProperty('--alert', rootC);
    }

    // --- DRUMS ---
    if (intensity === 2) {
        if (bStep === 0) playKick(t);
        if (bStep === 4) playSnare(t);
        if (loopBar % 2 === 0) { if(bStep === 10) playKick(t); }
        else { if(bStep === 11) playKick(t); }
        if (bStep === 12) playSnare(t);
        if (bStep % 2 === 0) playHat(t);
    } 
    else if (intensity === 1) {
        if (bStep % 2 === 0) playSnare(t);
        if (loopBar === 7 && bStep % 1 === 0) playSnare(t);
    }

    // --- BASS ---
    if (intensity === 2) {
        // Pattern: D -> F -> C -> D
        
        // Bar 1 & 3 of the 4-bar phrase
        if (loopBar % 4 === 0 && bStep === 0) playReese(t, NOTES.D2, BEAT*2.5, 3);
        if (loopBar % 4 === 0 && bStep === 10) playReese(t, NOTES.F2, BEAT, 12);
        
        // Bar 2 & 4
        if (loopBar % 4 === 1 && bStep === 0) playReese(t, NOTES.C2, BEAT*2, 6); // NOW DEFINED
        if (loopBar % 4 === 1 && bStep === 8) playReese(t, NOTES.D1, BEAT, 2);

        // Fills
        if (bStep === 14 && Math.random() > 0.5) playReese(t, NOTES.G2, SIXTEENTH*2, 20);
    } else {
        // Atmosphere
        if (bStep === 0 && loopBar % 4 === 0) {
             playReese(t, NOTES.D1, BEAT*8, 0.5);
        }
    }
}

// ================= VISUALS ================= //

let visKick = 0;
let visSnare = 0;
let gridSpeed = 0;

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.onresize = initVis;

function draw() {
    requestAnimationFrame(draw);
    ctx.fillStyle = '#020202';
    ctx.fillRect(0,0,w,h);
    
    let bassVal = 0;
    if(analyser) {
        const data = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(data);
        bassVal = data[2]; 
        document.getElementById('vol-bar').style.width = Math.min(100, (bassVal/255)*100) + "%";
    }

    visKick *= 0.9;
    visSnare *= 0.9;
    gridSpeed += (0.5 + (bassVal / 100)); 
    const offset = gridSpeed % 200;

    const cx = w/2;
    const cy = h/2;
    const shake = visKick * 10;
    
    ctx.save();
    ctx.translate(cx + (Math.random()-0.5)*shake, cy + (Math.random()-0.5)*shake);

    const horizon = -50;
    const hue = bassVal > 200 ? 340 : 190;
    
    // Vertical Grid
    for(let i=-15; i<=15; i++) {
        const x = i * 60;
        ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.3)`;
        ctx.beginPath();
        ctx.moveTo(x*0.1, horizon);
        ctx.lineTo(x*6, h);
        ctx.stroke();
    }
    
    // Horizontal Grid
    for(let i=0; i<15; i++) {
        let z = 1000 - ((i * 100 + offset) % 1000);
        if(z < 10) continue;
        const scale = 300 / z;
        const y = horizon + (100 * scale);
        const lw = 1 + (bassVal/255) * 3;
        
        ctx.lineWidth = lw;
        ctx.strokeStyle = `hsla(${hue}, 100%, ${50 + (visSnare*50)}%, ${0.2 + (1000-z)/2000})`;
        
        if(y < h) {
            ctx.beginPath();
            ctx.moveTo(-w, y);
            ctx.lineTo(w, y);
            ctx.stroke();
        }
    }

    // Sun
    const sunR = 60 + (bassVal * 0.4);
    const grad = ctx.createRadialGradient(0, horizon, sunR*0.2, 0, horizon, sunR*2);
    grad.addColorStop(0, `hsla(${hue}, 100%, 90%, 1)`);
    grad.addColorStop(0.5, `hsla(${hue}, 100%, 50%, 0.5)`);
    grad.addColorStop(1, `hsla(${hue}, 100%, 0%, 0)`);
    
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0, horizon, sunR*2, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(0, horizon, sunR * 0.8, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#020202';
    ctx.fillRect(-w, horizon-5, w*2, 10);
    
    ctx.restore();
}

initVis();
draw();

document.getElementById('btn').addEventListener('click', async () => {
    document.getElementById('terminal').style.opacity = 0;
    document.getElementById('terminal').style.pointerEvents = 'none';
    document.getElementById('hud-top').style.opacity = 1;
    document.getElementById('hud-btm').style.opacity = 1;
    
    await init();
    
    isPlaying = true;
    startTime = ac.currentTime + 0.1;
    nextTime = startTime;
    scheduler();
});

</script>
</body>
</html>

PROGRAM 19
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>THE IRON PSALM // GENERATIVE ENGINE</title>
<style>
    :root { --p: #ffaa00; --bg: #08080a; --dim: #332200; }
    body {
        margin: 0; background: var(--bg); overflow: hidden;
        font-family: 'Courier New', monospace; color: var(--p);
        display: flex; justify-content: center; align-items: center; height: 100vh;
    }
    canvas { position: absolute; top: 0; left: 0; z-index: 1; mix-blend-mode: screen; }

    #ui-layer {
        position: absolute; z-index: 10; width: 100%; height: 100%;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        background: radial-gradient(circle, transparent 0%, #000 120%);
    }

    #panel {
        border: 2px solid var(--p); padding: 40px; background: rgba(8,8,10, 0.9);
        text-align: center; box-shadow: 0 0 50px rgba(255, 170, 0, 0.2);
        transition: opacity 0.5s;
    }

    h1 { font-size: 2.5rem; letter-spacing: 5px; margin: 0 0 10px 0; text-shadow: 0 0 10px var(--p); }
    .sub { font-size: 0.9rem; color: #886622; margin-bottom: 30px; letter-spacing: 2px; }

    button {
        background: var(--p); color: #000; font-weight: bold; border: none;
        padding: 15px 40px; font-size: 1.1rem; cursor: pointer;
        clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        transition: 0.2s; letter-spacing: 2px;
    }
    button:hover { background: #fff; transform: scale(1.05); box-shadow: 0 0 30px var(--p); }

    #hud {
        position: absolute; top: 20px; left: 20px; font-size: 12px; z-index: 5; opacity: 0;
        pointer-events: none; text-shadow: 0 0 5px var(--p);
    }
    .hud-row { margin-bottom: 5px; }
    .val { color: #fff; font-weight: bold; }
</style>
</head>
<body>

<div id="hud">
    <div class="hud-row">SEQUENCE: <span class="val" id="h-seq">INIT</span></div>
    <div class="hud-row">BPM: <span class="val">138</span></div>
    <div class="hud-row">TIME: <span class="val" id="h-time">00:00</span></div>
</div>

<div id="ui-layer">
    <div id="panel">
        <h1>THE IRON PSALM</h1>
        <div class="sub">DAVIDIC HARP // ORPHIC BASS // 138 BPM</div>
        <button id="btn">EXECUTE PROTOCOL</button>
    </div>
</div>

<canvas id="c"></canvas>

<script>
/**
 * PROJECT: THE IRON PSALM
 * ENGINE: High-Tempo Generative Step Sequencer
 * KEY: C Double Harmonic Minor (C, Db, E, F, G, Ab, B) - The "Misheberak" Mode
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

// AUDIO GRAPH
let ac, master, limiter, delayL, delayR, delayGain;
let isPlaying = false;
let startTime = 0;

// CONFIG
const BPM = 138;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;
const STEPS_PER_BAR = 16;
const TOTAL_BARS = 64; 

// SCALE FREQUENCIES (C Double Harmonic Minor)
// Low C2 = 65.41 Hz
const SCALE = [
    65.41, 69.30, 82.41, 87.31, 98.00, 103.83, 123.47, // Octave 2
    130.81, 138.59, 164.81, 174.61, 196.00, 207.65, 246.94, // Octave 3
    261.63, 277.18, 329.63, 349.23, 392.00, 415.30, 493.88, // Octave 4
    523.25, 554.37, 659.25, 698.46, 783.99, 830.61, 987.77  // Octave 5
];

// VISUALS STATE
let kickPulse = 0;
let particles = [];

// ==================== 1. AUDIO ENGINE ==================== //

async function init() {
    ac = new AC();
    await ac.resume();

    // MASTER BUS
    master = ac.createGain();
    master.gain.value = 0.5;

    // LIMITER (Safety)
    limiter = ac.createDynamicsCompressor();
    limiter.threshold.value = -3;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.002;

    // STEREO DELAY (The "Canyon" Effect)
    const delayIn = ac.createGain(); delayIn.gain.value = 0.3;
    delayL = ac.createDelay(); delayL.delayTime.value = BEAT * 0.75; // Dotted 8th
    delayR = ac.createDelay(); delayR.delayTime.value = BEAT * 0.5;  // 8th
    const delayFb = ac.createGain(); delayFb.gain.value = 0.4;
    const merger = ac.createChannelMerger(2);

    master.connect(limiter).connect(ac.destination);
    
    // Send to Delay
    master.connect(delayIn);
    delayIn.connect(delayL); delayIn.connect(delayR);
    delayL.connect(merger, 0, 0); delayR.connect(merger, 0, 1);
    delayL.connect(delayFb); delayR.connect(delayFb); delayFb.connect(delayL); delayFb.connect(delayR); // Cross feedback
    merger.connect(ac.destination);
}

// INSTRUMENT: SYNTH KICK
function playKick(t) {
    const osc = ac.createOscillator();
    const g = ac.createGain();
    
    osc.frequency.setValueAtTime(150, t);
    osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
    
    g.gain.setValueAtTime(1.2, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
    
    osc.connect(g).connect(limiter); // Direct to limiter to punch through
    osc.start(t); osc.stop(t + 0.5);
    
    // Vis
    setTimeout(() => { kickPulse = 1.0; }, (t - ac.currentTime)*1000);
}

// INSTRUMENT: SYNTH SNARE
function playSnare(t) {
    const bufSize = ac.sampleRate * 0.2;
    const buf = ac.createBuffer(1, bufSize, ac.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0; i<bufSize; i++) data[i] = (Math.random() * 2 - 1);
    
    const noise = ac.createBufferSource();
    noise.buffer = buf;
    
    const filt = ac.createBiquadFilter();
    filt.type = 'highpass'; filt.frequency.value = 1000;
    
    const g = ac.createGain();
    g.gain.setValueAtTime(0.8, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    
    // Body tone
    const osc = ac.createOscillator();
    osc.frequency.setValueAtTime(200, t);
    osc.frequency.exponentialRampToValueAtTime(100, t+0.1);
    const oscG = ac.createGain();
    oscG.gain.setValueAtTime(0.5, t);
    oscG.gain.exponentialRampToValueAtTime(0.001, t+0.1);

    noise.connect(filt).connect(g).connect(master);
    osc.connect(oscG).connect(master);
    noise.start(t); osc.start(t); osc.stop(t+0.1);
}

// INSTRUMENT: HI-HAT
function playHat(t, open) {
    const bufSize = ac.sampleRate * (open ? 0.3 : 0.05);
    const buf = ac.createBuffer(1, bufSize, ac.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0; i<bufSize; i++) data[i] = (Math.random() * 2 - 1);
    
    const noise = ac.createBufferSource();
    noise.buffer = buf;
    
    const filt = ac.createBiquadFilter();
    filt.type = 'highpass'; filt.frequency.value = 8000;
    
    const g = ac.createGain();
    g.gain.setValueAtTime(0.3, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + (open ? 0.3 : 0.05));
    
    noise.connect(filt).connect(g).connect(master);
    noise.start(t);
}

// INSTRUMENT: FM HARP (David)
// Bright, plucked, metallic
function playHarp(t, freq, panVal) {
    const osc = ac.createOscillator(); osc.type = 'triangle';
    const mod = ac.createOscillator(); mod.type = 'sine';
    
    osc.frequency.setValueAtTime(freq, t);
    mod.frequency.setValueAtTime(freq * 2, t);
    
    const modG = ac.createGain();
    modG.gain.setValueAtTime(freq, t);
    modG.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
    
    const env = ac.createGain();
    env.gain.setValueAtTime(0, t);
    env.gain.linearRampToValueAtTime(0.4, t + 0.01);
    env.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
    
    const pan = ac.createStereoPanner();
    pan.pan.value = panVal;

    mod.connect(modG).connect(osc.frequency);
    osc.connect(env).connect(pan).connect(master);
    
    osc.start(t); osc.stop(t + 1.5);
    mod.start(t); mod.stop(t + 1.5);
    
    // Vis
    setTimeout(() => spawnParticle(freq), (t - ac.currentTime)*1000);
}

// INSTRUMENT: REESE BASS (Orpheus)
// Deep, detuned saws
function playBass(t, freq, dur) {
    const o1 = ac.createOscillator(); o1.type = 'sawtooth';
    const o2 = ac.createOscillator(); o2.type = 'sawtooth';
    
    o1.frequency.value = freq;
    o2.frequency.value = freq; 
    o2.detune.value = 15; // The "Reese" Detune
    
    const filt = ac.createBiquadFilter();
    filt.type = 'lowpass';
    filt.frequency.setValueAtTime(300, t);
    filt.frequency.linearRampToValueAtTime(2000, t + dur); // Filter sweep
    
    const g = ac.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.3, t+0.05);
    g.gain.linearRampToValueAtTime(0, t+dur);

    o1.connect(filt); o2.connect(filt);
    filt.connect(g).connect(master);
    
    o1.start(t); o1.stop(t+dur);
    o2.start(t); o2.stop(t+dur);
}

// ==================== 2. SEQUENCER ==================== //

// Patterns (16 steps)
const PTN_KICK_A = [1,0,0,0, 0,0,1,0, 0,0,0,0, 0,0,1,0];
const PTN_KICK_B = [1,0,0,1, 0,0,1,0, 0,0,1,0, 0,1,0,0]; // Drum & Bass feel
const PTN_SNARE  = [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0];

let nextTime = 0;
let step = 0;

function scheduler() {
    if(!isPlaying) return;
    const lookahead = 0.1;
    while (nextTime < ac.currentTime + lookahead) {
        runStep(step, nextTime);
        nextTime += SIXTEENTH;
        step++;
    }
    
    // UI Update
    const elapsed = Math.floor(ac.currentTime - startTime);
    const m = Math.floor(elapsed/60);
    const s = (elapsed%60).toString().padStart(2,'0');
    document.getElementById('h-time').innerText = `${m}:${s}`;
    
    setTimeout(scheduler, 25);
}

function runStep(s, t) {
    const bar = Math.floor(s / 16);
    const bStep = s % 16;
    
    // SECTIONS
    let section = "INTRO";
    let intensity = 0; // 0 to 3
    
    if (bar >= 4) { section = "BUILD"; intensity = 1; }
    if (bar >= 12) { section = "ASSAULT"; intensity = 3; } // Full speed
    if (bar >= 28) { section = "BRIDGE"; intensity = 1; }
    if (bar >= 36) { section = "CLIMAX"; intensity = 3; }
    if (bar >= 52) { section = "OUTRO"; intensity = 0; }
    
    if(bStep === 0) document.getElementById('h-seq').innerText = `${section} [${bar+1}]`;

    // --- DRUMS ---
    if (intensity >= 1) {
        const kPtn = (intensity === 3 && bar % 2 === 1) ? PTN_KICK_B : PTN_KICK_A;
        if(kPtn[bStep]) playKick(t);
        if(bar >= 8 && PTN_SNARE[bStep]) playSnare(t);
        if(bStep % 2 === 0) playHat(t, false); // Closed hats
        if(intensity === 3 && bStep % 4 === 2) playHat(t, true); // Open hats
    }

    // --- BASS ---
    // Root notes following the Double Harmonic Scale
    // Progression: I (C) -> bII (Db) -> I (C) -> VII (B)
    let root = SCALE[0]; // C2
    if(bar % 4 === 1) root = SCALE[1]; // Db2
    if(bar % 4 === 3) root = SCALE[6] / 2; // B1
    
    if (intensity >= 1 && bStep === 0) {
        // Long bass drone
        playBass(t, root, BEAT * 2);
    }
    if (intensity === 3 && bStep === 8) {
        // Bass stab mid-measure
        playBass(t, root * 1.5, BEAT);
    }

    // --- HARP (ARPEGGIOS) ---
    // Generative arpeggios based on intensity
    let noteChance = 0;
    if(section === "INTRO") noteChance = 0.2;
    if(intensity === 1) noteChance = 0.5;
    if(intensity === 3) noteChance = 0.9;

    if (Math.random() < noteChance) {
        // Which octave?
        let octOffset = 14; // Start at C4 (Index 14)
        if (Math.random() > 0.7) octOffset = 21; // C5
        
        // Complex Arp Logic
        // We want to ascend during the first half of bar, descend second half
        let interval = 0;
        if (bStep < 8) interval = Math.floor(Math.random() * 5); 
        else interval = 7 - Math.floor(Math.random() * 5);
        
        // Map to scale
        let noteIdx = octOffset + interval;
        // Shift depending on chord (Simple shift)
        if(bar % 4 === 1) noteIdx += 1; // Shift up for Db
        if(bar % 4 === 3) noteIdx -= 1; // Shift down for B
        
        if (SCALE[noteIdx]) {
            let pan = (bStep / 16) * 2 - 1; // Pan across stereo field left to right over the bar
            playHarp(t, SCALE[noteIdx], pan);
        }
    }
}

// ==================== 3. VISUAL ENGINE ==================== //

class Particle {
    constructor(freq) {
        this.angle = Math.random() * Math.PI * 2;
        this.dist = 50;
        this.speed = 2 + Math.random() * 3;
        // Color based on freq (Low = Red, High = Gold)
        const hue = freq < 200 ? 0 : 45; 
        this.color = `hsl(${hue}, 100%, 50%)`;
        this.size = Math.random() * 3 + 1;
        this.life = 1.0;
    }
    update() {
        this.dist += this.speed;
        this.life -= 0.02;
    }
    draw(ctx, cx, cy) {
        const x = cx + Math.cos(this.angle) * this.dist;
        const y = cy + Math.sin(this.angle) * this.dist;
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.beginPath();
        ctx.arc(x, y, this.size, 0, Math.PI*2);
        ctx.fill();
    }
}

function spawnParticle(freq) {
    for(let i=0; i<5; i++) particles.push(new Particle(freq));
}

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.onresize = initVis;

function draw() {
    requestAnimationFrame(draw);
    
    // Background fade (fast for frantic feel)
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0,0,w,h);
    
    const cx = w/2;
    const cy = h/2;

    // Kick Pulse (The Void Center)
    if(kickPulse > 0.01) kickPulse *= 0.9;
    
    const r = 50 + (kickPulse * 100);
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(255, 170, 0, ${kickPulse})`;
    ctx.lineWidth = 5;
    ctx.stroke();

    // Orphic Ring (Rotating)
    const time = Date.now() * 0.001;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(time);
    ctx.beginPath();
    for(let i=0; i<6; i++) {
        const a = (i/6) * Math.PI*2;
        ctx.moveTo(Math.cos(a)*150, Math.sin(a)*150);
        ctx.lineTo(Math.cos(a)*200, Math.sin(a)*200);
    }
    ctx.strokeStyle = '#332200';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    // Particles
    ctx.globalCompositeOperation = 'lighter';
    for(let i=particles.length-1; i>=0; i--) {
        const p = particles[i];
        p.update();
        p.draw(ctx, cx, cy);
        if(p.life <= 0) particles.splice(i, 1);
    }
    ctx.globalCompositeOperation = 'source-over';
}

// ==================== CONTROL ==================== //

initVis();
draw();

document.getElementById('btn').addEventListener('click', async () => {
    document.getElementById('panel').style.opacity = 0;
    document.getElementById('hud').style.opacity = 1;
    await init();
    
    startTime = ac.currentTime;
    nextTime = ac.currentTime + 0.1;
    isPlaying = true;
    
    scheduler();
});

</script>
</body>
</html>

PROGRAM 20
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VELOCITY // LIQUID AUDIO ENGINE</title>
    <style>
        body { 
            margin: 0; background: #000; overflow: hidden; 
            font-family: 'Segoe UI', sans-serif; color: #fff;
            display: flex; justify-content: center; align-items: center; height: 100vh;
        }
        canvas { position: absolute; top: 0; left: 0; z-index: 1; }
        #overlay {
            z-index: 10; text-align: center; background: rgba(0,0,0,0.8);
            padding: 60px; border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(20px); box-shadow: 0 0 50px rgba(0,200,255,0.2);
            transition: all 0.5s ease;
        }
        h1 { 
            font-weight: 900; letter-spacing: 10px; font-size: 3rem; margin: 0;
            background: linear-gradient(90deg, #fff, #00f2ff); -webkit-background-clip: text; color: transparent;
        }
        p { font-size: 0.9rem; letter-spacing: 3px; color: #aaa; margin-top: 10px; text-transform: uppercase; }
        button {
            margin-top: 30px; background: #fff; color: #000; border: none; padding: 15px 40px;
            font-size: 1rem; font-weight: bold; letter-spacing: 2px; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover { transform: scale(1.05); box-shadow: 0 0 30px #00f2ff; }
        #status-bar {
            position: absolute; bottom: 0; left: 0; width: 0%; height: 4px; 
            background: #00f2ff; z-index: 20; transition: width 0.2s linear;
        }
        .hidden { opacity: 0; pointer-events: none; transform: scale(0.9); }
    </style>
</head>
<body>

<div id="status-bar"></div>
<div id="overlay">
    <h1>VELOCITY</h1>
    <p>174 BPM Liquid DnB Engine</p>
    <button id="btn">INITIATE LAUNCH</button>
</div>
<canvas id="c"></canvas>

<script>
/**
 * PROJECT: VELOCITY
 * GENRE: Liquid Drum & Bass
 * BPM: 174
 * KEY: F Minor
 */

const AC = window.AudioContext || window.webkitAudioContext;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');
let w, h;

let actx, master, bus, limiter, analyser, reverb;
let isPlaying = false;
let startTime = 0;

// CONFIG
const BPM = 174;
const BEAT = 60 / BPM;
const SIXTEENTH = BEAT / 4;
const TOTAL_BARS = 64;

// FREQUENCIES (F Minor)
// F, G, Ab, Bb, C, Db, Eb
const N = {
    F1: 43.65, Ab1: 51.91, Bb1: 58.27, C1: 65.41, Db1: 69.30, Eb1: 77.78,
    F2: 87.31, G2: 98.00, Ab2: 103.83, Bb2: 116.54, C2: 130.81, Db2: 138.59, Eb2: 155.56,
    F3: 174.61, G3: 196.00, Ab3: 207.65, Bb3: 233.08, C3: 261.63, Db3: 277.18, Eb3: 311.13,
    F4: 349.23, G4: 392.00, Ab4: 415.30, Bb4: 466.16, C4: 523.25, Db4: 554.37, Eb4: 622.25,
    F5: 698.46, Ab5: 830.61, C5: 1046.50
};

// PROGRESSION (i - VI - III - VII) -> F minor, Db Major, Ab Major, Eb Major
const CHORDS = [
    [N.F3, N.Ab3, N.C4, N.Eb4], // Fm7
    [N.Db3, N.F3, N.Ab3, N.C4], // DbMaj7
    [N.Ab3, N.C4, N.Eb4, N.G4], // AbMaj7
    [N.Eb3, N.G3, N.Bb3, N.Eb4] // Eb
];
const BASS_ROOTS = [N.F1, N.Db1, N.Ab1, N.Eb1];

// MELODY
const MELODY = [
    {s:0, n:N.C5}, {s:3, n:N.Bb4}, {s:6, n:N.Ab4}, {s:8, n:N.F4}, {s:12, n:N.C5},
    {s:16, n:N.Db5}, {s:19, n:N.C5}, {s:22, n:N.Ab4}, {s:26, n:N.F4},
    {s:32, n:N.Eb5}, {s:35, n:N.C5}, {s:38, n:N.Bb4}, {s:42, n:N.Ab4},
    {s:48, n:N.G4}, {s:51, n:N.Ab4}, {s:54, n:N.Bb4}, {s:58, n:N.C5}
];

// --- AUDIO ENGINE ---

async function init() {
    actx = new AC();
    await actx.resume();

    // Master Bus
    master = actx.createGain();
    master.gain.value = 0.55;

    // Dynamics
    limiter = actx.createDynamicsCompressor();
    limiter.threshold.value = -3;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.002;
    limiter.release.value = 0.1;

    analyser = actx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.8;

    // Routing
    master.connect(limiter);
    limiter.connect(analyser);
    analyser.connect(actx.destination);

    // FX
    reverb = await createReverb();
    reverb.output.connect(master);
}

async function createReverb() {
    const len = actx.sampleRate * 2.5;
    const b = actx.createBuffer(2, len, actx.sampleRate);
    for(let c=0; c<2; c++){
        const d = b.getChannelData(c);
        for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 3);
    }
    const c = actx.createConvolver();
    c.buffer = b;
    const i = actx.createGain();
    const o = actx.createGain();
    o.gain.value = 0.35;
    i.connect(c); c.connect(o);
    return {input:i, output:o};
}

// INSTRUMENT 1: LIQUID PIANO
// Bright, compressed, delay-heavy
function playPiano(t, freq, vel=1) {
    const o1 = actx.createOscillator(); o1.type = 'triangle'; o1.frequency.value = freq;
    const o2 = actx.createOscillator(); o2.type = 'sine'; o2.frequency.value = freq;
    
    // Attack Noise (Hammer)
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.01, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer = b;

    const g = actx.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.4 * vel, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + 1.5);

    const f = actx.createBiquadFilter();
    f.type = 'lowpass';
    f.frequency.setValueAtTime(800, t);
    f.frequency.linearRampToValueAtTime(2000, t + 0.05);
    f.frequency.exponentialRampToValueAtTime(500, t + 1.0);

    o1.connect(f); o2.connect(f); 
    const ng = actx.createGain(); ng.gain.value=0.1; n.connect(ng); ng.connect(f);
    f.connect(g);
    g.connect(master);
    g.connect(reverb.input);

    // Delay send
    const del = actx.createDelay(); del.delayTime.value = 3/8 * BEAT; // Dotted 8th
    const delG = actx.createGain(); delG.gain.value = 0.2;
    g.connect(del); del.connect(delG); delG.connect(master);

    o1.start(t); o1.stop(t+2);
    o2.start(t); o2.stop(t+2);
    n.start(t);
}

// INSTRUMENT 2: REESE BASS (The Soul of DnB)
// Two detuned saws + lowpass filter movement
function playReese(t, freq, dur) {
    const o1 = actx.createOscillator(); o1.type = 'sawtooth'; o1.frequency.value = freq; o1.detune.value = -15;
    const o2 = actx.createOscillator(); o2.type = 'sawtooth'; o2.frequency.value = freq; o2.detune.value = 15;
    const sub = actx.createOscillator(); sub.type = 'sine'; sub.frequency.value = freq / 2;

    const f = actx.createBiquadFilter();
    f.type = 'lowpass';
    f.frequency.setValueAtTime(100, t);
    // The "Wobble" movement
    f.frequency.linearRampToValueAtTime(800, t + dur*0.3); 
    f.frequency.linearRampToValueAtTime(100, t + dur);

    const g = actx.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.6, t + 0.1);
    g.gain.setValueAtTime(0.6, t + dur - 0.1);
    g.gain.linearRampToValueAtTime(0, t + dur);

    o1.connect(f); o2.connect(f);
    f.connect(g);
    
    // Sub bypasses filter for clean low end
    const subG = actx.createGain(); subG.gain.value = 0.5;
    subG.gain.setValueAtTime(0.5, t); subG.gain.linearRampToValueAtTime(0, t+dur);
    sub.connect(subG); subG.connect(g);

    g.connect(master);

    o1.start(t); o1.stop(t+dur);
    o2.start(t); o2.stop(t+dur);
    sub.start(t); sub.stop(t+dur);
}

// INSTRUMENT 3: DRUMS (Synthesized Breakbeat)
// Kick
function playKick(t) {
    const o = actx.createOscillator();
    o.frequency.setValueAtTime(150, t);
    o.frequency.exponentialRampToValueAtTime(50, t+0.1);
    const g = actx.createGain();
    g.gain.setValueAtTime(1.0, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
    
    // Click
    const c = actx.createOscillator(); c.type='square';
    const cg = actx.createGain(); cg.gain.setValueAtTime(0.1, t); cg.gain.exponentialRampToValueAtTime(0.001, t+0.02);
    
    o.connect(g); g.connect(master);
    c.connect(cg); cg.connect(master);
    o.start(t); o.stop(t+0.2); c.start(t); c.stop(t+0.02);
    
    pulseVisuals(1);
}

// Snare (Tight & snappy)
function playSnare(t) {
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.15, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer = b;
    
    const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=400;
    const g = actx.createGain(); g.gain.setValueAtTime(0.7, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
    
    // Tonal body
    const o = actx.createOscillator(); o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(100, t+0.1);
    const og = actx.createGain(); og.gain.setValueAtTime(0.3, t); og.gain.exponentialRampToValueAtTime(0.001, t+0.1);

    n.connect(f); f.connect(g); g.connect(master); g.connect(reverb.input);
    o.connect(og); og.connect(master);
    n.start(t); o.start(t); o.stop(t+0.15);
}

// Hats (Fast shaker)
function playHat(t, open=false) {
    const n = actx.createBufferSource();
    const b = actx.createBuffer(1, actx.sampleRate*0.1, actx.sampleRate);
    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    n.buffer = b;
    const f = actx.createBiquadFilter(); f.type='highpass'; f.frequency.value=6000;
    const g = actx.createGain(); 
    g.gain.setValueAtTime(open ? 0.2 : 0.08, t); 
    g.gain.exponentialRampToValueAtTime(0.001, t + (open ? 0.1 : 0.03));
    n.connect(f); f.connect(g); g.connect(master);
    n.start(t);
}

// INSTRUMENT 4: ATMOSPHERIC PAD
function playPad(t, chord) {
    const g = actx.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.15, t+2);
    g.gain.setValueAtTime(0.15, t+SIXTEENTH*60);
    g.gain.linearRampToValueAtTime(0, t+SIXTEENTH*64);
    
    const f = actx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=600;

    chord.forEach((n, i) => {
        const o = actx.createOscillator(); o.type='sawtooth'; o.frequency.value=n;
        o.detune.value = i%2===0 ? 10 : -10;
        o.connect(f); o.start(t); o.stop(t+SIXTEENTH*64);
    });
    f.connect(g); g.connect(master); g.connect(reverb.input);
}

// --- SEQUENCER ---

let nextTime = 0;
let step = 0;
let bar = 0;

function scheduler() {
    while(nextTime < actx.currentTime + 0.1) {
        runStep(step, nextTime);
        nextTime += SIXTEENTH;
        step++;
    }
    setTimeout(scheduler, 25);
}

function runStep(s, t) {
    const stepInBar = s % 16;
    if(stepInBar === 0) bar++;
    
    const chordIdx = Math.floor((bar % 16) / 4); // Change chord every 4 bars
    const currentChord = CHORDS[chordIdx];
    const currentBass = BASS_ROOTS[chordIdx];

    // PHASES
    const intro = bar <= 8;
    const build = bar > 8 && bar <= 16;
    const drop = bar > 16 && bar <= 48;
    const outro = bar > 48;

    // 1. DRUMS (Amen Break Pattern)
    // K . . . S . . . . . K . S . . . (Basic skeleton)
    // Liquid DnB adds shuffles
    if (drop || (build && bar > 12)) {
        if(stepInBar === 0) playKick(t);
        if(stepInBar === 4) playSnare(t); // Beat 2
        if(stepInBar === 10) playKick(t); // Ghost kick
        if(stepInBar === 12) playSnare(t); // Beat 4
        
        // Shuffles
        if (Math.random() > 0.7 && stepInBar !== 4 && stepInBar !== 12) playHat(t, false);
    }
    // High-speed HiHats
    if ((drop || build) && s % 2 === 0) playHat(t, false);

    // 2. BASS (The Reese)
    // Plays long sustained notes in Intro, rhythmic in Drop
    if (intro || build) {
        if (stepInBar === 0 && bar % 4 === 1) playReese(t, currentBass, SIXTEENTH*60);
    }
    if (drop) {
        // Rhythmic pulsing bass
        if (stepInBar === 0) playReese(t, currentBass, SIXTEENTH*6);
        if (stepInBar === 7) playReese(t, currentBass, SIXTEENTH*4);
        if (stepInBar === 11) playReese(t, currentBass * 1.5, SIXTEENTH*4); // Fifth up
    }

    // 3. PIANO MELODY
    if (intro || drop) {
        const melNote = MELODY.find(m => m.s === stepInBar);
        if (melNote && (bar % 4 !== 3)) { // Rest on 4th bar of phrase
            playPiano(t, melNote.n, 0.8 + Math.random()*0.2);
        }
        // Random chord stabs
        if (stepInBar === 0 && bar % 2 === 0) {
            playPiano(t, currentChord[0], 0.4);
            playPiano(t, currentChord[2], 0.4);
        }
    }

    // 4. PADS
    if (intro || (drop && bar > 32)) {
        if (stepInBar === 0 && bar % 4 === 1) playPad(t, currentChord);
    }

    // UPDATE UI
    const pct = (bar / TOTAL_BARS) * 100;
    document.getElementById('status-bar').style.width = `${pct}%`;

    if (bar > 64) {
        // Loop
        step = 16 * 16; // Go back to drop
        bar = 16;
    }
}

// --- VISUALS (HYPERSPACE) ---

let pulse = 0;
let speed = 2;
let stars = [];

function initVis() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
    stars = Array(500).fill().map(() => ({
        x: Math.random() * w - w/2,
        y: Math.random() * h - h/2,
        z: Math.random() * 2000,
        sz: Math.random() * 2
    }));
}

function pulseVisuals(val) { pulse = val; }

function draw() {
    requestAnimationFrame(draw);
    
    // Clear with trail
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(0,0,w,h);
    
    pulse *= 0.9;
    
    const cx = w/2;
    const cy = h/2;
    
    // Speed up visuals during drop
    const currentSpeed = (isPlaying && bar > 16) ? 40 : 5;
    
    ctx.fillStyle = '#fff';
    
    stars.forEach(s => {
        // Move star towards camera
        s.z -= currentSpeed + (pulse * 50);
        
        if (s.z <= 1) {
            s.z = 2000;
            s.x = Math.random() * w - w/2;
            s.y = Math.random() * h - h/2;
        }
        
        const scale = 300 / s.z;
        const x2d = cx + s.x * scale;
        const y2d = cy + s.y * scale;
        
        // Draw Star
        const alpha = Math.min(1, (2000 - s.z) / 1000);
        const size = s.sz * scale;
        
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(x2d, y2d, size, 0, Math.PI*2);
        ctx.fill();
        
        // Draw line trails during drop
        if (isPlaying && bar > 16) {
            ctx.strokeStyle = `rgba(0, 242, 255, ${alpha * 0.5})`;
            ctx.lineWidth = size;
            ctx.beginPath();
            ctx.moveTo(x2d, y2d);
            // Previous position approximation
            const scalePrev = 300 / (s.z + 50);
            const xPrev = cx + s.x * scalePrev;
            const yPrev = cy + s.y * scalePrev;
            ctx.lineTo(xPrev, yPrev);
            ctx.stroke();
        }
    });
    ctx.globalAlpha = 1;

    // Analyzer Ring
    if(analyser) {
        const data = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(data);
        const bass = data[10];
        
        ctx.strokeStyle = `hsl(185, 100%, ${50 + pulse*50}%)`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        const r = 100 + (bass * 0.5);
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.stroke();
        
        // Glitch text
        if (pulse > 0.8) {
            ctx.font = "bold 20px monospace";
            ctx.fillStyle = "#00f2ff";
            ctx.fillText("VELOCITY :: " + Math.floor(actx.currentTime), cx - 60, cy + r + 30);
        }
    }
}

window.onresize = initVis;
initVis();

document.getElementById('btn').addEventListener('click', async (e) => {
    e.target.innerText = "SEQUENCE RUNNING";
    document.getElementById('overlay').classList.add('hidden');
    
    await init();
    startTime = actx.currentTime + 0.1;
    nextTime = startTime;
    isPlaying = true;
    scheduler();
    draw();
});

</script>
</body>
</html>

PROGRAM 21
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Î© // WITHOUT ME // ACCELERATED</title>
    <style>
        :root {
            --void: #080808;
            --neon: #00f3ff; /* Cyber Blue */
            --hot: #ff0055;   /* Aggressive Pink */
            --string: rgba(255, 255, 255, 0.15);
        }

        body {
            margin: 0;
            background: var(--void);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            filter: blur(0.5px) contrast(1.2);
        }

        #hud {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #chord-display {
            font-size: 12vw;
            font-weight: 900;
            color: transparent;
            -webkit-text-stroke: 2px var(--string);
            opacity: 0.3;
            transition: all 0.1s;
            text-transform: uppercase;
        }

        #lyric-display {
            margin-top: 20px;
            font-size: 1.5rem;
            color: var(--neon);
            text-shadow: 0 0 10px var(--neon);
            letter-spacing: 2px;
            text-align: center;
            min-height: 40px;
        }

        #controls {
            position: absolute;
            bottom: 50px;
            z-index: 20;
            display: flex;
            gap: 20px;
            align-items: center;
            pointer-events: auto;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 1px solid var(--neon);
        }

        button {
            background: var(--neon);
            color: black;
            border: none;
            padding: 15px 40px;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 20px var(--neon);
        }

        button:hover {
            background: white;
            box-shadow: 0 0 40px white;
        }

        input[type=range] {
            width: 200px;
            accent-color: var(--hot);
        }

        .flash {
            animation: flashbang 0.1s ease-out;
        }

        @keyframes flashbang {
            0% { -webkit-text-stroke: 4px var(--hot); opacity: 1; transform: scale(1.1); }
            100% { -webkit-text-stroke: 2px var(--string); opacity: 0.3; transform: scale(1); }
        }
    </style>
</head>
<body>

    <canvas id="stage"></canvas>

    <div id="hud">
        <div id="chord-display">READY</div>
        <div id="lyric-display">SYSTEM STANDBY // CAPO 4</div>
    </div>

    <div id="controls">
        <button onclick="SIM.start()">INITIATE // FASTER</button>
        <div style="display:flex; flex-direction:column; color:var(--neon); font-size:0.8rem;">
            <label>TEMPO OVERRIDE</label>
            <input type="range" min="60" max="120" value="82" oninput="SIM.setBPM(this.value)">
            <span id="bpm-val">82 BPM</span>
        </div>
    </div>

    <script>
        // ======================================================
        // 1. THE ARCHITECT'S TUNING (PHYSICS)
        // ======================================================
        const TUNING = [82.41, 110.00, 146.83, 196.00, 246.94, 329.63]; // E A D G B E
        const CAPO = 4;

        const AudioEngine = {
            ctx: null,
            master: null,
            reverb: null,
            
            init() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.5;

                // Cyber-Reverb (Infinite Hall)
                this.reverb = this.ctx.createConvolver();
                this.reverb.buffer = this.impulse(3.0);
                
                this.master.connect(this.ctx.destination);
                this.master.connect(this.reverb);
                this.reverb.connect(this.ctx.destination);
                
                return this.ctx.resume();
            },

            impulse(d) {
                const r = this.ctx.sampleRate;
                const len = r*d;
                const b = this.ctx.createBuffer(2, len, r);
                for(let c=0;c<2;c++){
                    let d=b.getChannelData(c);
                    for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/len, 2);
                }
                return b;
            },

            // The "Pluck" Synthesis
            play(stringIdx, fret, time, vel=1) {
                if(fret === -1) return;
                const t = time;
                
                // Pitch Logic
                const base = TUNING[stringIdx];
                const semi = CAPO + fret;
                const freq = base * Math.pow(2, semi/12);

                // 1. Attack (Pick noise)
                const n = this.ctx.createBufferSource();
                const nb = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
                const nd = nb.getChannelData(0);
                for(let i=0;i<1000;i++) nd[i]=Math.random()*2-1;
                n.buffer = nb;
                const ng = this.ctx.createGain();
                ng.gain.value = 0.2 * vel;
                ng.gain.exponentialRampToValueAtTime(0.01, t+0.02);
                n.connect(ng); ng.connect(this.master);
                n.start(t);

                // 2. Sustain (String)
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = freq;
                
                const f = this.ctx.createBiquadFilter();
                f.type = 'lowpass';
                f.frequency.setValueAtTime(freq*6, t);
                f.frequency.exponentialRampToValueAtTime(freq, t+0.2); // "Twang" decay

                const g = this.ctx.createGain();
                g.gain.setValueAtTime(0, t);
                g.gain.linearRampToValueAtTime(0.4*vel, t+0.005);
                g.gain.exponentialRampToValueAtTime(0.001, t+2.5);

                osc.connect(f); f.connect(g); g.connect(this.master);
                osc.start(t); osc.stop(t+3);

                // Visual Trigger
                Visuals.pluck(stringIdx, vel);
            }
        };

        // ======================================================
        // 2. THE DATA (TAB & CHORDS)
        // ======================================================
        
        // Exact Intro Tab from your request
        const INTRO_TAB = [
            // Meas 1: Bm7
            {s:1, f:2, t:0.0}, {s:2, f:4, t:0.5}, {s:3, f:2, t:1.0}, {s:4, f:3, t:1.5}, {s:5, f:2, t:2.0}, {s:5, f:0, t:2.5},
            // Meas 2: Dsus2
            {s:2, f:0, t:4.0}, {s:3, f:2, t:4.5}, {s:4, f:3, t:5.0}, {s:5, f:0, t:5.5},
            // Meas 3: A
            {s:1, f:0, t:8.0}, {s:2, f:2, t:8.5}, {s:3, f:2, t:9.0}, {s:4, f:2, t:9.5}, {s:5, f:0, t:10.0}, {s:4, f:3, t:10.5},
            // Meas 4: G/Em7
            {s:0, f:3, t:12.0}, {s:1, f:2, t:12.5}, {s:2, f:0, t:13.0}, {s:3, f:0, t:13.5}, {s:4, f:3, t:14.0}, {s:5, f:3, t:14.5}
        ];

        // Chords for the Loop
        const CHORDS = {
            "Bm7":   [-1, 2, 4, 2, 3, 2],
            "Dsus2": [-1, -1, 0, 2, 3, 0],
            "A":     [-1, 0, 2, 2, 2, 0],
            "Em7":   [0, 2, 2, 0, 3, 3],
            "G":     [3, 2, 0, 0, 3, 3]
        };

        const LOOP_SEQ = [
            { c: "Bm7",   l: "Found you when your heart was broke" },
            { c: "Dsus2", l: "I filled your cup until it overflowed" },
            { c: "A",     l: "Took it so far to keep you close" },
            { c: "Em7",   l: "I was afraid to leave you on your own" }
        ];

        // ======================================================
        // 3. THE SEQUENCER (THE BRAIN)
        // ======================================================
        const SIM = {
            bpm: 82, // FASTER
            isPlaying: false,
            startTime: 0,
            lookahead: 0.1,
            nextNoteTime: 0,
            step: 0,
            mode: 'INTRO', // INTRO -> LOOP
            loopIndex: 0,

            start() {
                document.querySelector('button').style.display = 'none';
                AudioEngine.init().then(() => {
                    this.isPlaying = true;
                    this.nextNoteTime = AudioEngine.ctx.currentTime + 0.1;
                    this.tick();
                });
            },

            setBPM(val) {
                this.bpm = parseInt(val);
                document.getElementById('bpm-val').innerText = this.bpm + " BPM";
            },

            tick() {
                if(!this.isPlaying) return;
                const secPerBeat = 60 / this.bpm;
                const secPerStep = secPerBeat / 4; // 16th notes

                while(this.nextNoteTime < AudioEngine.ctx.currentTime + this.lookahead) {
                    this.schedule(this.step, this.nextNoteTime);
                    this.nextNoteTime += secPerStep;
                    this.step++;
                }
                requestAnimationFrame(this.tick.bind(this));
            },

            schedule(step, time) {
                // --- INTRO MODE ---
                if(this.mode === 'INTRO') {
                    // Convert step to beats (step is 16th, tab 't' is beats)
                    const beat = step / 4;
                    
                    // Find notes in tab that match this beat
                    const notes = INTRO_TAB.filter(n => Math.abs(n.t - beat) < 0.01);
                    notes.forEach(n => {
                        AudioEngine.play(n.s, n.f, time, 1.2);
                        Visuals.flashChord(beat < 4 ? "Bm7" : beat < 8 ? "Dsus2" : beat < 12 ? "A" : "G");
                    });

                    if(beat >= 16) {
                        this.mode = 'LOOP';
                        this.step = 0; // Reset for loop
                    }
                }
                
                // --- LOOP MODE (STRUMMING) ---
                else {
                    const loopLen = 64; // 4 bars of 16 steps
                    const localStep = step % 16; // Step within bar
                    const barIdx = Math.floor((step % loopLen) / 16);
                    
                    const data = LOOP_SEQ[barIdx];
                    const frets = CHORDS[data.c];

                    // UI Update
                    if(localStep === 0) {
                        Visuals.flashChord(data.c);
                        document.getElementById('lyric-display').innerText = data.l;
                    }

                    // STRUMMING PATTERN (Driving 16ths)
                    // D . D U . U D U
                    // 0 . 4 6 . 10 12 14
                    
                    if(localStep === 0) this.strum(frets, time, 1.0, 'down'); // BIG DOWN
                    if(localStep === 4) this.strum(frets, time, 0.7, 'down');
                    if(localStep === 6) this.strum(frets, time, 0.6, 'up');
                    if(localStep === 10) this.strum(frets, time, 0.6, 'up');
                    if(localStep === 12) this.strum(frets, time, 0.8, 'down');
                    if(localStep === 14) this.strum(frets, time, 0.5, 'up');
                }
            },

            strum(frets, time, vel, dir) {
                // Strum physics: slight delay between strings
                const speed = 0.03; // Fast strum
                if(dir === 'down') {
                    for(let i=0; i<6; i++) {
                        if(frets[i] !== -1) AudioEngine.play(i, frets[i], time + (i*speed), vel);
                    }
                } else {
                    for(let i=5; i>=0; i--) {
                        if(frets[i] !== -1) AudioEngine.play(i, frets[i], time + ((5-i)*speed), vel*0.8);
                    }
                }
            }
        };

        // ======================================================
        // 4. VISUALS (CYBER-STRINGS)
        // ======================================================
        const Visuals = {
            cvs: document.getElementById('stage'),
            ctx: document.getElementById('stage').getContext('2d'),
            strings: [0,0,0,0,0,0],
            
            init() {
                this.resize();
                window.onresize = () => this.resize();
                this.loop();
            },
            
            resize() {
                this.cvs.width = window.innerWidth;
                this.cvs.height = window.innerHeight;
            },

            flashChord(txt) {
                const el = document.getElementById('chord-display');
                el.innerText = txt;
                el.classList.remove('flash');
                void el.offsetWidth; // trigger reflow
                el.classList.add('flash');
            },

            pluck(s, v) {
                this.strings[s] = v * 20;
            },

            loop() {
                const w = this.cvs.width;
                const h = this.cvs.height;
                this.ctx.clearRect(0,0,w,h);

                const spacing = h / 8;
                const top = spacing * 1.5;

                for(let i=0; i<6; i++) {
                    const y = top + (i * spacing);
                    const amp = this.strings[i];
                    
                    this.ctx.beginPath();
                    
                    // Color Logic
                    if(amp > 1) {
                        this.ctx.strokeStyle = '#00f3ff';
                        this.ctx.lineWidth = 3;
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = '#00f3ff';
                    } else {
                        this.ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        this.ctx.lineWidth = 1 + (i*0.5); // Thicker low strings
                        this.ctx.shadowBlur = 0;
                    }

                    this.ctx.moveTo(0, y);
                    
                    // Vibration Physics
                    for(let x=0; x<w; x+=20) {
                        const dy = Math.sin(x*0.05 + Date.now()*0.1) * amp * Math.sin(x/w * Math.PI);
                        this.ctx.lineTo(x, y + dy);
                    }
                    
                    this.ctx.stroke();
                    this.strings[i] *= 0.9; // Decay
                }
                
                requestAnimationFrame(() => this.loop());
            }
        };
        Visuals.init();

    </script>
</body>
</html>

PROGRAM 22
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WOLF-RAYET // WOMP CORE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            cursor: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: monospace;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
        }

        /* Glitchy Text Overlay */
        #hud {
            position: absolute;
            z-index: 10;
            color: #0ff;
            text-align: center;
            opacity: 0.7;
            pointer-events: none;
            mix-blend-mode: hard-light;
            text-shadow: 2px 2px 0px #f0f;
            white-space: pre;
            font-size: 14px;
        }

        #start-btn {
            position: absolute;
            z-index: 100;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 20px 50px;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 5px;
            background: rgba(0,0,0,0.8);
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px #0ff;
        }

        #start-btn:hover {
            background: #0ff;
            color: #000;
        }

        .fade-out {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <canvas id="c"></canvas>
    <div id="hud">SYSTEM IDLE</div>
    <div id="start-btn">INITIATE SEQUENCE</div>

    <script>
        /*
         *  WOLF-RAYET // PROCEDURAL DUBSTEP OPERA
         *  Combines Promethium-61 Atmosphere with Heavy FM Bass Synthesis
         */

        // --- GLOBAL CONFIG ---
        const BPM = 140; // Classic Dubstep Tempo
        const SECONDS_PER_BEAT = 60 / BPM;
        const SIXTEENTH = SECONDS_PER_BEAT / 4;
        
        // --- VISUAL GLOBALS ---
        let canvas = document.getElementById('c');
        let ctx = canvas.getContext('2d');
        let w, h, cx, cy;
        let hud = document.getElementById('hud');
        
        // --- AUDIO GLOBALS ---
        let actx, master, limiter;
        let nextNoteTime = 0;
        let tickCount = 0; // 16th note counter
        let phraseCount = 0;
        let barCount = 0;
        let kickVis = 0;
        let snareVis = 0;
        let wompLevel = 0; // Driven by audio to warp visuals

        // --- PROMETHEUM ATOM DATA ---
        let electrons = [];
        
        function resize() {
            w = window.innerWidth;
            h = window.innerHeight;
            canvas.width = w;
            canvas.height = h;
            cx = w/2; 
            cy = h/2;
        }
        window.addEventListener('resize', resize);
        resize();

        /* ==========================================================================
           AUDIO ENGINE: THE SYNTHS
           ========================================================================== */

        function initAudio() {
            actx = new (window.AudioContext || window.webkitAudioContext)();
            
            // MASTER CHAIN: LIMITER IS CRITICAL FOR WOMP
            limiter = actx.createDynamicsCompressor();
            limiter.threshold.value = -12;
            limiter.knee.value = 0;
            limiter.ratio.value = 20; // Hard limiting
            limiter.attack.value = 0.005;
            limiter.release.value = 0.05;

            master = actx.createGain();
            master.gain.value = 0.8;
            master.connect(limiter);
            limiter.connect(actx.destination);

            // Reverb Bus for Atmosphere (Flutes/Wolves)
            setupReverb();

            // Start Clock
            nextNoteTime = actx.currentTime + 0.1;
            requestAnimationFrame(loop); // Visual loop
            scheduler(); // Audio clock loop
        }

        let reverbNode;
        function setupReverb() {
            reverbNode = actx.createConvolver();
            // Procedural Impulse
            let len = actx.sampleRate * 4;
            let buff = actx.createBuffer(2, len, actx.sampleRate);
            for(let c=0;c<2;c++){
                let d = buff.getChannelData(c);
                for(let i=0;i<len;i++) d[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 3);
            }
            reverbNode.buffer = buff;
            reverbNode.connect(master);
        }

        // --- 1. THE KICK (Seismic Event) ---
        function playKick(t) {
            kickVis = 1.5;
            let osc = actx.createOscillator();
            let gain = actx.createGain();
            
            osc.frequency.setValueAtTime(150, t);
            osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
            
            gain.gain.setValueAtTime(1.0, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

            osc.connect(gain);
            gain.connect(limiter); // Bypass master volume gain for cleaner sidechain feel
            
            osc.start(t);
            osc.stop(t + 0.5);
        }

        // --- 2. THE SNARE (Electric Whip) ---
        function playSnare(t) {
            snareVis = 20; // Screen flash offset
            
            // Tone
            let osc = actx.createOscillator();
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.exponentialRampToValueAtTime(100, t+0.2);
            let oscG = actx.createGain();
            oscG.gain.setValueAtTime(0.5, t);
            oscG.gain.exponentialRampToValueAtTime(0.01, t+0.1);
            osc.connect(oscG);
            oscG.connect(reverbNode);
            osc.start(t); 
            osc.stop(t+0.2);

            // Noise (Snap)
            let bSize = actx.sampleRate;
            let buff = actx.createBuffer(1, bSize, actx.sampleRate);
            let d = buff.getChannelData(0);
            for(let i=0;i<bSize;i++) d[i] = Math.random() * 2 - 1;
            
            let noise = actx.createBufferSource();
            noise.buffer = buff;
            
            let filt = actx.createBiquadFilter();
            filt.type = 'highpass';
            filt.frequency.value = 1000;
            
            let nG = actx.createGain();
            nG.gain.setValueAtTime(0.7, t);
            nG.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            
            noise.connect(filt);
            filt.connect(nG);
            nG.connect(reverbNode); // Wet snare
            noise.start(t);
        }

        // --- 3. THE WOMP (FM BASS FACE) ---
        // The core logic of the track
        function playWomp(t, dur, wobbleSpeed, noteFreq = 41.2) { // E1 default
            wompLevel = 1.0; // Signal visuals

            // Carrier: Sawtooth (Rich harmonics)
            let osc1 = actx.createOscillator(); 
            osc1.type = 'sawtooth';
            osc1.frequency.value = noteFreq; 

            // Sub osc: Sine
            let sub = actx.createOscillator();
            sub.type = 'sine';
            sub.frequency.value = noteFreq;

            // FILTERS (The Vocal Tract)
            let lowpass = actx.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.Q.value = 12; // Screaming resonance

            let gain = actx.createGain();

            // MODULATION (The Womp Womp Womp)
            let lfo = actx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = (BPM / 60) * wobbleSpeed; // synced to beat

            let lfoGain = actx.createGain();
            lfoGain.gain.value = 2000; // How much it opens the filter

            lfo.connect(lfoGain);
            lfoGain.connect(lowpass.frequency);

            // Envelope to define filter center point
            lowpass.frequency.setValueAtTime(300, t); 
            // Also distort
            let dist = actx.createWaveShaper();
            dist.curve = makeDistortionCurve(100);

            // Routing
            osc1.connect(dist);
            dist.connect(lowpass);
            sub.connect(gain); // Clean sub, dry
            lowpass.connect(gain);
            gain.connect(limiter);

            // Amplitude Envelope
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.8, t + 0.05);
            gain.gain.setValueAtTime(0.8, t + dur - 0.05);
            gain.gain.linearRampToValueAtTime(0, t + dur);

            osc1.start(t);
            sub.start(t);
            lfo.start(t);

            osc1.stop(t+dur);
            sub.stop(t+dur);
            lfo.stop(t+dur);
            
            // Visual fade out timer
            setTimeout(() => { wompLevel = 0; }, dur*1000);
        }

        // --- 4. ATMOSPHERIC LAYERS (From previous context) ---
        function playAtmosphere(t) {
            // Random Flute / Wolf ambience
            let osc = actx.createOscillator();
            osc.type = 'triangle';
            // Pentatonic scale degrees
            let freq = [329, 392, 440, 493, 587][Math.floor(Math.random()*5)];
            osc.frequency.value = freq;
            
            let g = actx.createGain();
            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.1, t+2);
            g.gain.linearRampToValueAtTime(0, t+8);
            
            let pan = actx.createStereoPanner();
            pan.pan.value = Math.random()*2 - 1;

            osc.connect(g);
            g.connect(pan);
            pan.connect(reverbNode);
            osc.start(t);
            osc.stop(t+8);
        }

        function makeDistortionCurve(amount) {
            let k = amount, n_samples = 44100, curve = new Float32Array(n_samples), i = 0, x;
            for ( ; i < n_samples; ++i ) {
                x = i * 2 / n_samples - 1;
                curve[i] = ( 3 + k ) * x * 20 * (Math.PI / 180) / ( Math.PI + k * Math.abs(x) );
            }
            return curve;
        }

        /* ==========================================================================
           SEQUENCER: THE BRAIN
           ========================================================================== */
        
        // E Minor: E, F#, G, A, B, C, D
        const BASS_NOTES = [41.20, 41.20, 41.20, 43.65, 36.71, 48.99]; // E, E, E, F, D, G
        
        function scheduler() {
            while (nextNoteTime < actx.currentTime + 0.1) {
                scheduleNote(tickCount, nextNoteTime);
                advanceNote();
            }
            let timerID = setTimeout(scheduler, 25.0);
        }

        function advanceNote() {
            tickCount++;
            if(tickCount === 16) {
                tickCount = 0;
                phraseCount++;
                if(phraseCount % 4 === 0) barCount++;
            }
            nextNoteTime += SIXTEENTH;
        }

        // --- COMPOSITION MAP ---
        function scheduleNote(beatNumber, t) {
            // beatNumber 0 - 15 (16th notes)
            
            // PHASE 1: ATMOSPHERE INTRO (Bars 0 - 1)
            // PHASE 2: BUILD UP (Bars 2 - 3)
            // PHASE 3: THE DROP (Bars 4+)

            // --- Background Layers (Always On) ---
            if(Math.random() < 0.1 && barCount < 4) playAtmosphere(t); // Flutes die out at drop

            if(barCount >= 0) {
                // Intro Hi-Hats
                if(beatNumber % 4 === 2) { 
                    // soft hat
                }
            }

            // --- THE BUILD UP ---
            if (barCount >= 2 && barCount < 4) {
                // Rising Snares
                if(beatNumber % 4 === 0) { // Quarter notes
                    playKick(t);
                }
                if (barCount === 3 && beatNumber % 2 === 0) { // 8th notes speed up
                    playSnare(t);
                }
                if (barCount === 3 && phraseCount % 4 === 3) { // Roll at end
                     if(beatNumber > 8) playSnare(t + (Math.random()*0.05));
                }
            }

            // --- THE DROP (BAR 4 onwards) ---
            if (barCount >= 4) {
                
                // DRUMS
                if (beatNumber === 0) playKick(t);
                if (beatNumber === 8) playSnare(t);
                
                // Shuffle kick
                if (beatNumber === 11 && Math.random()>0.5) playKick(t); 

                // WOMP BASS PATTERN
                // Pattern length is 16 ticks
                
                const note = BASS_NOTES[phraseCount % BASS_NOTES.length];
                const highNote = note * 2; 

                // Bar A: WOMP - WOMP - WOBBLE
                if (phraseCount % 2 === 0) {
                    if(beatNumber === 0) playWomp(t, SIXTEENTH * 5, 2, note); // WOOOOOMP
                    if(beatNumber === 6) playWomp(t, SIXTEENTH * 2, 6, note); // wub
                    if(beatNumber === 8) playWomp(t, SIXTEENTH * 8, 4, note); // YOI YOI YOI YOI
                } 
                // Bar B: RAPID FIRE / GLITCH
                else {
                    if(beatNumber === 0) playWomp(t, SIXTEENTH * 3, 2, note);
                    if(beatNumber === 3) playWomp(t, SIXTEENTH * 3, 4, note * 1.5); // Fifth interval
                    
                    // The "Growl" (Fast LFO)
                    if(beatNumber === 8) playWomp(t, SIXTEENTH * 4, 12, note); // GGGGGRRRRR
                    
                    // High scream end of phrase
                    if(beatNumber === 12) playWomp(t, SIXTEENTH * 4, 16, highNote); 
                }
            }

            // HUD UPDATES via main thread lookahead hack (visual only)
            setTimeout(() => {
                let txt = `BAR: ${barCount} // PHS: ${phraseCount} \n`;
                if(barCount < 2) txt += ">>> SYSTEM WARMUP... ELECTRONS STABLE";
                else if (barCount < 4) txt += ">>> PRESSURE BUILDING... 61 AGENTS SYNCING";
                else txt += "!!! QUANTUM CRITICALITY !!! WOMP CORE ENGAGED";
                
                if (beatNumber % 4 === 0) hud.innerText = txt + "\n" + Math.random().toString(2).substring(2, 10);
            }, (t - actx.currentTime) * 1000);
        }

        /* ==========================================================================
           VISUALS: QUANTUM CHAOS + ATOMIC VIBRATION
           ========================================================================== */

        class Electron {
            constructor(i) {
                this.i = i;
                this.r = 100 + (i * 2);
                this.ang = (Math.PI * 2 / 61) * i;
                this.val = i + 2; // Collatz seed
                this.color = '#fff';
            }

            draw() {
                // COLLATZ MATH
                if(kickVis > 0.5) { // Step algorithm on beats
                    if (this.val % 2 == 0) this.val = this.val / 2;
                    else this.val = (this.val * 3) + 1;
                    if(this.val < 2) this.val = Math.floor(Math.random()*500)+5;
                }

                // Radius logic: Background vs Drop
                let radius = this.r;
                if(barCount >= 4) {
                     // DURING DROP: Womp warps the orbit
                     radius += (wompLevel * Math.sin(this.val)) * 200; 
                }
                
                let x = cx + Math.cos(this.ang + tickCount*0.1) * radius;
                let y = cy + Math.sin(this.ang + tickCount*0.1) * radius;

                // Shake displacement
                x += (Math.random()-0.5) * snareVis;
                y += (Math.random()-0.5) * snareVis;

                ctx.strokeStyle = `hsla(${(this.val % 360) + (barCount >= 4 ? tickCount*10 : 0)}, 80%, 60%, 0.8)`;
                
                // LINE DRAWING STYLE (Symphonic Horizontal Entry)
                ctx.lineWidth = barCount >= 4 ? 3 : 1;
                
                ctx.beginPath();
                if(this.i % 2 === 0) {
                     // Right Horizontal scan
                     ctx.moveTo(x - (20 + wompLevel * 300), y);
                     ctx.lineTo(x + 20, y);
                } else {
                     // Left Horizontal scan
                     ctx.moveTo(x + (20 + wompLevel * 300), y);
                     ctx.lineTo(x - 20, y);
                }
                ctx.stroke();

                // Core dot
                ctx.fillStyle = '#fff';
                ctx.fillRect(x-1, y-1, 3, 3);
            }
        }

        // Init Atoms
        for(let i=0; i<61; i++) electrons.push(new Electron(i));

        function loop() {
            requestAnimationFrame(loop);
            
            // DECAY VISUALS
            kickVis *= 0.9;
            snareVis *= 0.8;

            // DRAW BACKGROUND
            ctx.fillStyle = `rgba(0,0,0, ${barCount>=4 ? 0.3 : 0.1})`; // Short trails on drop, long trails intro
            ctx.fillRect(0,0,w,h);
            
            // SCREEN SHAKE
            if(wompLevel > 0.1 || snareVis > 1) {
                let shake = (wompLevel * 10) + snareVis;
                ctx.save();
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
            }

            // MIND FUCKERY BLEND MODE
            if(wompLevel > 0.5) ctx.globalCompositeOperation = 'difference'; // Invert colors on bass wobble
            else ctx.globalCompositeOperation = 'screen';

            // THE ATOM CORE
            ctx.beginPath();
            ctx.arc(cx, cy, 10 + (kickVis*50), 0, Math.PI*2);
            ctx.strokeStyle = '#0ff';
            ctx.stroke();

            // ELECTRONS
            electrons.forEach(e => e.draw());
            
            // DROP SPECIFIC FX
            if(barCount >= 4 && wompLevel > 0.8) {
                // Glitch lines
                ctx.fillStyle = Math.random() > 0.5 ? '#f0f' : '#0ff';
                let gy = Math.random() * h;
                ctx.fillRect(0, gy, w, Math.random()*20);
            }

            if(wompLevel > 0.1 || snareVis > 1) ctx.restore(); // Undo Shake
            ctx.globalCompositeOperation = 'source-over';
        }

        // --- INTERACTION ---
        let btn = document.getElementById('start-btn');
        btn.addEventListener('click', () => {
            btn.classList.add('fade-out');
            document.body.style.cursor = 'none'; // bye bye
            initAudio();
        });

    </script>
</body>
</html>

PROGRAM 23
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WOMP // FLUID CHROME</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            cursor: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
            /* The Androgyne Sheen */
            filter: contrast(1.5) hue-rotate(20deg) drop-shadow(0 0 10px rgba(200, 0, 255, 0.5));
        }

        #start {
            position: absolute;
            z-index: 99;
            color: #fff;
            font-family: monospace;
            text-transform: uppercase;
            letter-spacing: 5px;
            font-size: 2rem;
            text-align: center;
            cursor: pointer;
            mix-blend-mode: exclusion;
        }

        .shake {
            animation: tremor 0.1s infinite;
        }

        @keyframes tremor {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            100% { transform: translate(-1px, -2px) rotate(-1deg); }
        }
    </style>
</head>
<body>

    <canvas id="can"></canvas>
    <div id="start">CLICK TO GUSH<br><span style="font-size:12px;opacity:0.6;">(VOLUME WARNING)</span></div>

    <script>
        // CONFIG
        const WOMP_RATE = 2.5; // Wobbles per second (BPM equivalent ~150 half-time)
        const BASS_FREQ = 60;  // Sub Bass
        const MID_FREQ = 180;  // Androgynous Vocal Fundament (G3)
        
        let actx, master, limiter;
        let isRunning = false;
        let cvs, ctx, w, h;
        
        // VISUAL OBJECTS
        let particles = [];
        let centerRadius = 0;
        let wompPhase = 0; // Tracks the LFO for visuals

        // ================= AUDIO ENGINE ================= //
        
        // This is a custom "Vocal Womp" Synthesizer
        function initAudio() {
            actx = new (window.AudioContext || window.webkitAudioContext)();
            master = actx.createGain();
            master.gain.value = 0.5;

            // Limiter to allow aggression without destroying speakers
            let comp = actx.createDynamicsCompressor();
            comp.threshold.value = -10;
            comp.ratio.value = 12;
            
            master.connect(comp);
            comp.connect(actx.destination);

            startWompLoop();
            startSub();
        }

        function makeDistortionCurve(amount) {
            let k = typeof amount === 'number' ? amount : 50,
                n_samples = 44100,
                curve = new Float32Array(n_samples),
                deg = Math.PI / 180,
                i = 0,
                x;
            for ( ; i < n_samples; ++i ) {
                x = i * 2 / n_samples - 1;
                curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) );
            }
            return curve;
        }

        function startWompLoop() {
            const osc1 = actx.createOscillator();
            const osc2 = actx.createOscillator();
            
            // OSC 1: SAW (The Bite)
            osc1.type = 'sawtooth';
            osc1.frequency.value = MID_FREQ;
            
            // OSC 2: TRIANGLE (The Body, slightly detuned)
            osc2.type = 'triangle';
            osc2.frequency.value = MID_FREQ - 2;

            // WAVE SHAPER (The Grit)
            const shaper = actx.createWaveShaper();
            shaper.curve = makeDistortionCurve(100);
            shaper.oversample = '4x';

            // FORMANT FILTER (The "Mouth")
            // A Lowpass filter creates "Oooh", High cutoff creates "Aaaah"
            const filter = actx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 6; // Very Resonant
            
            // LFO (The Rhythm)
            const lfo = actx.createOscillator();
            lfo.type = 'sawtooth'; // Hard ramp for aggressive punch
            lfo.frequency.value = WOMP_RATE;

            const lfoGain = actx.createGain();
            lfoGain.gain.value = 2500; // How wide the filter opens

            // VCA (Volume gating - chopping the sound)
            const gate = actx.createGain();
            gate.gain.value = 0;
            const gateLfoGain = actx.createGain();
            gateLfoGain.gain.value = 1.0;

            // WIRING
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            
            // Connecting LFO to volume so it pulses
            lfo.connect(gateLfoGain);
            gateLfoGain.connect(gate.gain);

            osc1.connect(shaper);
            osc2.connect(shaper);
            shaper.connect(filter);
            filter.connect(gate);
            gate.connect(master);

            osc1.start();
            osc2.start();
            lfo.start();
            
            // VISUAL SYNC: Extract the LFO data roughly for the canvas
            setInterval(() => {
                const now = actx.currentTime;
                // Simulating LFO phase for visual extraction 
                // Sawtooth rises 0->1 repeatedly
                wompPhase = (now * WOMP_RATE) % 1;
            }, 16);
        }

        function startSub() {
            const sub = actx.createOscillator();
            sub.type = 'sine';
            sub.frequency.value = BASS_FREQ; // 60Hz constant hum
            
            const gain = actx.createGain();
            gain.gain.value = 0.8;
            
            sub.connect(gain);
            gain.connect(master);
            sub.start();
        }

        // ================= VISUAL ENGINE ================= //

        function initVis() {
            cvs = document.getElementById('can');
            ctx = cvs.getContext('2d');
            resize();
            window.addEventListener('resize', resize);
            loop();
        }

        function resize() {
            w = window.innerWidth;
            h = window.innerHeight;
            cvs.width = w;
            cvs.height = h;
        }

        // PARTICLE CLASS: "The Gush"
        class Streamer {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = w / 2;
                this.y = h / 2;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 5;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.history = [];
                // Androgynous gradient colors: Cyan, Magenta, White, Neon Violet
                const cols = ['#00FFFF', '#FF00FF', '#E0E0E0', '#9D00FF'];
                this.col = cols[Math.floor(Math.random()*cols.length)];
                this.life = 1;
                this.width = Math.random() * 4 + 1;
            }

            update(burstMultiplier) {
                // If the WOMP is hitting (sawtooth drops), boost speed
                let boost = (1 + burstMultiplier * 2);
                
                this.x += this.vx * boost;
                this.y += this.vy * boost;
                this.life -= 0.02;

                this.history.push({x: this.x, y: this.y});
                if(this.history.length > 5) this.history.shift();

                if(this.life <= 0 || this.x < 0 || this.x > w || this.y < 0 || this.y > h) {
                    this.reset();
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                for(let p of this.history) ctx.lineTo(p.x, p.y);
                ctx.strokeStyle = this.col;
                ctx.lineWidth = this.width * (wompPhase + 0.5); // Thicker on womp
                ctx.lineCap = 'round';
                
                // Chrome shine effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.col;
                
                ctx.stroke();
            }
        }

        // Create initial particles
        for(let i=0; i<150; i++) particles.push(new Streamer());

        function loop() {
            requestAnimationFrame(loop);
            if(!isRunning) return;

            // Clear with fading trails (The Fluid effect)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            ctx.fillRect(0,0,w,h);
            ctx.globalCompositeOperation = 'lighten';

            // THE PULSE
            // wompPhase goes 0 -> 1 over and over.
            // When phase is low, it means the synth envelope is open.
            
            // Screen Shake calculation
            if (wompPhase > 0.8) { 
                let shake = (wompPhase - 0.8) * 40;
                let sx = (Math.random()-0.5) * shake;
                let sy = (Math.random()-0.5) * shake;
                ctx.translate(sx, sy);
                document.body.style.backgroundColor = '#100018'; // Flash purple black
            } else {
                ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
                document.body.style.backgroundColor = '#000';
            }

            // Draw Core
            let rad = 50 + (wompPhase * 100);
            let grad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, rad);
            grad.addColorStop(0, '#FFF');
            grad.addColorStop(0.3, '#00FFFF'); // Cyan
            grad.addColorStop(0.6, '#9D00FF'); // Violet
            grad.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(w/2, h/2, rad, 0, Math.PI*2);
            ctx.fill();

            // Particles
            particles.forEach(p => {
                p.update(wompPhase);
                p.draw();
            });
            
            // THE FLUID OVERLAY
            // Chromatic aberration rings
            ctx.beginPath();
            ctx.arc(w/2, h/2, rad * 1.5, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 - (wompPhase*0.5)})`;
            ctx.lineWidth = 10;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(w/2, h/2, rad * 1.6, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(255, 0, 255, ${0.5 - (wompPhase*0.5)})`;
            ctx.lineWidth = 10;
            ctx.stroke();
        }


        // START HANDLER
        document.getElementById('start').addEventListener('click', function() {
            this.style.display = 'none';
            isRunning = true;
            initAudio();
            initVis();
            actx.resume();
        });

    </script>
</body>
</html>

PROGRAM 24
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ONYX // VECTOR HARVEST</title>
<style>
:root { --acc: #00f3ff; --bg: #080808; --w: #eee; --d: #111; }
body {
margin: 0; background: var(--bg); overflow: hidden;
font-family: 'Consolas', 'Monaco', monospace; color: var(--w);
height: 100vh; width: 100vw;
}
canvas { position: absolute; top: 0; left: 0; z-index: 0; mix-blend-mode: screen; }
code
Code
#ui-grid {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 10; pointer-events: none;
    background: linear-gradient(transparent 95%, rgba(0, 243, 255, 0.1) 100%),
                linear-gradient(90deg, transparent 95%, rgba(0, 243, 255, 0.1) 100%);
    background-size: 40px 40px;
}

#main {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    text-align: center; z-index: 20; pointer-events: auto;
}

h1 { 
    font-size: 4rem; letter-spacing: -2px; margin: 0; color: var(--w); 
    text-shadow: 0 0 20px var(--acc); font-weight: 400;
}

#btn-init {
    background: transparent; color: var(--acc); border: 2px solid var(--acc);
    padding: 15px 60px; font-size: 1rem; font-family: inherit; 
    margin-top: 30px; cursor: pointer; text-transform: uppercase; letter-spacing: 4px;
    transition: 0.3s;
}
#btn-init:hover { background: var(--acc); color: #000; box-shadow: 0 0 30px var(--acc); }

.monitor {
    position: absolute; font-size: 10px; color: var(--acc); opacity: 0.7;
}
#top-left { top: 30px; left: 30px; text-align: left; }
#btm-right { bottom: 30px; right: 30px; text-align: right; }

.active-state #main { opacity: 0; pointer-events: none; }
.active-state #play-info { opacity: 1; }

#play-info {
    position: absolute; bottom: 50px; left: 0; width: 100%; 
    text-align: center; opacity: 0; transition: 0.5s; z-index: 20;
}
.p-bar { width: 300px; height: 4px; background: #222; display: inline-block; margin-top: 10px; position: relative; }
.p-fill { width: 0%; height: 100%; background: var(--acc); transition: width 0.2s linear; box-shadow: 0 0 10px var(--acc);}
</style>
</head>
<body>
<div id="ui-grid"></div>
<div id="top-left">
SYSTEM: ONYX AUDIOGRID<br>
COMPOSER: A.I. LOGIC<br>
STATUS: IDLE
</div>
<div id="btm-right">
FREQ: 44.1KHZ<br>
LATENCY: 2ms<br>
RENDER: WEBGL
</div>
<div id="main">
<h1>VECTOR HARVEST</h1>
<button id="btn-init">INITIALIZE PROTOCOL</button>
</div>
<div id="play-info">
<div id="seq-step">WAITING</div>
<div class="p-bar"><div class="p-fill" id="p-fill"></div></div>
</div>
<canvas id="c"></canvas>
<script>
/*
COMPOSITION: VECTOR HARVEST
GENRE: Techstep / Neurofunk
BPM: 172
KEY: D Minor
*/

const ctx = document.getElementById('c').getContext('2d');
let w, h;

// AUDIO CONTEXT
let ac, master, limiter, delay, verb;
let isRunning = false;
let startTime = 0;

// CONSTANTS
const BPM = 172;
const BEAT = 60 / BPM;
const BAR = BEAT * 4;
const T_SIX = BEAT / 4;

// SCALE (D Minor)
const MIDI = n => 440 * Math.pow(2, (n - 69) / 12);
// D1, F1, G1, A1, D2, F2, A2, D3
const NOTES = {
D1: MIDI(38), F1: MIDI(41), G1: MIDI(43), A1: MIDI(45),
Bb1: MIDI(46), D2: MIDI(50), F2: MIDI(53), A2: MIDI(57),
C3: MIDI(60), D3: MIDI(62), E3: MIDI(64), F3: MIDI(65), A3: MIDI(69)
};

// ==================== AUDIO ENGINE ==================== //

async function initAudio() {
const AC = window.AudioContext || window.webkitAudioContext;
ac = new AC();
await ac.resume();

// Master Chain
master = ac.createGain();
master.gain.value = 0.7;

// Hard Limiter
limiter = ac.createDynamicsCompressor();
limiter.threshold.value = -2;
limiter.ratio.value = 20;
limiter.attack.value = 0.001;

// Aux Effects (Stereo Ping Pong Delay)
delay = createDelay();

// Reverb (Convolver)
verb = await createReverb();

master.connect(limiter).connect(ac.destination);
}

// AUX FX GENERATORS
function createDelay() {
const dL = ac.createDelay(); dL.delayTime.value = BEAT * 0.75; // Dotted 8th
const dR = ac.createDelay(); dR.delayTime.value = BEAT * 0.5; // 8th
const fb = ac.createGain(); fb.gain.value = 0.4;
const merger = ac.createChannelMerger(2);
const input = ac.createGain();

input.connect(dL); input.connect(dR);
dL.connect(merger, 0, 0); dR.connect(merger, 0, 1);
dL.connect(fb); dR.connect(fb); fb.connect(input);
merger.connect(master);
return input;
}

async function createReverb() {
// Synthesize a metallic impulse
const len = ac.sampleRate * 1.5;
const buf = ac.createBuffer(2, len, ac.sampleRate);
for(let c=0;c<2;c++){
const ch = buf.getChannelData(c);
for(let i=0;i<len;i++) ch[i] = (Math.random()*2-1) * Math.exp(-i/(len/10));
}
const con = ac.createConvolver(); con.buffer = buf;
const inG = ac.createGain(); const outG = ac.createGain(); outG.gain.value = 0.2;
inG.connect(con).connect(outG).connect(master);
return inG;
}

// === INSTRUMENTS === //

// 1. THE GROWL (FM Synthesis Bass)
function bassFM(t, note, dur, modIdx = 5, articulate = true) {
const c = ac.createOscillator(); // Carrier
const m = ac.createOscillator(); // Modulator
const mG = ac.createGain(); // Mod Amplitude
const m2 = ac.createOscillator(); // Sub Mod

// Setup Frequencies
c.frequency.value = note;
c.type = 'sine';

// Ratio 1:2 for harsh octave harmonic, slightly detuned
m.frequency.value = note * 2 + (Math.random()*2);
m.type = 'sawtooth';

m2.frequency.value = 6; // LFO Speed
const lfoG = ac.createGain();
lfoG.gain.value = 10;

// Envelope
const g = ac.createGain();
g.gain.setValueAtTime(0, t);

if (articulate) {
// Wah shape
g.gain.linearRampToValueAtTime(1, t + 0.05);
g.gain.exponentialRampToValueAtTime(0.01, t + dur);
// Mod Index sweep (The "Yoi" sound)
mG.gain.setValueAtTime(0, t);
mG.gain.linearRampToValueAtTime(note * modIdx, t + (dur*0.3));
mG.gain.linearRampToValueAtTime(0, t + dur);
} else {
// Sustain drone
g.gain.linearRampToValueAtTime(0.8, t+0.1);
g.gain.linearRampToValueAtTime(0, t+dur);
mG.gain.value = note * 2;
}

// Distort Chain
const shaper = ac.createWaveShaper();
shaper.curve = new Float32Array(44100).map((_,i) => {
const x = (i/44100)*2-1;
return Math.tanh(x*5); // Soft clip
});

// Routing
m.connect(mG).connect(c.frequency);
c.connect(shaper).connect(g).connect(master);

c.start(t); c.stop(t + dur);
m.start(t); m.stop(t + dur);

viz.kick = 0.5; // shake screen on bass too
}

// 2. CYBER KICK (Pitch envelope pulse)
function kick(t) {
const o = ac.createOscillator();
const g = ac.createGain();
o.frequency.setValueAtTime(180, t);
o.frequency.exponentialRampToValueAtTime(45, t + 0.1);

g.gain.setValueAtTime(1.5, t);
g.gain.exponentialRampToValueAtTime(0.01, t + 0.25);

o.connect(g).connect(limiter); // Bypass master vol for punch
o.start(t); o.stop(t + 0.25);

viz.kick = 1.0;
}

// 3. TEK SNARE (Noise + Fundamental)
function snare(t) {
const n = ac.createBufferSource();
n.buffer = ((() => {
const b = ac.createBuffer(1, 44100 * 0.2, 44100);
const d = b.getChannelData(0);
for(let i=0; i<d.length; i++) d[i] = Math.random() * 2 - 1;
return b;
})());

const tri = ac.createOscillator(); tri.type = 'triangle';
tri.frequency.setValueAtTime(220, t);
tri.frequency.linearRampToValueAtTime(100, t+0.1);

const nG = ac.createGain(); nG.gain.setValueAtTime(1, t); nG.gain.exponentialRampToValueAtTime(0.01, t+0.15);
const tG = ac.createGain(); tG.gain.setValueAtTime(0.8, t); tG.gain.exponentialRampToValueAtTime(0.01, t+0.1);

// Bandpass filter to make noise snap
const f = ac.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 2000; f.Q.value = 1;

n.connect(f).connect(nG).connect(master);
n.connect(f).connect(nG).connect(verb); // Reverb send
tri.connect(tG).connect(master);

n.start(t); tri.start(t); tri.stop(t+0.15);

viz.snare = 1.0;
}

// 4. HAT (Metallic Highpass)
function hat(t, open = false) {
const len = open ? 0.3 : 0.05;
const n = ac.createOscillator(); // FM Hat
n.type = 'square';
const n2 = ac.createOscillator(); n2.type='square'; n2.frequency.value=8400;
n2.connect(n.frequency);

const f = ac.createBiquadFilter(); f.type='highpass'; f.frequency.value=6000;
const g = ac.createGain();
g.gain.setValueAtTime(open?0.1:0.15, t);
g.gain.exponentialRampToValueAtTime(0.001, t+len);

n.connect(f).connect(g).connect(master);
n.start(t); n2.start(t);
n.stop(t+len); n2.stop(t+len);
}

// 5. PLUCK (Arpeggiator sound)
function pluck(t, note) {
const o = ac.createOscillator(); o.type='sawtooth'; o.frequency.value = note;
const f = ac.createBiquadFilter(); f.type='lowpass';

f.frequency.setValueAtTime(note, t);
f.frequency.exponentialRampToValueAtTime(note * 4, t + 0.01); // pluck attack
f.frequency.exponentialRampToValueAtTime(note, t + 0.2);

const g = ac.createGain(); g.gain.value=0.15; g.gain.exponentialRampToValueAtTime(0.001, t+0.4);

o.connect(f).connect(g).connect(master);
g.connect(delay); // Send to delay

o.start(t); o.stop(t+0.4);
}

// ==================== COMPOSITION / SEQUENCER ==================== //

let nextT = 0;
let step = 0;
const TOTAL_STEPS = 16 * 64; // 64 Bars

function scheduler() {
if (!isRunning) return;

const lookahead = 0.1;
while (nextT < ac.currentTime + lookahead) {
runPattern(step, nextT);
nextT += T_SIX;
step++;
if(step >= TOTAL_STEPS) {
isRunning = false;
finish();
}
}
requestAnimationFrame(scheduler);
}

function runPattern(s, t) {
const bar = Math.floor(s / 16);
const bStep = s % 16;

updateUI(bar, s);

// === STRUCTURE ===
// 0-8: INTRO (Arps)
// 8-16: DRUMS ENTER
// 16-24: BUILD (Filter Riser)
// 24-40: DROP 1 (Main Neuro Theme)
// 40-48: BREAKDOWN (Atmospheric)
// 48-64: DROP 2 (Max Chaos)

const isIntro = bar < 16;
const isBuild = bar >= 16 && bar < 24;
const isDrop = (bar >= 24 && bar < 40) || bar >= 48;
const isBreak = bar >= 40 && bar < 48;

// --- ARPEGGIATOR ---
if ((isIntro || isBreak) && bStep % 2 === 0) {
// Simple Dm pattern ascending
const notes = [NOTES.D3, NOTES.F3, NOTES.A3, NOTES.D2];
const idx = (bStep / 2) % 4;
pluck(t, notes[idx]);
if (bar >= 4 && Math.random()>0.8) pluck(t, NOTES.A2); // harmonizing rand
}
if (isDrop && bStep % 4 === 0 && Math.random() > 0.5) {
// Random glissando artifacts in drop
pluck(t, NOTES.E3);
}

// --- DRUMS (Standard DnB: Kick on 0, Snare on 4 & 12? No, standard is Snare on 4 & 12)
// Note: In 16th steps:
// Beat: 1...2...3...4...
// Step: 0...4...8...12..
// Two Step Pattern: Kick(0), Snare(8). Wait...
// BPM is 172. Step is 1/16.
// Standard Two Step: Kick on 0, Snare on 8. (With ghost notes)

const drumsActive = (bar >= 8 && !isBreak) || (bar >= 16);

if (drumsActive) {
// KICK
if (bStep === 0) kick(t);
if (bStep === 10 && (bar % 2 === 0)) kick(t); // The "Skippy" Kick
if (isDrop && bStep === 7) kick(t); // Aggressive neuro kick pattern

// SNARE
if (bStep === 8) snare(t);

// BUILD SNARE
if (isBuild && bar >= 22) {
if(bStep % 2 === 0) snare(t); // roll
}

// HATS
if (bStep % 2 === 0) hat(t);
if (bStep % 4 === 2) hat(t, true); // open hat offbeat
}

// --- BASS ---
if (isDrop) {
// PATTERN A: The "Call"
if (bar % 4 === 0) {
if (bStep === 0) bassFM(t, NOTES.D1, BEAT * 1.5, 4);
if (bStep === 11) bassFM(t, NOTES.F1, BEAT * 0.5, 8); // flick
}
// PATTERN B: The "Response"
else if (bar % 4 === 1) {
if (bStep === 0) bassFM(t, NOTES.C3, BEAT, 10); // high pitch growl
if (bStep === 4) bassFM(t, NOTES.D1, BEAT, 2);
}
// PATTERN C: Rolling
else {
if (bStep === 0) bassFM(t, NOTES.D1, BEAT * 2, 5, false);
if (bStep === 12) bassFM(t, NOTES.G1, BEAT, 15); // womp
}
} else if (isBuild) {
// Rising tension bass
if (bStep === 0 && bar % 2 === 0) bassFM(t, NOTES.D1, BEAT * 4, 2, false);
} else if (bar >= 4 && bar < 8) {
// Intro subs
if (bStep === 0) bassFM(t, NOTES.D1, BEAT*4, 1, false);
}
}

function updateUI(bar, s) {
document.getElementById('p-fill').style.width = (s/TOTAL_STEPS*100) + '%';

let stateText = "INTRO // UPLINK";
if (bar >= 16) stateText = "SEQUENCE // ACCEL";
if (bar >= 24) stateText = ">>> CORE DUMP <<<";
if (bar >= 40) stateText = "SYSTEM IDLE";
if (bar >= 48) stateText = "CRITICAL FAILURE";

document.getElementById('seq-step').innerText = `${stateText} [BAR ${bar+1}]`;
}

function finish() {
document.getElementById('main').style.opacity = 1;
document.querySelector('h1').innerText = "SEQUENCE COMPLETE";
document.getElementById('btn-init').style.display = 'inline-block';
document.getElementById('btn-init').innerText = "RESTART";
document.body.classList.remove('active-state');
}

// ==================== VISUALS ==================== //

let viz = { kick: 0, snare: 0 };

function initViz() {
w = document.getElementById('c').width = window.innerWidth;
h = document.getElementById('c').height = window.innerHeight;
}
window.onresize = initViz;

function draw() {
requestAnimationFrame(draw);

// Decay triggers
viz.kick *= 0.9;
viz.snare *= 0.9;

// BG clearing (Trail effect)
ctx.fillStyle = 'rgba(8,8,8,0.2)';
ctx.fillRect(0, 0, w, h);

const cx = w/2;
const cy = h/2;

// Shake
const dx = (Math.random()-0.5) * viz.kick * 20;
const dy = (Math.random()-0.5) * viz.kick * 20;

ctx.save();
ctx.translate(dx, dy);

// Central Pulse (Snare)
if (viz.snare > 0.01) {
ctx.beginPath();
ctx.arc(cx, cy, viz.snare * 200, 0, Math.PI*2);
ctx.strokeStyle = `rgba(255, 255, 255, ${viz.snare})`;
ctx.lineWidth = 2;
ctx.stroke();
}

// Grid lines reacting to bass
ctx.beginPath();
const lines = 12;
for (let i=0; i<lines; i++) {
const angle = (i/lines) * Math.PI*2;
const len = 100 + (viz.kick * 150);
const x1 = cx + Math.cos(angle) * 50;
const y1 = cy + Math.sin(angle) * 50;
const x2 = cx + Math.cos(angle) * len;
const y2 = cy + Math.sin(angle) * len;

ctx.strokeStyle = i%2===0 ? '#00f3ff' : '#ff0055';
ctx.lineWidth = 2 + (viz.kick * 4);
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
}
ctx.stroke();

// Rotating Ring
ctx.beginPath();
const r = 100 + (viz.kick * 20);
ctx.arc(cx, cy, r, 0, Math.PI*2);
ctx.strokeStyle = 'rgba(0, 243, 255, 0.5)';
ctx.lineWidth = 4;
ctx.stroke();

ctx.restore();
}

// BOOTSTRAP
initViz();
draw();

document.getElementById('btn-init').addEventListener('click', async () => {
document.body.classList.add('active-state');
await initAudio();
startTime = ac.currentTime + 0.1;
nextT = startTime;
step = 0;
isRunning = true;
scheduler();
});

</script>
</body>
</html>

PROGRAM 25
___________________________________________________

