<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BACH // TESSERACT</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Orbitron:wght@400;900&display=swap');

    :root {
        --void: #000000;
        --light: #e0e0e0;
        --hyper: #00ffcc;
        --dim: #1a1a2e;
    }

    body {
        margin: 0;
        background: var(--void);
        overflow: hidden;
        font-family: 'Cinzel', serif;
        color: var(--light);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.92);
        z-index: 10;
        transition: opacity 1.5s;
    }

    h1 {
        font-family: 'Orbitron', sans-serif;
        font-size: 4rem;
        margin: 0;
        color: var(--light);
        text-shadow: 0 0 20px var(--hyper);
        letter-spacing: 10px;
        text-align: center;
        font-weight: 900;
    }

    p {
        font-family: 'Cinzel', serif;
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.2rem;
        color: var(--hyper);
        opacity: 0.8;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 30px;
        left: 30px;
        font-family: 'Orbitron', sans-serif;
        font-size: 12px;
        pointer-events: none;
        z-index: 5;
        color: var(--hyper);
        border-left: 1px solid var(--hyper);
        padding-left: 15px;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>J.S. BACH<br><span style="font-size: 2rem; letter-spacing: 20px;">TESSERACT</span></h1>
    <p>[ ENTER THE HYPERCUBE ]</p>
    <p style="font-size: 0.7rem; color: #666; margin-top: 3rem;">MOUSE Y = TIME DILATION</p>
</div>

<div id="hud">
    DIMENSION: 5<br>
    STATUS: QUANTUM SUPERPOSITION
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * BACH TESSERACT ENGINE
 * 5D Spectral Granulation + Hypercube Visuals
 */

// --- AUDIO ENGINE (The Quantum Cello) ---
const AudioEngine = {
    ctx: null,
    master: null,
    convolver: null,
    
    // Granular buffers
    grains: [],
    
    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.5;
        
        // 5D Reverb (Infinite Space)
        AudioEngine.convolver = AudioEngine.ctx.createConvolver();
        AudioEngine.convolver.buffer = await AudioEngine.createImpulse(5.0, 4.0); // 5s tail
        
        AudioEngine.master.connect(AudioEngine.convolver);
        AudioEngine.convolver.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = length - i;
            // Reverse exponential for "swelling" space
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // Plays a "Grain" of the note
    playGrain: (freq, time, panX, panY, panZ) => {
        if(!AudioEngine.ctx) return;
        
        const osc = AudioEngine.ctx.createOscillator();
        const amp = AudioEngine.ctx.createGain();
        const panner = AudioEngine.ctx.createStereoPanner();
        const filter = AudioEngine.ctx.createBiquadFilter();
        
        // 5D Tone: Sine modulated by random noise (texture)
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        // Filter based on "Z" (Depth)
        // Far away = Lowpass, Close = Highpass
        if (panZ < 0) {
            filter.type = 'lowpass';
            filter.frequency.value = 500 + (panZ + 1) * 2000; 
        } else {
            filter.type = 'highpass';
            filter.frequency.value = 100 + panZ * 500;
        }
        
        // Panning X (Left/Right)
        panner.pan.value = panX;
        
        // Envelope (Grain shape)
        const dur = 0.1 + Math.random() * 0.2; // Short grains
        amp.gain.setValueAtTime(0, time);
        amp.gain.linearRampToValueAtTime(0.1 * (1-Math.abs(panY)), time + dur/2); // Y affects volume
        amp.gain.linearRampToValueAtTime(0, time + dur);
        
        // Chain
        osc.connect(filter);
        filter.connect(panner);
        panner.connect(amp);
        amp.connect(AudioEngine.master);
        
        osc.start(time);
        osc.stop(time + dur);
    },
    
    // Triggers a full note as a cloud of grains
    playNote: (freq, time) => {
        // Burst of 10 grains scattered in 5D space
        for(let i=0; i<8; i++) {
            const offset = Math.random() * 0.1;
            const px = (Math.random() * 2 - 1);
            const py = (Math.random() * 2 - 1);
            const pz = (Math.random() * 2 - 1);
            // Slight detune for thickness
            const f = freq + (Math.random() * 4 - 2);
            AudioEngine.playGrain(f, time + offset, px, py, pz);
        }
        
        // Fundamental Anchor (The Cello body)
        const fund = AudioEngine.ctx.createOscillator();
        fund.type = 'triangle';
        fund.frequency.value = freq;
        const fAmp = AudioEngine.ctx.createGain();
        fAmp.gain.setValueAtTime(0, time);
        fAmp.gain.linearRampToValueAtTime(0.2, time + 0.05);
        fAmp.gain.exponentialRampToValueAtTime(0.001, time + 1.5);
        
        fund.connect(fAmp);
        fAmp.connect(AudioEngine.master);
        fund.start(time);
        fund.stop(time + 1.5);
    }
};

// --- THE COMPOSITION (Bach Prelude G Major) ---
const BACH_NOTES = [
    // Measure 1
    ['G2', 0.0], ['D3', 0.25], ['B3', 0.5], ['A3', 0.75], ['B3', 1.0], ['D3', 1.25], ['B3', 1.5], ['D3', 1.75],
    // Measure 1 (repeat pattern)
    ['G2', 2.0], ['D3', 2.25], ['B3', 2.5], ['A3', 2.75], ['B3', 3.0], ['D3', 3.25], ['B3', 3.5], ['D3', 3.75],
    
    // Measure 2
    ['G2', 4.0], ['E3', 4.25], ['C4', 4.5], ['B3', 4.75], ['C4', 5.0], ['E3', 5.25], ['C4', 5.5], ['E3', 5.75],
    ['G2', 6.0], ['E3', 6.25], ['C4', 6.5], ['B3', 6.75], ['C4', 7.0], ['E3', 7.25], ['C4', 7.5], ['E3', 7.75],
    
    // Measure 3
    ['G2', 8.0], ['F#3', 8.25], ['C4', 8.5], ['B3', 8.75], ['C4', 9.0], ['F#3', 9.25], ['C4', 9.5], ['F#3', 9.75],
    ['G2', 10.0], ['F#3', 10.25], ['C4', 10.5], ['B3', 10.75], ['C4', 11.0], ['F#3', 11.25], ['C4', 11.5], ['F#3', 11.75],
    
    // Measure 4 (Back to G)
    ['G2', 12.0], ['D3', 12.25], ['B3', 12.5], ['A3', 12.75], ['B3', 13.0], ['D3', 13.25], ['B3', 13.5], ['D3', 13.75],
    ['G2', 14.0], ['D3', 14.25], ['B3', 14.5], ['A3', 14.75], ['B3', 15.0], ['D3', 15.25], ['B3', 15.5], ['D3', 15.75],
    
    // Measure 5 (Climb)
    ['G2', 16.0], ['E3', 16.25], ['B3', 16.5], ['A3', 16.75], ['B3', 17.0], ['E3', 17.25], ['B3', 17.5], ['E3', 17.75]
];

// Map Note Names to Freq
const FREQ_MAP = {
    'G2': 98.00, 'A2': 110.00, 'B2': 123.47, 'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F#3': 185.00,
    'G3': 196.00, 'A3': 220.00, 'B3': 246.94, 'C4': 261.63, 'D4': 293.66
};

// --- SEQUENCER ---
let startTime = 0;
let noteIdx = 0;
let speedMult = 1.0;

function scheduler() {
    if (!AudioEngine.ctx) return;
    
    const lookahead = 0.1;
    const currentTime = AudioEngine.ctx.currentTime;
    
    // Loop
    if (noteIdx >= BACH_NOTES.length) {
        noteIdx = 0;
        startTime = currentTime;
    }
    
    while (noteIdx < BACH_NOTES.length) {
        const noteData = BACH_NOTES[noteIdx];
        const noteTime = startTime + (noteData[1] * 0.6 * speedMult); // 0.6 = base tempo scaling
        
        if (noteTime < currentTime + lookahead) {
            const freq = FREQ_MAP[noteData[0]];
            if (freq) {
                AudioEngine.playNote(freq, noteTime);
                spawnVisual(noteData[0]);
            }
            noteIdx++;
        } else {
            break;
        }
    }
    
    requestAnimationFrame(scheduler);
}

// --- 4D VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
let angleX = 0;
let angleY = 0;
let angleZ = 0;
let angleW = 0;

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Matrix Math
function mult(v, m) {
    let result = [];
    for (let i = 0; i < m.length; i++) { // rows
        let sum = 0;
        for (let j = 0; j < v.length; j++) { // cols
            sum += m[i][j] * v[j];
        }
        result.push(sum);
    }
    return result;
}

// Tesseract Geometry (16 points)
// x, y, z, w (4D coordinates)
const points = [];
for(let i=0; i<16; i++) {
    let x = (i & 1) ? 1 : -1;
    let y = (i & 2) ? 1 : -1;
    let z = (i & 4) ? 1 : -1;
    let w_coord = (i & 8) ? 1 : -1;
    points.push([x, y, z, w_coord]);
}

// Connections
// A mess of lines to form the hypercube
// Simplified: Connect if hamming distance is 1
const edges = [];
for(let i=0; i<16; i++) {
    for(let j=i+1; j<16; j++) {
        let dist = 0;
        // Check coordinate differences
        if (points[i][0] !== points[j][0]) dist++;
        if (points[i][1] !== points[j][1]) dist++;
        if (points[i][2] !== points[j][2]) dist++;
        if (points[i][3] !== points[j][3]) dist++;
        
        if (dist === 1) {
            edges.push([i, j]);
        }
    }
}

// Active notes highlighting
let activePulse = 0;
let activeHue = 0;

function spawnVisual(noteName) {
    activePulse = 1.0;
    // Map pitch to hue
    const freq = FREQ_MAP[noteName];
    activeHue = (freq - 98) * 2; 
}

function draw() {
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(0,0,w,h);
    
    const projected = [];
    
    // Rotation Matrices (4D)
    // XY, XZ, XW, YZ, YW, ZW
    // We'll rotate XW and YZ
    
    const t = Date.now() * 0.0005 * (1/speedMult);
    
    for (let i = 0; i < points.length; i++) {
        let p = points[i];
        
        // Rotate ZW plane
        let angle = t;
        let cos = Math.cos(angle);
        let sin = Math.sin(angle);
        
        // Apply rotations manually for speed
        // Z, W rotation
        let z = p[2] * cos - p[3] * sin;
        let w_coord = p[2] * sin + p[3] * cos;
        let x = p[0];
        let y = p[1];
        
        // Rotate XY plane
        let x2 = x * Math.cos(angle*0.5) - y * Math.sin(angle*0.5);
        let y2 = x * Math.sin(angle*0.5) + y * Math.cos(angle*0.5);
        
        // 4D to 3D Projection (Perspective)
        let distance = 3;
        let w_inv = 1 / (distance - w_coord);
        
        let p3 = [
            x2 * w_inv,
            y2 * w_inv,
            z * w_inv
        ];
        
        // 3D to 2D Projection
        let z_inv = 1 / (distance - p3[2]);
        let p2 = [
            p3[0] * z_inv * 500 + w/2,
            p3[1] * z_inv * 500 + h/2
        ];
        
        projected.push(p2);
        
        // Draw Vertices
        ctx.beginPath();
        ctx.arc(p2[0], p2[1], 3 + (activePulse * 5), 0, Math.PI*2);
        ctx.fillStyle = `hsla(${activeHue}, 100%, 50%, 1)`;
        ctx.fill();
    }
    
    // Draw Edges
    ctx.lineWidth = 1 + (activePulse * 3);
    ctx.strokeStyle = `hsla(${activeHue + 180}, 100%, 50%, ${0.2 + activePulse * 0.5})`;
    
    for (let i = 0; i < edges.length; i++) {
        const a = projected[edges[i][0]];
        const b = projected[edges[i][1]];
        
        ctx.beginPath();
        ctx.moveTo(a[0], a[1]);
        ctx.lineTo(b[0], b[1]);
        ctx.stroke();
    }
    
    activePulse *= 0.9;
    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        document.getElementById('overlay').classList.add('hidden');
        startTime = AudioEngine.ctx.currentTime;
        scheduler();
    }
});

document.addEventListener('mousemove', (e) => {
    const y = e.clientY / window.innerHeight;
    // Map Y to Speed (0.5x to 2.0x)
    speedMult = 0.5 + (y * 1.5);
});

draw();

</script>
</body>
</html>

PROGRAM 1
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CLAPTON // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Courier+New:wght@700&display=swap');

    :root {
        --bg: #2b1b17; /* Coffee/Brown */
        --ink: #f4e1d2; /* Cream */
        --accent: #d2691e; /* Chocolate/Orange */
        --gold: #daa520;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Abril Fatface', cursive;
        color: var(--ink);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(43, 27, 23, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 5rem;
        margin: 0;
        color: var(--ink);
        text-shadow: 2px 2px 0px var(--accent);
        letter-spacing: 2px;
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--gold);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--ink);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>SLOWHAND</h1>
    <p>[ CLICK TO PLAY THE BLUES ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = TONE KNOB // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: WOMAN TONE (NECK PICKUP)<br>
    BPM: 90 (Expressive)
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * CLAPTON ENGINE
 * Woman Tone Physics + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 90, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    drive: null,
    driveGain: null,
    reverb: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.5;

        // WOMAN TONE CHAIN (Smooth Overdrive)
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(100); // Warm clipping
        AudioEngine.drive.oversample = '4x';
        
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 0.6; 

        // Room Reverb
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(1.5, 3.0);
        
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.25;

        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(verbMix);
        verbMix.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            // Soft clipping for blues
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playString: (stringIdx, fret, time, duration = 1.0, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Woman Tone: Dominant Sine (Fundamental) + Soft Square (Hollow)
        osc1.type = 'sine'; 
        osc2.type = 'square'; 
        
        // Pitch Logic
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.2); // Slower, bluesy slide
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
            
            // Vibrato logic
            if (bendType === 'vib') {
                const vib = AudioEngine.ctx.createOscillator();
                vib.frequency.value = 4; // Slow hand vibrato
                const vibGain = AudioEngine.ctx.createGain();
                vibGain.gain.value = freq * 0.01; // Wide
                vib.connect(vibGain);
                vibGain.connect(osc1.frequency);
                vibGain.connect(osc2.frequency);
                vib.start(t);
                vib.stop(t+duration);
            }
        }

        // Filter (Rolled off Tone Knob)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800; // The "Woman Tone" sweet spot
        filter.Q.value = 2.0; // Slight resonance for singing quality

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.6, t + 0.05); // Smooth attack
        amp.gain.exponentialRampToValueAtTime(0.4, t + 0.3); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix: Mostly Sine/Filtered Square
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.7;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.3;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setTone: (val) => {
        // Map 0-1 to Tone Knob (Filter Cutoff)
        // 400Hz (Dark) to 2000Hz (Bright)
        // We want to default to ~800Hz
        // The UI calls this "Mouse Y" so let's map it dynamically if needed, but 'playString' creates new nodes.
        // For global tone control, we'd need a master filter, but here we bake it per note.
        // Let's just leave it baked for the "Woman Tone" authenticity.
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null, bend = null) {
    TAB.push({ beat, string, fret, type, target, bend });
}

// -- BUILD THE SOLO --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;
const T = 0.33; // Triplet feel roughly

// Phrase 1
// D-9-11-12 G-12~ G-11-11~
addNote(b, 3, 9); b+=S;
addNote(b, 3, 11); b+=S;
addNote(b, 3, 12); b+=S;
addNote(b, 2, 12, 'pluck', null, 'vib'); b+=Q*1.5;

addNote(b, 3, 9); b+=S;
addNote(b, 3, 11); b+=S;
addNote(b, 4, 12); b+=S; // A-12
addNote(b, 2, 11); b+=E;
addNote(b, 2, 11, 'pluck', null, 'vib'); b+=Q;

// Phrase 2
// A-/10-12 D-9 G-9~ D-8-12~
// A-/10-12
addNote(b, 4, 10, 'slide', 12); b+=E;
// D-9
addNote(b, 3, 9); b+=E;
// G-9~
addNote(b, 2, 9, 'pluck', null, 'vib'); b+=Q;

// A-/9-11
addNote(b, 4, 9, 'slide', 11); b+=E;
// D-8
addNote(b, 3, 8); b+=E;
// D-12~
addNote(b, 3, 12, 'pluck', null, 'vib'); b+=Q;

// Fast run: 11h12p11 9 8 9
addNote(b, 3, 11); b+=S;
addNote(b, 3, 12); b+=S; // h
addNote(b, 3, 11); b+=S; // p
addNote(b, 3, 9); b+=S;
addNote(b, 3, 8); b+=S;
addNote(b, 3, 9); b+=Q;

b += 0.5;

// Phrase 3
// D-/9-11-9-11 G-12~
addNote(b, 3, 9, 'slide', 11); b+=S; // Slide up/down feel
addNote(b, 3, 9); b+=S;
addNote(b, 3, 11); b+=S;
addNote(b, 2, 12, 'pluck', null, 'vib'); b+=Q;

// G-11h12p11 9
addNote(b, 2, 11); b+=S;
addNote(b, 2, 12); b+=S;
addNote(b, 2, 11); b+=S;
addNote(b, 2, 9); b+=Q;

// B-10 10 A-12
addNote(b, 1, 10); b+=E;
addNote(b, 1, 10); b+=E;
addNote(b, 4, 12); b+=E;

// G-12h14p11 11 9 D-12
addNote(b, 2, 12); b+=S;
addNote(b, 2, 14); b+=S; // h
addNote(b, 2, 11); b+=S; // p? Tab says 12h14p-11? That's a big jump. 
// Tab: 12h14p (space) 11 11
// Maybe 12h14p12 11? Let's follow 12 14 11.
addNote(b, 2, 11); b+=E;
addNote(b, 2, 11); b+=E;
addNote(b, 2, 9); b+=E;
addNote(b, 3, 12); b+=Q;

b += 0.5;

// Phrase 4
// A-10h12 D-9 G-9 7h9p7 6
addNote(b, 4, 10); b+=S;
addNote(b, 4, 12); b+=S;
addNote(b, 3, 9); b+=E;
addNote(b, 2, 9); b+=E;
addNote(b, 2, 7); b+=S;
addNote(b, 2, 9); b+=S;
addNote(b, 2, 7); b+=S;
addNote(b, 2, 6); b+=Q;

// Phrase 5
// A-9 G-9h10p9 9
addNote(b, 4, 9); b+=E;
addNote(b, 2, 9); b+=S;
addNote(b, 2, 10); b+=S;
addNote(b, 2, 9); b+=S;
addNote(b, 2, 9); b+=E;

// D-12 12 9 A-12 9 E-12 10 7~
addNote(b, 3, 12); b+=S;
addNote(b, 3, 12); b+=S;
addNote(b, 3, 9); b+=S;
addNote(b, 4, 12); b+=S;
addNote(b, 4, 9); b+=S;
addNote(b, 5, 12); b+=S;
addNote(b, 5, 10); b+=S;
addNote(b, 5, 7, 'pluck', null, 'vib'); b+=Q*2;


const LOOP_LENGTH = b + 4;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 1.2, note.target, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#5c4033';
    ctx.font = "16px 'Courier New'";
    ctx.fillStyle = '#daa520';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#d2691e';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 120; 
    
    ctx.font = "20px 'Abril Fatface'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#f4e1d2'; 
            let txt = note.fret;
            if(note.bend) txt += '~';
            if(note.target) txt += '/';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#2b1b17';
            ctx.fill();
            ctx.strokeStyle = '#f4e1d2'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#f4e1d2'; 
            ctx.fillText(txt, x - 6, y + 4);
        }
    });

    // Ripples
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 50);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(210, 105, 30, ${n.life})`;
        ctx.lineWidth = 3;
        ctx.stroke();

        n.life -= 0.03;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    // Tone control placeholder
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 2
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EARTH ANGEL // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Pacifico&family=Courier+New:wght@700&display=swap');

    :root {
        --bg: #008080; /* Teal */
        --ink: #ff69b4; /* Pink */
        --accent: #ffffff; /* White */
        --gold: #ffd700;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Pacifico', cursive;
        color: var(--accent);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 128, 128, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 5rem;
        margin: 0;
        color: var(--ink);
        text-shadow: 3px 3px 0px #fff;
        transform: rotate(-3deg);
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--gold);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--accent);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>Earth Angel</h1>
    <p>[ CLICK TO GO BACK TO 1955 ]</p>
    <p style="font-size: 0.8rem; color: #eee; margin-top: 2rem;">MOUSE Y = REVERB // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: 50s HOLLOW BODY<br>
    BPM: 74 (6/8 Feel)
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * EARTH ANGEL ENGINE
 * 50s Ballad Physics + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 74, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.5;

        // School Gym Reverb
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(2.5, 3.0);
        
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.4;

        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // 50s Tone: Warm, clean, slightly hollow
    playString: (stringIdx, fret, time, duration = 2.5, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        osc1.type = 'sine'; 
        osc2.type = 'triangle'; // Add harmonics
        
        // Pitch Logic
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter (Warm)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1500; 
        filter.Q.value = 0.5;

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.6, t + 0.02); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.5;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.5;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setReverb: (val) => {
        if(AudioEngine.reverbGain) AudioEngine.reverbGain.gain.setTargetAtTime(val, AudioEngine.ctx.currentTime, 0.1);
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}
function addChord(beat, notes, type='pluck') {
    notes.forEach(n => addNote(beat, n[0], n[1], type));
}

// -- BUILD THE SONG --
let b = 0.0;
const E = 0.5; 
const S = 0.25;
// 6/8 Time: 6 beats per measure? No, typically counted 1-2-3 4-5-6. 
// The BPM 74 suggests dotted quarter notes? Let's assume standard notation where beats are 8th notes in triplets.
// Or simple 4/4 with triplets.
// The tab looks arpeggiated.
// e-3--3-----------0
// b-3----3----------0
// g-0------0---0-----0
// d-0----------2
// a-2----------2
// e-3----------0
// G Major -> Em
// Each arpeggio seems to be 4-6 notes.
// G: E-3 A-2 D-0 G-0 B-3 e-3
// Em: E-0 A-2 D-2 G-0 B-0 e-0
// C: A-3 D-2 G-0 B-1 e-0
// D: D-0 G-2 B-3 e-2

function addArpeggio(startBeat, chordNotes) {
    // chordNotes is just the tab sequence in time
    // This function is custom for this specific tab style
}

// INTRO (x2)
for(let k=0; k<2; k++) {
    // G Major Part
    // e-3--3
    // b-3----3
    // g-0------0---0
    // d-0----------
    // a-2----------
    // e-3----------
    // Bass G (E-3, A-2, D-0) strum/arpeggio
    addNote(b, 5, 3); // E-3
    addNote(b, 4, 2); // A-2
    addNote(b, 3, 0); // D-0
    addNote(b, 2, 0); // G-0
    addNote(b, 1, 3); // B-3
    addNote(b, 0, 3); b+=E; // e-3
    
    addNote(b, 0, 3); b+=E; // e-3
    addNote(b, 1, 3); b+=E; // b-3
    addNote(b, 2, 0); b+=E; // g-0
    addNote(b, 2, 0); b+=E; // g-0
    
    // Em Part
    // e-----------0
    // b----------0
    // g-----0-----0
    // d-2
    // a-2
    // e-0
    addNote(b, 5, 0); // E-0
    addNote(b, 4, 2); // A-2
    addNote(b, 3, 2); b+=E; // D-2
    
    addNote(b, 2, 0); b+=E; // g-0
    addNote(b, 1, 0); b+=E; // b-0
    addNote(b, 0, 0); b+=E; // e-0
    addNote(b, 2, 0); b+=E; // g-0
    
    // C Major Part
    // e--------0
    // b-------1
    // g------0
    // d-----2
    // a-3
    addNote(b, 4, 3); // A-3
    addNote(b, 3, 2); b+=E; // D-2
    
    addNote(b, 2, 0); b+=E; // g-0
    addNote(b, 1, 1); b+=E; // b-1
    addNote(b, 0, 0); b+=E; // e-0
    
    // D Major Part
    // e-----0---2----2
    // b-----1---3------3
    // g-----0---2--------2
    // d---------0----------0
    addNote(b, 0, 0); b+=E; // e-0
    addNote(b, 1, 1); b+=E; // b-1
    
    addNote(b, 3, 0); // D-0 (Bass)
    addNote(b, 2, 2); // G-2
    addNote(b, 1, 3); // B-3
    addNote(b, 0, 2); b+=E; // e-2
    
    addNote(b, 0, 2); b+=E; // e-2
    addNote(b, 1, 3); b+=E; // b-3
    addNote(b, 2, 2); b+=E; // g-2
    addNote(b, 3, 0); b+=E; // d-0
}

// VERSE
// e-3-----3------------0---0-0--2-2
// b-3-----3------------1---1-1--3-3
// g-0-----0--0----0----0---0-0--2-2
// d-0-----0--2----2----2---2-2--0-0
// a-2-----2--2----2----3---3-3
// e-3-----3--0----0
// Strumming chords G -> Em -> C -> D
function addVerseLine() {
    // G (Strum)
    addChord(b, [[5,3], [4,2], [3,0], [2,0], [1,3], [0,3]]); b+=1.0;
    addChord(b, [[5,3], [4,2], [3,0], [2,0], [1,3], [0,3]]); b+=1.0;
    
    // Em (Strum)
    addChord(b, [[5,0], [4,2], [3,2], [2,0]]); b+=1.0; // Tab says d-2 a-2 e-0 g-0
    addChord(b, [[5,0], [4,2], [3,2], [2,0]]); b+=1.0;
    
    // C (Strum)
    addChord(b, [[4,3], [3,2], [2,0], [1,1], [0,0]]); b+=0.5;
    addChord(b, [[4,3], [3,2], [2,0], [1,1], [0,0]]); b+=0.5;
    addChord(b, [[4,3], [3,2], [2,0], [1,1], [0,0]]); b+=1.0;
    
    // D (Strum)
    addChord(b, [[3,0], [2,2], [1,3], [0,2]]); b+=0.5;
    addChord(b, [[3,0], [2,2], [1,3], [0,2]]); b+=0.5;
    
    b+=1.0; // Rest
}

addVerseLine();
addVerseLine();

// CHORUS
// Same as verse with minor alterations (fiddling)
// Let's do arpeggios again for variety
for(let i=0; i<2; i++) {
    // G
    addNote(b, 5, 3); addNote(b, 0, 3); b+=E;
    addNote(b, 1, 3); b+=E;
    addNote(b, 2, 0); b+=E;
    
    // Em
    addNote(b, 5, 0); addNote(b, 0, 0); b+=E;
    addNote(b, 1, 0); b+=E;
    addNote(b, 2, 0); b+=E;
    
    // C
    addNote(b, 4, 3); addNote(b, 0, 0); b+=E;
    addNote(b, 1, 1); b+=E;
    
    // D
    addNote(b, 3, 0); addNote(b, 0, 2); b+=E;
    addNote(b, 1, 3); b+=E;
    addNote(b, 0, 2); b+=E;
}

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 2.0, note.target);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#ff69b4';
    ctx.font = "16px 'Courier New'";
    ctx.fillStyle = '#fff';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 100; 
    
    ctx.font = "20px 'Pacifico'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ff69b4'; 
            let txt = note.fret;
            if(note.target) txt += '/';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#008080';
            ctx.fill();
            ctx.strokeStyle = '#fff'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#fff'; 
            ctx.fillText(txt, x - 6, y + 4);
        }
    });

    // Heart Ripples
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 40);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 105, 180, ${n.life})`;
        ctx.lineWidth = 2;
        ctx.stroke();

        n.life -= 0.02;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setReverb(y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 3
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ELECTRIC LEAD // DISTORTION ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Share+Tech+Mono&display=swap');

    :root {
        --bg: #050510;
        --neon: #00f3ff;
        --hot: #ff0055;
        --dim: #1a1a2e;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Share Tech Mono', monospace;
        color: var(--neon);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
        filter: drop-shadow(0 0 10px var(--neon));
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(5, 5, 16, 0.9);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-family: 'Orbitron', sans-serif;
        font-size: 4rem;
        margin: 0;
        color: #fff;
        text-shadow: 0 0 20px var(--neon), 0 0 40px var(--neon);
        letter-spacing: 5px;
        font-style: italic;
    }

    p {
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.2rem;
        color: var(--hot);
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: #fff;
        text-shadow: 0 0 5px #fff;
    }

    /* Tube glow animation */
    @keyframes pulse {
        0% { opacity: 0.8; }
        50% { opacity: 1; text-shadow: 0 0 30px var(--neon); }
        100% { opacity: 0.8; }
    }
    .tube-glow { animation: pulse 2s infinite; }
</style>
</head>
<body>

<div id="overlay">
    <h1 class="tube-glow">HIGH GAIN</h1>
    <p>[ CLICK TO SHRED ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = DISTORTION AMOUNT // SPACE = PAUSE</p>
</div>

<div id="hud">
    AMP: OVERDRIVE<br>
    BPM: 75 (Ballad Tempo)
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * ELECTRIC GUITAR ENGINE
 * Distortion Physics + Solo Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 75, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    drive: null,
    driveGain: null,
    reverb: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.4;

        // DISTORTION CHAIN
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(400); // High gain
        AudioEngine.drive.oversample = '4x';
        
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 0.5; // Input gain into distortion

        // Delay/Reverb for "Stadium" sound
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(2.5, 2.0);
        
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.3;

        // Routing: Source -> Drive -> Master -> Dest
        //                       \-> Reverb -> Dest
        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(verbMix);
        verbMix.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // ELECTRIC TONE: Sawtooth (Bridge Pickup) + Square (Neck Pickup)
    playString: (stringIdx, fret, time, duration = 2.0, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        osc1.type = 'sawtooth'; 
        osc2.type = 'square';
        
        // PITCH LOGIC
        let targetFreq = freq;
        let bendTime = 0.2;

        if (slideTo !== null) {
            // Standard slide
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
        } else if (bendType === 'full') {
            // 10(12) - Whole Step Bend
            targetFreq = freq * Math.pow(2, 2/12); 
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.2); 
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.2); 
        } else if (bendType === 'release') {
            // (12)(10) - Pre-bend release
            const startFreq = freq * Math.pow(2, 2/12); // Start at bend
            osc1.frequency.setValueAtTime(startFreq, t);
            osc1.frequency.linearRampToValueAtTime(freq, t + 0.15);
            osc2.frequency.setValueAtTime(startFreq, t);
            osc2.frequency.linearRampToValueAtTime(freq, t + 0.15);
        } else if (bendType === 'half') {
            // 12(13)
             targetFreq = freq * Math.pow(2, 1/12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
            
            // Subtle Vibrato for sustain
            const vib = AudioEngine.ctx.createOscillator();
            vib.frequency.value = 5;
            const vibGain = AudioEngine.ctx.createGain();
            vibGain.gain.value = freq * 0.005;
            vib.connect(vibGain);
            vibGain.connect(osc1.frequency);
            vibGain.connect(osc2.frequency);
            vib.start(t);
            vib.stop(t+duration);
        }

        // TONE FILTER (Cab Simulation)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 3500; // Roll off harsh highs
        filter.Q.value = 0.7;

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.5, t + 0.01); // Instant attack
        amp.gain.exponentialRampToValueAtTime(0.3, t + 0.2); // Sustain level
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); // Fade out

        // Mix: 60% Saw, 40% Square
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.6;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.4;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        
        // Connect to Drive
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setDistortion: (val) => {
        // Map 0-1 to Curve amount 0-1000
        if(AudioEngine.drive) {
            AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(val * 1000);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null, bend = null) {
    TAB.push({ beat, string, fret, type, target, bend });
}

// -- BUILD THE SOLO --
let b = 0.5; // Lead-in
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// === PHRASE 1 ===
// B-13. 13 13 | 12. 12 12 | 10. (12)(10) | G-9
addNote(b, 1, 13); b += Q*1.5; // 13.
addNote(b, 1, 13); b += S; 
addNote(b, 1, 13); b += S;

addNote(b, 1, 12); b += Q*1.5; // 12.
addNote(b, 1, 12); b += S; 
addNote(b, 1, 12); b += S;

addNote(b, 1, 10); b += Q; // 10.
addNote(b, 1, 10, 'pluck', null, 'full'); b += E; // (12) Bend up
addNote(b, 1, 10, 'pluck', null, 'release'); b += E; // (10) Release
addNote(b, 2, 9); b += Q*2; // G-9 Sustain

b += Q; // Rest

// === PHRASE 2 ===
// B-10. (12)(10) 8 10. (12)(10) | G-10
addNote(b, 1, 10); b += Q; 
addNote(b, 1, 10, 'pluck', null, 'full'); b += S; // Bend
addNote(b, 1, 10, 'pluck', null, 'release'); b += S; // Release

addNote(b, 1, 8); b += E;
addNote(b, 2, 9); b += E; // G-9 harmony/passing? Tab says 9 on G? Actually tab says 9 on G then back to B line.
// Tab: G-9 (between phrases?) Wait, looking at tab:
// B-10 (12)(10) 8 | 10 (12)(10) | G-10
// There is a G-9 under the first bend group? Let's follow the melodic line.
// B string mostly.
addNote(b, 1, 10); b += Q; 
addNote(b, 1, 10, 'pluck', null, 'full'); b += S; 
addNote(b, 1, 10, 'pluck', null, 'release'); b += S;
addNote(b, 2, 10); b += Q*2; // G-10

b += Q;

// === PHRASE 3 ===
// D-12 G-9 10. 12 | B-10 | G-12. | D-12 G-9 10. 12
addNote(b, 3, 12); b += E;
addNote(b, 2, 9); b += E;
addNote(b, 2, 10); b += Q;
addNote(b, 2, 12); b += E;
addNote(b, 1, 10); b += Q; // B-10
addNote(b, 2, 12); b += Q*1.5; // G-12.

addNote(b, 3, 12); b += E;
addNote(b, 2, 9); b += E;
addNote(b, 2, 10); b += Q;
addNote(b, 2, 12); b += Q*1.5;

// === PHRASE 4 ===
// B-10 8 10(12) (12)(10) 8 10 8 8\ | G-8. 8\
// High E-10 involved? "e---10---"
addNote(b, 1, 10); b += E;
addNote(b, 1, 8); b += E;
addNote(b, 1, 10, 'pluck', null, 'full'); b += E; // Bend 12
addNote(b, 0, 10); b += E; // High E 10 (Blues lick)
addNote(b, 1, 10, 'pluck', null, 'release'); b += E; // Release to 10
addNote(b, 1, 8); b += E;
addNote(b, 1, 10); b += E;
addNote(b, 1, 8); b += E;
addNote(b, 1, 8, 'slide', 1); b += Q; // Slide down
addNote(b, 2, 8); b += Q; // G-8
addNote(b, 2, 8, 'slide', 1); b += Q;

b += Q;

// === PHRASE 5 ===
// B-12(13) (13) (13) | 12. 12 12 | 10. (12)(10) | G-9
addNote(b, 1, 12, 'pluck', null, 'half'); b += Q; // Bend 13
addNote(b, 1, 12, 'pluck', null, 'half'); b += Q; // Re-pick bent? or hold? Tab implies hold/re-pick
addNote(b, 1, 12, 'pluck', null, 'half'); b += Q;

addNote(b, 1, 12); b += Q*1.5;
addNote(b, 1, 12); b += S;
addNote(b, 1, 12); b += S;

addNote(b, 1, 10); b += Q;
addNote(b, 1, 10, 'pluck', null, 'full'); b += E;
addNote(b, 1, 10, 'pluck', null, 'release'); b += E;
addNote(b, 2, 9); b += Q*2;

b += Q;

// === PHRASE 6 ===
// G-9 B-8 10. (12)(10) 8 (12)(10) | G-10
addNote(b, 2, 9); b += E;
addNote(b, 1, 8); b += E;
addNote(b, 1, 10); b += Q;
addNote(b, 1, 10, 'pluck', null, 'full'); b += S;
addNote(b, 1, 10, 'pluck', null, 'release'); b += S;
addNote(b, 2, 9); b += E; // Tab has G-9 here?
addNote(b, 1, 8); b += E;
addNote(b, 1, 10, 'pluck', null, 'full'); b += S; // Another bend?
addNote(b, 1, 10, 'pluck', null, 'release'); b += S;
addNote(b, 2, 10); b += Q*2;

b += Q;

// === PHRASE 7 ===
// D-12 G-9 10 12 | B-10 | D-12 G-9 10 12 | B-10 12 13 12
addNote(b, 3, 12); b += S;
addNote(b, 2, 9); b += S;
addNote(b, 2, 10); b += S;
addNote(b, 2, 12); b += S;
addNote(b, 1, 10); b += Q;

addNote(b, 3, 12); b += S;
addNote(b, 2, 9); b += S;
addNote(b, 2, 10); b += S;
addNote(b, 2, 12); b += S;

addNote(b, 1, 10); b += E;
addNote(b, 1, 12); b += E;
addNote(b, 1, 13); b += E;
addNote(b, 1, 12); b += E;

// === PHRASE 8 (OUTRO) ===
// G-14. 12. | B-(15)(13) 13
addNote(b, 2, 14); b += Q*1.5;
addNote(b, 2, 12); b += Q*1.5;
addNote(b, 1, 13, 'pluck', null, 'full'); b += E; // Pre-bend 15? or 13->15
addNote(b, 1, 13, 'pluck', null, 'release'); b += E; // Release
addNote(b, 1, 13); b += Q*4; // Final sustain


// Loop Logic
const LOOP_LENGTH = b + 4;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            // Play logic
            AudioEngine.playString(note.string, note.fret, playTime, 2.5, note.target, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Draw Staff Strings
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333';
    ctx.font = "16px 'Share Tech Mono'";
    ctx.fillStyle = '#00f3ff';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        
        // Glowing String
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#00f3ff';
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.shadowBlur = 0;

        ctx.fillText(name, 10, y + 5);
    });

    // Draw Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#ff0055';
    ctx.lineWidth = 3;
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#ff0055';
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Draw Notes
    const pixelsPerBeat = 120; // Slower scroll for ballad
    
    ctx.font = "20px 'Orbitron'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            // Note Body
            ctx.fillStyle = '#00f3ff'; 
            let txt = note.fret;
            if (note.bend === 'full') txt += 'b';
            if (note.bend === 'half') txt += '';
            if (note.bend === 'release') txt = '(' + txt + ')';
            if (note.type === 'slide') txt += '\\';

            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#050510';
            ctx.fill();
            ctx.strokeStyle = '#00f3ff'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#fff'; 
            ctx.fillText(txt, x - 10, y + 2);
        }
    });

    // Active Flashes (Sparks)
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        // Electric Burst
        const radius = 20 + ((1 - n.life) * 50);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(0, 243, 255, ${n.life})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Cross spark
        ctx.beginPath();
        ctx.moveTo(HIT_X - radius, y - 5);
        ctx.lineTo(HIT_X + radius, y - 5);
        ctx.moveTo(HIT_X, y - 5 - radius);
        ctx.lineTo(HIT_X, y - 5 + radius);
        ctx.strokeStyle = `rgba(255, 0, 85, ${n.life})`;
        ctx.stroke();

        n.life -= 0.05;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    // Map Y to Distortion (0.0 to 1.0)
    AudioEngine.setDistortion(1 - y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 4
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FLAMENCO // GUITAR ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Rye&family=Courier+New:wght@700&display=swap');

    :root {
        --paper: #1a0505;
        --ink: #f1c40f;
        --accent: #e74c3c;
        --string: #7f8c8d;
    }

    body {
        margin: 0;
        background: var(--paper);
        overflow: hidden;
        font-family: 'Rye', serif;
        color: var(--ink);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(26, 5, 5, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 5rem;
        margin: 0;
        color: var(--accent);
        text-shadow: 4px 4px 0px #000;
        letter-spacing: 5px;
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--ink);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--accent);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>Malaguea</h1>
    <p>[ CLICK TO START ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = HALL REVERB // SPACE = PAUSE</p>
</div>

<div id="hud">
    STYLE: FLAMENCO (NYLON)<br>
    BPM: 130
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * FLAMENCO GUITAR ENGINE
 * Nylon String Physics + Malaguea Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 130, // Faster Tempo for Flamenco
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.6;

        // Large Hall Reverb for that Spanish Cathedral sound
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(3.5, 2.5);
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.4;

        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // NYLON TONE: Warmer, less metallic than steel
    playString: (stringIdx, fret, time, duration = 1.5, slideTo = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Nylon Mix: Dominant Sine (Fundamental) + Subtle Triangle (Harmonics)
        osc1.type = 'sine'; 
        osc2.type = 'triangle';
        
        // Handling Slides / Hammer-ons
        if (slideTo !== null) {
            const targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.1); 
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter Envelope: Quick decay of high frequencies (The "Pluck")
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 0; // Low resonance for wood sound
        filter.frequency.setValueAtTime(freq * 3, t); // Start slightly bright
        filter.frequency.exponentialRampToValueAtTime(freq, t + 0.1); // Quickly darken

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.5, t + 0.01); // Fast attack (Nail)
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix: 70% Sine, 30% Triangle
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.7;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.3;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    // "Golpe" - Percussive hit on guitar body
    playDeadNote: (time) => {
        const t = time;
        const bufSize = AudioEngine.ctx.sampleRate * 0.05; 
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;

        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 150; // Deep wood thud

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0.6, t);
        amp.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

        noise.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);
        noise.start(t);
    },

    setReverb: (val) => {
        if(AudioEngine.reverbGain) AudioEngine.reverbGain.gain.setTargetAtTime(val, AudioEngine.ctx.currentTime, 0.1);
    }
};

// --- TAB DATA PARSER ---
const TAB = [];

function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}
function addChord(beat, notes) {
    notes.forEach(n => addNote(beat, n[0], n[1]));
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; // Quarter Note
const S = 0.25; // 16th Note
const E = 0.5; // 8th Note

// === PART 1: Em THEME ===
// Bass E + Melody 0
for(let i=0; i<2; i++) {
    addNote(b, 5, 0); // Bass
    addNote(b, 0, 0); // High E
    b += Q;
    
    // Run 1: 0 2 3 2
    addNote(b, 0, 0); b += S;
    addNote(b, 0, 2); b += S;
    addNote(b, 0, 3); b += S;
    addNote(b, 0, 2); b += S;
    
    // Run 2: 5 3 2 3
    addNote(b, 0, 5); b += S;
    addNote(b, 0, 3); b += S;
    addNote(b, 0, 2); b += S;
    addNote(b, 0, 3); b += S;
    
    // Land
    addNote(b, 0, 0); 
    if(i===1) addNote(b, 0, 0); // Double strum effect
    b += Q;
}

// === PART 2: D THEME ===
// Bass D + Melody 2
for(let i=0; i<2; i++) {
    addNote(b, 3, 0); // Bass D
    addNote(b, 0, 2); // High E 2
    b += Q;
    
    // Run 1: 0 2 0 -
    addNote(b, 0, 0); b += S;
    addNote(b, 0, 2); b += S;
    addNote(b, 0, 0); b += S;
    // triplet gap feel
    addNote(b, 0, 3); b += S; // Next beat start
    
    // Run 2: 2 0 - 3 (B string)
    addNote(b, 0, 2); b += S;
    addNote(b, 0, 0); b += S;
    addNote(b, 1, 3); b += E; // B string 3
    
    // Land
    addNote(b, 0, 2); // High E 2
    addNote(b, 1, 3); // Harmony
    b += Q;
}

// === PART 3: C THEME ===
// Bass C + Melody 0
for(let i=0; i<2; i++) {
    addNote(b, 4, 3); // Bass C
    addNote(b, 0, 0); // High E 0
    b += Q;

    if(i===0) {
        // Run: 0 2 5 3 2 0
        addNote(b, 0, 0); b += S;
        addNote(b, 0, 2); b += S;
        addNote(b, 0, 5); b += S;
        addNote(b, 0, 3); b += S;
        
        addNote(b, 0, 2); b += S;
        addNote(b, 0, 0); b += S;
        addNote(b, 0, 0); b += E; // Land
    } else {
        // Variation: 0 2 0 (B)4 4 1
        addNote(b, 0, 0); b += S;
        addNote(b, 0, 2); b += S;
        addNote(b, 0, 0); b += S;
        
        addNote(b, 1, 4); b += S; // D# (Phrygian)
        addNote(b, 1, 4); b += S;
        addNote(b, 1, 1); b += E;
    }
}

// === PART 4: B7 Run ===
addChord(b, [[4,2], [3,1], [2,2], [1,0]]); // B7 Chord
b += Q;

// Run down
addNote(b, 3, 1); b += S;
addNote(b, 3, 4); b += S;
addNote(b, 2, 2); b += S;
addNote(b, 2, 0); b += S;

addNote(b, 3, 4); b += S;
addNote(b, 3, 2); b += S;
addNote(b, 3, 1); b += S;
addNote(b, 4, 3, 'slide', 2); b += S; // Hammer/Pull Sim

addNote(b, 5, 3); b += S;
addNote(b, 5, 2); b += S;
addNote(b, 5, 0); b += E;

// === PART 5: Am RUN ===
// Fast arpeggios
addNote(b, 5, 0); // Low E
addChord(b, [[1,1], [2,2], [3,2]]); // Am
b += Q;

addNote(b, 1, 0); b += S;
addNote(b, 0, 0); b += S;
addNote(b, 1, 3); b += S;
addNote(b, 1, 1); b += S;

addNote(b, 1, 0); b += S;
addNote(b, 1, 0, 'slide', 1); b += S; // h/p
addNote(b, 1, 0); b += S;
addNote(b, 2, 2); b += S;

// Final strum Em
addChord(b, [[5,0], [4,2], [3,2], [2,0], [1,0], [0,0]]); // Em
b += 2.0;


// Loop Logic
const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            if (note.type === 'x') {
                AudioEngine.playDeadNote(playTime);
            } else if (note.type === 'slide') {
                AudioEngine.playString(note.string, note.fret, playTime, 0.8, note.target);
            } else {
                AudioEngine.playString(note.string, note.fret, playTime, 1.0);
            }
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Draw Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#7f8c8d';
    ctx.font = "20px 'Courier New'";
    ctx.fillStyle = '#f1c40f';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Draw Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#e74c3c';
    ctx.lineWidth = 4;
    ctx.stroke();

    // Draw Notes
    const pixelsPerBeat = 180; 
    
    ctx.font = "24px 'Rye'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#e74c3c'; // Spanish Red
            let txt = note.type === 'x' ? 'x' : note.fret;
            if (note.type === 'slide') txt += '~';

            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#1a0505';
            ctx.fill();
            ctx.strokeStyle = '#f1c40f'; // Gold Border
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#f1c40f'; // Gold Text
            ctx.fillText(txt, x - 8, y + 4);
        }
    });

    // Active Flashes
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 40);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(241, 196, 15, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.08;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    ctx.font = "14px 'Courier New'";
    ctx.fillStyle = '#e74c3c';
    ctx.fillText("GOLPE", HIT_X - 25, STAFF_Y - 110);

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setReverb(y * 0.8);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 5
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MALAGUEA // VIRTUOSO</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Rye&family=Courier+New:wght@700&display=swap');

    :root {
        --bg: #1a0505;
        --gold: #ffcc00;
        --red: #ff0000;
        --rose: #e6005c;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Rye', cursive;
        color: var(--gold);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(26, 5, 5, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 5rem;
        margin: 0;
        color: var(--red);
        text-shadow: 2px 2px 0px var(--gold);
        letter-spacing: 5px;
        text-align: center;
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.2rem;
        color: var(--gold);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--gold);
        border-left: 3px solid var(--red);
        padding-left: 10px;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>MALAGUEA</h1>
    <p>[ CLICK TO BAILE ]</p>
    <p style="font-size: 0.8rem; color: #aaa; margin-top: 2rem;">MOUSE Y = HALL REVERB // SPACE = PAUSE</p>
</div>

<div id="hud">
    STYLE: FLAMENCO PURO<br>
    BPM: 160
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * FLAMENCO VIRTUOSO ENGINE
 * Nylon Physics + Malaguea Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 160, // High speed
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.6;

        // Spanish Hall Reverb
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(2.5, 2.0);
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.3;

        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playString: (stringIdx, fret, time, duration = 1.0, slideTo = null) => {
        if (!AudioEngine.ctx) return;
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Nylon Tone: Sine + Triangle
        osc1.type = 'sine'; 
        osc2.type = 'triangle'; 
        
        let targetFreq = freq;
        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter: Sharp Attack, Warm Decay
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(3000, t);
        filter.frequency.exponentialRampToValueAtTime(800, t + 0.15); 
        filter.Q.value = 0.5;

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.7, t + 0.01); // Fast Pluck
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.6;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.4;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },
    
    // Rasgueado Strum (Fast Strum)
    playStrum: (notes, time) => {
        notes.forEach((n, i) => {
            // Slight delay between strings for strum effect
            AudioEngine.playString(n[0], n[1], time + (i * 0.015), 1.5);
        });
    },

    setReverb: (val) => {
        if(AudioEngine.reverbGain) AudioEngine.reverbGain.gain.setTargetAtTime(val, AudioEngine.ctx.currentTime, 0.1);
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}
function addChord(beat, notes) {
    // notes: [[string, fret], ...]
    // For rasgueado, we trigger a special type handled by scheduler? 
    // Or just add separate notes with micro-timing. 
    // Let's add them as a chord block and let scheduler handle strum timing if needed, 
    // or just add them here.
    notes.forEach((n, i) => {
        // Simulate strum here
        addNote(beat + (i*0.01), n[0], n[1], 'strum');
    });
}

// -- BUILD MALAGUEA --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// Part 1: The Theme (Em - D - C - B7)
// Bass Melody + High Open E Pedal
// Em
addNote(b, 5, 0); addNote(b, 0, 0); b+=Q;
addNote(b, 0, 0); b+=S; addNote(b, 0, 2); b+=S; addNote(b, 0, 3); b+=S; addNote(b, 0, 2); b+=S;
addNote(b, 0, 5); b+=S; addNote(b, 0, 3); b+=S; addNote(b, 0, 2); b+=S; addNote(b, 0, 3); b+=S;
addNote(b, 0, 0); b+=Q;

// D
addNote(b, 3, 0); addNote(b, 0, 2); b+=Q;
addNote(b, 0, 0); b+=S; addNote(b, 0, 2); b+=S; addNote(b, 0, 0); b+=S; addNote(b, 1, 3); b+=S;
addNote(b, 0, 2); b+=S; addNote(b, 0, 0); b+=S; addNote(b, 1, 3); b+=S; addNote(b, 2, 2); b+=S;
addNote(b, 0, 2); addNote(b, 1, 3); b+=Q;

// C
addNote(b, 4, 3); addNote(b, 0, 0); b+=Q;
addNote(b, 0, 0); b+=S; addNote(b, 0, 2); b+=S; addNote(b, 0, 5); b+=S; addNote(b, 0, 3); b+=S;
addNote(b, 0, 2); b+=S; addNote(b, 0, 0); b+=S; addNote(b, 1, 4); b+=S; addNote(b, 1, 1); b+=S;
addNote(b, 0, 0); b+=Q;

// B7 (Rasgueado)
addChord(b, [[4,2], [3,1], [2,2], [1,0], [0,2]]); b+=Q;
addNote(b, 1, 0); b+=S; addNote(b, 1, 4); b+=S; addNote(b, 1, 0); b+=S; addNote(b, 2, 2); b+=S;
addNote(b, 3, 4); b+=S; addNote(b, 3, 1); b+=S; addNote(b, 4, 2); b+=S; addNote(b, 5, 2); b+=S;
addChord(b, [[5,2], [4,2], [3,1], [2,2], [1,0], [0,2]]); b+=Q;

// Part 2: Tremolo / Arpeggio Section (Am)
// Bass A - High E tremolo (simulated with fast notes)
b += 1.0; // Pause
addNote(b, 4, 0); addNote(b, 2, 2); addNote(b, 1, 1); b+=E;
addNote(b, 0, 0); b+=S; addNote(b, 0, 0); b+=S; addNote(b, 0, 0); b+=S; addNote(b, 0, 0); b+=S;
addNote(b, 0, 1); b+=S; addNote(b, 0, 1); b+=S; addNote(b, 0, 3); b+=S; addNote(b, 0, 3); b+=S;
addNote(b, 0, 5); b+=S; addNote(b, 0, 5); b+=S; addNote(b, 0, 3); b+=S; addNote(b, 0, 1); b+=S;
addNote(b, 0, 0); b+=Q;

// Part 3: Scales (Phrygian Dominant)
b += 1.0;
// E string run: 0 1 3 4 5 7 8 10 12 13 12 10 8 7 5 4 1 0
const run = [0,1,3,4,5,7,8,10,12,13,12,10,8,7,5,4,1,0];
run.forEach(f => {
    addNote(b, 0, f); b+=S;
});
addChord(b, [[5,0], [4,2], [3,2], [2,1], [1,0], [0,0]]); b+=2.0; // E Major Finale

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 1.5, note.target);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#b30000';
    ctx.font = "16px 'Courier New'";
    ctx.fillStyle = '#ffcc00';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 4;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 200; 
    
    ctx.font = "24px 'Rye'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ffcc00'; 
            let txt = note.fret;
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#330000';
            ctx.fill();
            ctx.strokeStyle = '#ffcc00'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#ffcc00'; 
            ctx.fillText(txt, x - 8, y + 4);
        }
    });

    // Roses/Sparks
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 50);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 0, 0, ${n.life})`;
        ctx.lineWidth = 3;
        ctx.stroke();

        n.life -= 0.05;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setReverb(y * 0.8);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 6
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MARSHMELLO // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Courier+New:wght@700&display=swap');

    :root {
        --bg: #111;
        --white: #fff;
        --pink: #ff69b4; /* Hot Pink */
        --cyan: #00ffff;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Fredoka One', cursive;
        color: var(--white);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(17, 17, 17, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 5rem;
        margin: 0;
        color: var(--white);
        text-shadow: 4px 4px 0px var(--pink);
        letter-spacing: 2px;
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--cyan);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--white);
    }
    
    .mello-eyes {
        font-size: 3rem;
        position: absolute;
        top: 20px;
        right: 20px;
        color: var(--white);
        transform: rotate(10deg);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>ALONE</h1>
    <p>[ CLICK TO DROP THE BEAT ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = FILTER / DROP // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: SYNTH PLUCK<br>
    BPM: 142
</div>
<div class="mello-eyes">X X</div>

<canvas id="canvas"></canvas>

<script>
/**
 * MARSHMELLO ENGINE
 * Synth Physics + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 142, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    filter: null,
    delay: null,
    delayGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.4;

        // Global Lowpass Filter (The "Mello" sound)
        AudioEngine.filter = AudioEngine.ctx.createBiquadFilter();
        AudioEngine.filter.type = 'lowpass';
        AudioEngine.filter.frequency.value = 20000; // Open
        AudioEngine.filter.Q.value = 1.0;

        // Tempo-synced Delay
        AudioEngine.delay = AudioEngine.ctx.createDelay();
        AudioEngine.delay.delayTime.value = (60 / CONFIG.BPM) * 0.75; // Dotted 8th
        
        AudioEngine.delayGain = AudioEngine.ctx.createGain();
        AudioEngine.delayGain.gain.value = 0.4;
        
        const delayFb = AudioEngine.ctx.createGain();
        delayFb.gain.value = 0.4;

        // Routing
        AudioEngine.master.connect(AudioEngine.filter);
        AudioEngine.filter.connect(AudioEngine.ctx.destination);
        
        // Delay Send
        AudioEngine.filter.connect(AudioEngine.delay);
        AudioEngine.delay.connect(delayFb);
        delayFb.connect(AudioEngine.delay);
        AudioEngine.delay.connect(AudioEngine.delayGain);
        AudioEngine.delayGain.connect(AudioEngine.ctx.destination);
    },

    // Synth Pluck Tone
    playString: (stringIdx, fret, time, duration = 0.5, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // EDM Tone: Sawtooth + Square (Detuned)
        osc1.type = 'sawtooth'; 
        osc2.type = 'square'; 
        osc2.detune.value = 10; // Super-saw width
        
        // Pitch Logic
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Pluck Envelope
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.6, t + 0.005); // Instant attack
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Note Filter (Bright pluck)
        const nFilter = AudioEngine.ctx.createBiquadFilter();
        nFilter.type = 'lowpass';
        nFilter.frequency.setValueAtTime(5000, t);
        nFilter.frequency.exponentialRampToValueAtTime(500, t + 0.2); // Filter pluck
        
        // Dead note logic
        if (bendType === 'x') {
            duration = 0.05;
            nFilter.frequency.value = 1000;
        }

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.5;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.5;

        osc1.connect(osc1Gain); osc1Gain.connect(nFilter);
        osc2.connect(osc2Gain); osc2Gain.connect(nFilter);
        nFilter.connect(amp);
        amp.connect(AudioEngine.master);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setFilter: (val) => {
        if(AudioEngine.filter) {
            // Map 0-1 to 200Hz - 20000Hz
            const freq = 200 + (val * 19800);
            AudioEngine.filter.frequency.setTargetAtTime(freq, AudioEngine.ctx.currentTime, 0.1);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}
function addChord(beat, notes, type='pluck') {
    notes.forEach(n => addNote(beat, n[0], n[1], type, null));
}

// -- BUILD THE SONG --
let b = 0.0;
const E = 0.5; // 8th note
const S = 0.25; // 16th note
// Intro arpeggios are fast. Tab shows 16th notes? Or 8ths at high tempo?
// 142 BPM is fast. The intro looks like 8th notes.
// D---0---0---0 (repeats)
// Let's interpret the intro rhythm.

// === INTRO ===
// G-3 3 3 3/5 5 5 5 5/7 7 7 7 7 ...
// e|-------------------------------------------------|
// B|-------------------------------------------------|
// G|-------------------------------------------------|
// D|---0---0---0---------4---4---4-------------------|
// A|---------------------------------------5---5---5-|
// E|-3---3---3---3/5---5---5---5---5/7---7---7---7---|
// Rhythm: 8th notes
function addIntro() {
    // G chord (3rd fret E, open D)
    for(let i=0; i<3; i++) {
        addNote(b, 5, 3); b+=E; // E-3
        addNote(b, 3, 0); b+=E; // D-0
    }
    // Slide up / transition
    addNote(b, 5, 3, 'slide', 5); b+=E; // E-3/5
    addNote(b, 3, 0); b+=E; // D-0? Tab says D-4 next measure
    
    // A chord (5th fret E, 4th fret D)
    for(let i=0; i<3; i++) {
        addNote(b, 5, 5); b+=E; // E-5
        addNote(b, 3, 4); b+=E; // D-4
    }
    // Transition
    addNote(b, 5, 5, 'slide', 7); b+=E;
    addNote(b, 3, 4); b+=E; 
    
    // B chord (7th fret E, 5th fret A? No tab says A string notes now)
    // A string 5
    // E-7
    for(let i=0; i<3; i++) {
        addNote(b, 5, 7); b+=E; 
        addNote(b, 4, 5); b+=E;
    }
    // Ending lick
    // A-4-5-5-5-4
    // D-4-4-4-2
    addNote(b, 5, 7); b+=E;
    addNote(b, 4, 4); b+=E;
    // A-5 D-4
    addNote(b, 4, 5); b+=E; addNote(b, 3, 4); b+=E;
    addNote(b, 4, 5); b+=E; addNote(b, 3, 4); b+=E;
    addNote(b, 4, 5); b+=E; addNote(b, 3, 4); b+=E;
    addNote(b, 4, 4); b+=E; addNote(b, 3, 2); b+=E;
}

addIntro();

// === CHORUS (THE DROP) ===
// Melody: E-2 5 0-2-0~
// B-3 3
// G-0
// D-
// A-0~
// E-3 3
// Rhythm: Syncopated melody
b += 1.0; // Breath

// Phrase 1
// G chord (E-3)
addNote(b, 0, 2); b+=0.75;
addNote(b, 0, 5); b+=0.25;
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 0); b+=1.0; // ~
addNote(b, 1, 3); b+=0.5;
addNote(b, 1, 3); b+=0.5;
addNote(b, 5, 3); b+=0.5; // Bass G
addNote(b, 2, 0); b+=0.5;
addNote(b, 5, 3); b+=1.0; 

// Phrase 2 (D/F#?)
// e-3 2 3 2 0-2
// A-0~
addNote(b, 0, 3); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 3); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 1, 3); b+=1.0; // ~
addNote(b, 2, 0); b+=0.5;
addNote(b, 2, 0); b+=0.5;
addNote(b, 4, 0); b+=1.0; // Bass A

// Phrase 3 (Bm?)
// e-0-2 b-3 3
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 1, 3); b+=0.5;
addNote(b, 1, 3); b+=0.5;
addNote(b, 2, 0); b+=0.5;
addNote(b, 4, 2); b+=1.5; // Bass B

// Phrase 4
// e-5 0-2-0~
addNote(b, 0, 5); b+=0.5;
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 0); b+=1.0;
addNote(b, 2, 0); b+=0.5;
addNote(b, 4, 2); b+=1.0;

b += 1.0;

// === BREAKDOWN (The Strumming/Wrist Thump Part) ===
// e-3-0-2-0 0-2-0
// b-3-3-3-3 3-3-3-3
// o (Wrist Thump)
// This is percussive. Let's use 'x' note for thumps.

function addThump() {
    addNote(b, 5, 0, 'x'); // Thump
}

// Phrase 1
addThump(); b+=0.5;
addNote(b, 0, 3); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 0); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 2); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 0); addNote(b, 1, 3); b+=0.5;
addThump(); b+=0.5;
addNote(b, 0, 0); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 2); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 0); addNote(b, 1, 3); b+=0.5;

// Phrase 2
addThump(); b+=0.5;
addNote(b, 0, 3); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 3); b+=0.5;
addThump(); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 3, 'slide', 5); b+=0.5; // 3/5
addNote(b, 0, 3); b+=0.5;
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;

b += 2.0;

// === VERSE (Fingerstyle Arpeggio) ===
// e-----5 2-0
// b---3 3
// g---0
// d-0
addNote(b, 3, 0); b+=0.5; // Bass D
addNote(b, 1, 3); b+=0.5;
addNote(b, 2, 0); b+=0.5;
addNote(b, 0, 5); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 0); b+=0.5;
addNote(b, 1, 3); b+=1.0;

// Walkdown
// b-2 2/3 e-0 2 3-2 0
addNote(b, 1, 2); b+=0.5;
addNote(b, 1, 2, 'slide', 3); b+=0.5;
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 3); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 0); b+=0.5;
addNote(b, 1, 3); b+=1.0;

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            // Use 'pluck' mostly, unless 'slide'
            AudioEngine.playString(note.string, note.fret, playTime, 0.4, note.target, note.type);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#fff';
    ctx.font = "16px 'Courier New'";
    ctx.fillStyle = '#00ffff';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#ff69b4';
    ctx.lineWidth = 4;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 180; 
    
    ctx.font = "20px 'Fredoka One'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ff69b4'; 
            let txt = note.fret;
            if(note.target) txt += '/';
            if(note.type === 'x') txt = 'X';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#111';
            ctx.fill();
            ctx.strokeStyle = '#ff69b4'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#fff'; 
            ctx.fillText(txt, x - 6, y + 6);
        }
    });

    // Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 60);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(0, 255, 255, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.08;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setFilter(1 - y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 7
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GEMINI // ETERNAL OPUS</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syncopate:wght@700&display=swap');

    :root {
        --void: #08080c;
        --star: #e2e2e2;
        --cyan: #00f0ff;
        --magenta: #ff0055;
        --gold: #ffd700;
    }

    body {
        margin: 0;
        background: var(--void);
        overflow: hidden;
        font-family: 'Space Mono', monospace;
        color: var(--star);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(8, 8, 12, 0.9);
        z-index: 10;
        transition: opacity 0.8s;
        backdrop-filter: blur(5px);
    }

    h1 {
        font-family: 'Syncopate', sans-serif;
        font-size: 4vw;
        margin: 0;
        text-transform: uppercase;
        background: linear-gradient(45deg, var(--cyan), var(--magenta));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: 10px;
        text-align: center;
    }

    p {
        font-weight: bold;
        margin-top: 20px;
        font-size: 1rem;
        color: var(--star);
        letter-spacing: 2px;
        opacity: 0.8;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 30px;
        left: 30px;
        font-size: 12px;
        pointer-events: none;
        z-index: 5;
        color: var(--star);
        border-left: 2px solid var(--cyan);
        padding-left: 15px;
        line-height: 1.5;
    }

    #chord-display {
        font-size: 3rem;
        font-weight: 700;
        color: var(--gold);
        margin-bottom: 5px;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }
    
    #mode-display {
        color: var(--magenta);
        text-transform: uppercase;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>THE ETERNAL<br>IMPROVISER</h1>
    <p>[ CLICK TO INITIATE GENERATIVE CORE ]</p>
    <p style="font-size: 0.7rem; margin-top: 2rem; opacity: 0.5;">MOUSE Y CONTROLS INTENSITY // GENERATED IN REALTIME</p>
</div>

<div id="hud">
    <div id="chord-display">Em9</div>
    <div id="mode-display">PHASE: ATMOSPHERIC</div>
    <div>SCALE: E DORIAN</div>
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * GEMINI ETERNAL OPUS
 * A self-composing generative guitar engine.
 */

// --- MUSIC THEORY KNOWLEDGE BASE ---
const THEORY = {
    // Strings: High E to Low E frequencies
    STRINGS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41],
    
    // E Dorian / Minor Pentatonic Pool
    // Format: [String Index (0-5), Fret]
    SCALES: {
        'Em_Pent': [
            [5,0], [5,3], [5,5], [5,7], [5,10], [5,12],
            [4,0], [4,2], [4,5], [4,7], [4,10], [4,12], 
            [3,0], [3,2], [3,5], [3,7], [3,9],  [3,12],
            [2,0], [2,2], [2,4], [2,7], [2,9],  [2,12],
            [1,0], [1,3], [1,5], [1,8], [1,10], [1,12],
            [0,0], [0,3], [0,5], [0,7], [0,10], [0,12]
        ],
        'E_Dorian': [ // Adds F# and C# to Em
            [5,0], [5,2], [5,3], [5,5], [5,7], [5,9], [5,10], [5,12],
            [4,0], [4,2], [4,4], [4,5], [4,7], [4,9], [4,10], [4,12],
            [3,0], [3,2], [3,4], [3,5], [3,7], [3,9], [3,11], [3,12],
            [2,0], [2,2], [2,4], [2,5], [2,7], [2,9], [2,11], [2,12],
            [1,0], [1,2], [1,3], [1,5], [1,7], [1,8], [1,10], [1,12],
            [0,0], [0,2], [0,3], [0,5], [0,7], [0,9], [0,10], [0,12]
        ]
    },
    
    // Chord Shapes (String, Fret)
    CHORDS: {
        'Em9': [[5,0], [4,2], [3,4], [2,0], [1,3], [0,2]],
        'Cmaj7': [[4,3], [3,5], [2,4], [1,5], [0,3]],
        'Am7': [[5,5], [4,7], [3,5], [2,5], [1,5], [0,5]],
        'Dadd11': [[5,10], [4,12], [3,11], [2,0], [1,10], [0,10]], // Big barre
        'G': [[5,3], [4,2], [3,0], [2,0], [1,3], [0,3]]
    },
    
    PROGRESSION: ['Em9', 'Cmaj7', 'Am7', 'Dadd11', 'Em9', 'G', 'Cmaj7', 'Dadd11']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    
    // FX Nodes
    drive: null,
    driveGain: null,
    reverb: null,
    reverbGain: null,
    delay: null,
    delayGain: null,
    
    // State
    isPlaying: false,
    intensity: 0.3, // 0.0 - 1.0 controlled by mouse

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.3;

        // 1. DYNAMIC DRIVE (Tube Screamer Emulation)
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(50); // Start low
        AudioEngine.drive.oversample = '4x';
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 1.0;

        // 2. ATMOSPHERIC DELAY
        AudioEngine.delay = AudioEngine.ctx.createDelay();
        AudioEngine.delay.delayTime.value = 0.375; // Dotted 8th ish
        AudioEngine.delayGain = AudioEngine.ctx.createGain();
        AudioEngine.delayGain.gain.value = 0.3;
        const delayFb = AudioEngine.ctx.createGain();
        delayFb.gain.value = 0.4;

        // 3. COSMIC REVERB
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(3.0, 2.0);
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.4;

        // ROUTING
        // Signal -> Drive -> Master
        //        -> Delay -> Master
        //        -> Reverb -> Master
        
        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        
        // Aux Sends from Master (Post-Drive)
        AudioEngine.master.connect(AudioEngine.delay);
        AudioEngine.delay.connect(delayFb);
        delayFb.connect(AudioEngine.delay);
        AudioEngine.delay.connect(AudioEngine.delayGain);
        AudioEngine.delayGain.connect(AudioEngine.ctx.destination);

        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playNote: (stringIdx, fret, time, duration = 1.0, type = 'pluck') => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = THEORY.STRINGS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Tone Morphing: Sine (Clean) -> Sawtooth (Dirty) based on Intensity
        const intensity = AudioEngine.intensity;
        
        if (intensity < 0.4) {
            osc1.type = 'sine';
            osc2.type = 'triangle';
        } else if (intensity < 0.7) {
            osc1.type = 'triangle';
            osc2.type = 'sawtooth';
        } else {
            osc1.type = 'sawtooth';
            osc2.type = 'square';
        }
        
        osc1.frequency.value = freq;
        osc2.frequency.value = freq;
        osc2.detune.value = intensity * 10; // Detune widens with intensity

        // Filter Envelope (The "Pluck")
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        const cutoffStart = 500 + (intensity * 4000); // Brightness
        filter.frequency.setValueAtTime(cutoffStart, t);
        filter.frequency.exponentialRampToValueAtTime(cutoffStart * 0.2, t + 0.2);
        filter.Q.value = 1 + (intensity * 5);

        // Amplitude Envelope
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.6, t + 0.01);
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration);

        // Mix
        const oscMix = AudioEngine.ctx.createGain();
        oscMix.gain.value = 0.5;

        osc1.connect(oscMix);
        osc2.connect(oscMix);
        oscMix.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
        
        // Visual Trigger
        triggerVisual(stringIdx, fret, intensity);
    },
    
    updateParams: () => {
        if (!AudioEngine.ctx) return;
        const t = AudioEngine.ctx.currentTime;
        const i = AudioEngine.intensity;
        
        // Morph FX based on intensity
        // Drive: 0 -> 400
        const driveAmount = i * 400;
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(driveAmount);
        
        // Delay: More delay on high intensity
        AudioEngine.delayGain.gain.setTargetAtTime(0.2 + (i * 0.3), t, 0.1);
    }
};

// --- THE COMPOSER (GENERATIVE LOGIC) ---
const Composer = {
    BPM: 110,
    nextNoteTime: 0,
    currentBar: 0,
    currentChordIdx: 0,
    
    // Rhythm Patterns (in 16th notes)
    patterns: [
        [1, 0, 0, 1, 0, 0, 1, 0], // 3-3-2 (Polyrhythm)
        [1, 0, 1, 0, 1, 0, 1, 0], // Straight 8ths
        [1, 0, 0, 0, 1, 0, 0, 0], // Quarter notes
        [1, 1, 1, 1, 1, 1, 1, 1]  // Shred (16ths)
    ],

    scheduler: () => {
        if (!AudioEngine.isPlaying) return;
        
        // Schedule ahead
        while (Composer.nextNoteTime < AudioEngine.ctx.currentTime + 0.2) {
            Composer.composeBeat(Composer.nextNoteTime);
            Composer.nextNoteTime += (60 / Composer.BPM) / 4; // Advance by 16th note
        }
        setTimeout(Composer.scheduler, 25);
    },

    composeBeat: (t) => {
        // 1. Determine Context
        const sixteenth = Math.floor((t * (Composer.BPM/60) * 4)) % 16; // 0-15 in a bar
        const bar = Math.floor((t * (Composer.BPM/60) / 4));
        
        // New Bar? Change Chord
        if (bar !== Composer.currentBar) {
            Composer.currentBar = bar;
            Composer.currentChordIdx = (Composer.currentChordIdx + 1) % THEORY.PROGRESSION.length;
            const chordName = THEORY.PROGRESSION[Composer.currentChordIdx];
            
            // Play the chord on beat 1
            const notes = THEORY.CHORDS[chordName];
            notes.forEach((n, i) => {
                // Strum effect
                AudioEngine.playNote(n[0], n[1], t + (i*0.02), 3.0);
            });
            
            // UI Update
            document.getElementById('chord-display').innerText = chordName;
            const intensity = AudioEngine.intensity;
            const mode = intensity < 0.3 ? "ATMOSPHERIC" : intensity < 0.7 ? "GROOVING" : "MELTING";
            document.getElementById('mode-display').innerText = `PHASE: ${mode}`;
        }

        // 2. Determine Lead Line (Based on Intensity)
        // Higher intensity = higher probability of notes & faster divisions
        const intensity = AudioEngine.intensity;
        let patternIdx = 0;
        if (intensity > 0.3) patternIdx = 1;
        if (intensity > 0.6) patternIdx = 0; // Syncopated
        if (intensity > 0.85) patternIdx = 3; // Shred
        
        const pattern = Composer.patterns[patternIdx];
        const step = sixteenth % 8;
        
        if (pattern[step] === 1) {
            // Play a lead note?
            // Chance increases with intensity
            if (Math.random() < intensity + 0.2) {
                // Pick a note from Scale
                const scale = THEORY.SCALES['E_Dorian'];
                // Pick note range based on intensity (Higher intensity = Higher fretboard)
                const minIdx = Math.floor(intensity * 20);
                const maxIdx = Math.min(scale.length - 1, minIdx + 15);
                
                // Random walk or random pick
                const noteIdx = Math.floor(Math.random() * (maxIdx - minIdx + 1)) + minIdx;
                const n = scale[noteIdx];
                
                // Add humanization
                const humanTime = t + (Math.random() * 0.02);
                AudioEngine.playNote(n[0], n[1], humanTime, 0.5);
            }
        }
    }
};

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const particles = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(string, fret, intensity) {
    // Create a burst at a position mapped to string/fret
    const x = (fret / 15) * w * 0.8 + (w * 0.1);
    const y = (string / 6) * h * 0.6 + (h * 0.2);
    
    // Color based on intensity
    let hue = 180; // Cyan
    if (intensity > 0.5) hue = 320; // Pink
    if (intensity > 0.8) hue = 50; // Gold
    
    particles.push({
        x: x, y: y,
        vx: (Math.random() - 0.5) * 5,
        vy: (Math.random() - 0.5) * 5,
        life: 1.0,
        hue: hue,
        size: 5 + (intensity * 20)
    });
}

function draw() {
    // Trails
    ctx.fillStyle = 'rgba(8, 8, 12, 0.2)';
    ctx.fillRect(0, 0, w, h);
    
    // Draw Strings
    ctx.lineWidth = 1;
    for(let i=0; i<6; i++) {
        const y = (i / 6) * h * 0.6 + (h * 0.2);
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
    }

    // Draw Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
        ctx.fillStyle = `hsla(${p.hue}, 100%, 50%, ${p.life})`;
        ctx.fill();
        
        // Glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = `hsla(${p.hue}, 100%, 50%, 1)`;
        
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        
        if (p.life <= 0) particles.splice(i, 1);
    }
    ctx.shadowBlur = 0;

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('click', async () => {
    if (!AudioEngine.ctx) {
        await AudioEngine.init();
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        Composer.nextNoteTime = AudioEngine.ctx.currentTime + 0.1;
        Composer.scheduler();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    // Map Y to Intensity (Bottom = 0, Top = 1)
    const y = 1 - (e.clientY / window.innerHeight);
    AudioEngine.intensity = Math.max(0.1, Math.min(1.0, y));
    AudioEngine.updateParams();
});

document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
        AudioEngine.isPlaying = !AudioEngine.isPlaying;
        if(AudioEngine.isPlaying) {
            Composer.nextNoteTime = AudioEngine.ctx.currentTime + 0.1;
            Composer.scheduler();
        }
    }
});

draw();

</script>
</body>
</html>

PROGRAM 8
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WITHOUT ME - CHORUS VOCAL</title>
<style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{background:#000;height:100vh;overflow:hidden;cursor:pointer;font-family:'Courier New', monospace; color: #ff0055;}
    canvas{position:fixed;top:0;left:0;z-index: 1; opacity: 0.6;}
    #ui{position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);text-align:center;z-index:10;pointer-events:none; width: 100%;}
    #t{font-size:3rem; font-weight: 900; letter-spacing:-0.05em; text-transform:uppercase; text-shadow: 0 0 30px #ff0055;}
    #sub{font-size: 1.2rem; margin-top: 10px; color: white; background: black; padding: 5px 10px;}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
    <div id="t">CLICK TO START</div>
    <div id="sub">VOLUME 250% | HIGH SPEED</div>
</div>

<script>
const AC = window.AudioContext || window.webkitAudioContext;
let ctx, master, limiter;
let started = false;

// 
// PITCH DATA (B Minor Scale)
// 
const F = {
    B1: 61.74, D2: 73.42, E2: 82.41, G2: 98.00, A2: 110.00, 
    B2: 123.47, D3: 146.83, E3: 164.81, Fs3: 185.00, G3: 196.00, A3: 220.00,
    B3: 246.94, Cs4: 277.18, D4: 293.66, E4: 329.63, Fs4: 369.99, G4: 392.00, A4: 440.00,
    B4: 493.88, Cs5: 554.37, D5: 587.33, E5: 659.25, Fs5: 739.99
};

// 
// AUDIO ENGINE
// 

async function init() {
    ctx = new AC();
    if (ctx.state === 'suspended') await ctx.resume();

    master = ctx.createGain();
    // REQUESTED: VOLUME 250%
    master.gain.value = 2.5; 

    // Hard Limiter to prevent speakers from exploding at 250% gain
    limiter = ctx.createDynamicsCompressor();
    limiter.threshold.value = -1; 
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;

    master.connect(limiter);
    limiter.connect(ctx.destination);
}

// 
// THE "SINGING" LOGIC (Adapted from your Orchestral File)
// 

function choirNote(freq, t, dur, vel = 0.6) {
    // 3 Oscillators per note for thickness
    for (let v = 0; v < 3; v++) {
        const osc = ctx.createOscillator();
        // Mix sine and triangle for "vocal" texture
        osc.type = v % 2 === 0 ? 'sawtooth' : 'triangle'; 
        osc.frequency.value = freq;
        osc.detune.value = (v - 1) * 6; // Chorus effect
        
        // FORMANT FILTER (The "Singing" part)
        // Bandpass around 800Hz-1200Hz mimics human vowels
        const f1 = ctx.createBiquadFilter();
        f1.type = 'bandpass';
        f1.frequency.value = 900 + (Math.random() * 200); 
        f1.Q.value = 2.5; // Resonant peak
        
        const env = ctx.createGain();
        env.gain.setValueAtTime(0, t);
        // Legato attack
        env.gain.linearRampToValueAtTime(vel * 0.15, t + 0.05); 
        env.gain.linearRampToValueAtTime(0, t + dur);
        
        osc.connect(f1);
        f1.connect(env);
        env.connect(master);
        
        osc.start(t);
        osc.stop(t + dur + 0.1);
    }
}

// 
// BACKING INSTRUMENTS
// 

function kick808(t) {
    const osc = ctx.createOscillator();
    osc.frequency.setValueAtTime(120, t);
    osc.frequency.exponentialRampToValueAtTime(45, t + 0.15);
    const env = ctx.createGain();
    env.gain.setValueAtTime(1.0, t);
    env.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
    osc.connect(env);
    env.connect(master);
    osc.start(t);
    osc.stop(t + 0.6);
    vis(t, 100, '#f05');
}

function snare(t) {
    const noise = ctx.createBufferSource();
    const b = ctx.createBuffer(1, 44100*0.2, 44100);
    const d = b.getChannelData(0);
    for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    noise.buffer = b;
    const f = ctx.createBiquadFilter();
    f.type = 'highpass'; f.frequency.value = 1000;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.7, t);
    g.gain.exponentialRampToValueAtTime(0.01, t+0.15);
    noise.connect(f); f.connect(g); g.connect(master);
    noise.start(t);
    vis(t, 50, '#fff');
}

function hihat(t) {
    const osc = ctx.createOscillator();
    osc.type = 'square'; osc.frequency.value = 800;
    const f = ctx.createBiquadFilter();
    f.type = 'highpass'; f.frequency.value = 6000;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.15, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.04);
    osc.connect(f); f.connect(g); g.connect(master);
    osc.start(t); osc.stop(t+0.05);
}

function guitar(freq, t, dur) {
    const osc = ctx.createOscillator();
    osc.type = 'sine'; osc.frequency.value = freq;
    const env = ctx.createGain();
    env.gain.setValueAtTime(0, t);
    env.gain.linearRampToValueAtTime(0.4, t+0.01);
    env.gain.exponentialRampToValueAtTime(0.01, t+dur);
    osc.connect(env); env.connect(master);
    osc.start(t); osc.stop(t+dur);
}

// 
// COMPOSITION
// 

function compose() {
    const t0 = ctx.currentTime + 0.2;
    // REQUESTED: SPEED UP (148 BPM)
    const BPM = 148; 
    const Q = 60 / BPM;     // Quarter Note
    const E = Q / 2;        // Eighth Note
    const BAR = Q * 4;

    let t = t0;

    //  INTRO RIFF (Kept as requested) 
    document.getElementById('t').innerText = "INTRO";
    
    // Simple fast riff to establish key
    [F.B2, F.Fs3, F.A3, F.D4, F.Fs4].forEach((n, i) => guitar(n, t + i*E, 1.0));
    t += BAR;
    [F.D2, F.A3, F.D4, F.A3].forEach((n, i) => guitar(n, t + i*E, 1.0));
    t += BAR;
    [F.A2, F.E3, F.A3, F.Cs4].forEach((n, i) => guitar(n, t + i*E, 1.0));
    t += BAR;
    [F.G2, F.B2, F.D3, F.G3].forEach((n, i) => guitar(n, t + i*E, 1.0));
    t += BAR;

    //  CHORUS (Logic: Choir Singing) 
    
    const sing = (note, time, dur) => choirNote(note, time, dur);
    const word = (txt) => setTimeout(() => document.getElementById('t').innerText = txt, (t - t0) * 1000);

    // Loop Chorus Twice
    for (let round = 0; round < 2; round++) {
        
        // BAR 1-2: Bm7 "Tell me how's it feel sittin' up there?"
        word("TELL ME");
        // Melody: F# F# E D E (Tell me how's it feel)
        sing(F.Fs4, t, E);
        sing(F.Fs4, t+E, E);
        sing(F.E4, t+2*E, E);
        sing(F.D4, t+3*E, E);
        sing(F.E4, t+4*E, Q);
        
        // Melody: F# F# A F# (Sittin' up there)
        sing(F.Fs4, t+6*E, E);
        sing(F.Fs4, t+7*E, E);
        sing(F.A4, t+8*E, E);
        sing(F.Fs4, t+9*E, Q);

        // Beat
        kick808(t); kick808(t+2.5*Q); snare(t+2*Q); snare(t+6*Q);
        for(let i=0;i<16;i++) hihat(t+i*E);
        
        t += BAR * 2;

        // BAR 3-4: A / G "Feeling so high but too far away to hold me"
        word("SO HIGH");
        // Melody: F# F# E D (Feeling so high)
        sing(F.Fs4, t, E);
        sing(F.Fs4, t+E, E);
        sing(F.E4, t+2*E, E);
        sing(F.D4, t+3*E, Q);

        // Melody: D E F# E D (But too far away)
        sing(F.D4, t+4*E, E);
        sing(F.E4, t+5*E, E);
        sing(F.Fs4, t+6*E, E);
        sing(F.E4, t+7*E, E);
        sing(F.D4, t+8*E, E);
        
        // Melody: B A B (To hold me)
        sing(F.B3, t+9*E, E);
        sing(F.A3, t+10*E, E);
        sing(F.B3, t+11*E, Q);

        // Beat
        kick808(t); kick808(t+3*Q); snare(t+2*Q); snare(t+6*Q);
        for(let i=0;i<16;i++) hihat(t+i*E);
        
        t += BAR * 2;

        // BAR 5-6: Bm7 "You know I'm the one who put you up there"
        word("UP THERE");
        // Melody: F# F# E D E (You know I'm the one)
        sing(F.Fs4, t, E);
        sing(F.Fs4, t+E, E);
        sing(F.E4, t+2*E, E);
        sing(F.D4, t+3*E, E);
        sing(F.E4, t+4*E, Q);
        
        // Melody: F# F# A F# (Put you up there)
        sing(F.Fs4, t+6*E, E);
        sing(F.Fs4, t+7*E, E);
        sing(F.A4, t+8*E, E);
        sing(F.Fs4, t+9*E, Q);

        // Beat
        kick808(t); kick808(t+2.5*Q); snare(t+2*Q); snare(t+6*Q);
        for(let i=0;i<16;i++) hihat(t+i*E);

        t += BAR * 2;

        // BAR 7-8: "Thinking you could live without me"
        word("WITHOUT ME");
        // Melody: F# F# E D (Thinking you could)
        sing(F.Fs4, t, E);
        sing(F.Fs4, t+E, E);
        sing(F.E4, t+2*E, E);
        sing(F.D4, t+3*E, Q);
        
        // Melody: F# E D (Live without me)
        sing(F.Fs4, t+4.5*Q, E);
        sing(F.E4, t+5*Q, E);
        sing(F.D4, t+5.5*Q, Q);

        // Beat
        kick808(t); snare(t+2*Q); snare(t+6*Q);
        for(let i=0;i<16;i++) hihat(t+i*E);
        
        t += BAR * 2;
    }
    
    setTimeout(() => document.getElementById('t').innerText = "FIN", (t - t0) * 1000);
}

// 
// VISUALS
// 

const canvas = document.getElementById('c');
const c = canvas.getContext('2d');
let w, h;
let pulses = [];

function resize() { w=canvas.width=window.innerWidth; h=canvas.height=window.innerHeight; }
window.addEventListener('resize', resize); resize();

function vis(t, r, col) {
    setTimeout(() => {
        pulses.push({r:10, max:r*2, col:col, a:1});
    }, (t - ctx.currentTime)*1000);
}

function loop() {
    requestAnimationFrame(loop);
    c.fillStyle = 'rgba(0,0,0,0.1)';
    c.fillRect(0,0,w,h);
    pulses.forEach((p, i) => {
        c.beginPath(); c.arc(w/2, h/2, p.r, 0, Math.PI*2);
        c.strokeStyle = p.col; c.lineWidth = 5; c.globalAlpha = p.a;
        c.stroke();
        p.r += 10; p.a *= 0.9;
        if(p.a < 0.01) pulses.splice(i,1);
    });
}
loop();

document.addEventListener('click', async () => {
    if(started) return; started=true;
    await init(); compose();
});
</script>
</body>
</html>

PROGRAM 9
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HATIKVAH // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Courier+New:wght@700&display=swap');

    :root {
        --bg: #001a33; /* Deep Blue */
        --ink: #e6f2ff;
        --accent: #ffffff; /* White (Flag colors) */
        --gold: #ffd700;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Cinzel', serif;
        color: var(--ink);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 26, 51, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 4rem;
        margin: 0;
        color: var(--accent);
        text-shadow: 0 0 20px var(--ink);
        letter-spacing: 5px;
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--gold);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--ink);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>HATIKVAH</h1>
    <p>[ CLICK TO BEGIN ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = REVERB // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: CLASSICAL GUITAR<br>
    BPM: 68 (Adagio)
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * HATIKVAH ENGINE
 * Classical Physics + Anthem Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 68, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.6;

        // Cathedral Reverb (Long, Sparse)
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(4.0, 3.0);
        
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.4;

        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // Classical Tone: Pure Triangle/Sine blend
    playString: (stringIdx, fret, time, duration = 2.0, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        osc1.type = 'triangle'; 
        osc2.type = 'sine'; 
        
        osc1.frequency.value = freq;
        osc2.frequency.value = freq;

        // Filter (Warm, rounded)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1200; // Classical warmth
        filter.Q.value = 0;

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.5, t + 0.05); // Slower attack (fingerstyle)
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix: Mostly Triangle for body
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.6;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.4;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setReverb: (val) => {
        if(AudioEngine.reverbGain) AudioEngine.reverbGain.gain.setTargetAtTime(val, AudioEngine.ctx.currentTime, 0.1);
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck') {
    TAB.push({ beat, string, fret, type });
}
function addChord(beat, notes) {
    notes.forEach(n => addNote(beat, n[0], n[1]));
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// === PART 1: Verse Melody ===
// Dm Gm Dm Gm Dm A7 Dm
// G: 0 2 2 | 3 2 3 (B:3) 2 |
// D: 0 2 3 | ...

// Phrase 1
// D-0 D-2 D-3 G-0 G-2 G-2
addNote(b, 3, 0); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 3); b+=E;
addNote(b, 2, 0); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 2, 2); b+=E;

// Phrase 2
// G-3 G-2 G-3 B-3 G-2
addNote(b, 2, 3); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 2, 3); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 2, 2); b+=Q; // Hold

// Phrase 3 (Piano Bridge Sim)
// D-5 D-55 D-3 D-3
addNote(b, 3, 5); b+=Q;
addNote(b, 3, 5); b+=E;
addNote(b, 3, 5); b+=E;
addNote(b, 3, 3); b+=Q;
addNote(b, 3, 3); b+=Q;

// Phrase 4 (Resolution)
// D-2 D-0 D-2 D-3 D-0
addNote(b, 3, 2); b+=E;
addNote(b, 3, 0); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 3); b+=E;
addNote(b, 3, 0); b+=Q;
// A-0
addNote(b, 4, 0); b+=Q;

// REPEAT Part 1
// D-0 2 3 G-0 2 2
addNote(b, 3, 0); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 3); b+=E;
addNote(b, 2, 0); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 2, 2); b+=E;

// G-3 2 3 B-3 G-2
addNote(b, 2, 3); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 2, 3); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 2, 2); b+=Q;

// D-5 55 3 3
addNote(b, 3, 5); b+=Q;
addNote(b, 3, 5); b+=E;
addNote(b, 3, 5); b+=E;
addNote(b, 3, 3); b+=Q;
addNote(b, 3, 3); b+=Q;

// D-2 0 2 3 0
addNote(b, 3, 2); b+=E;
addNote(b, 3, 0); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 3); b+=E;
addNote(b, 3, 0); b+=Q*2;

b+=2.0; // Breath

// === PART 2: Chorus (High Part) ===
// Dm Bb C7 F
// B-3 3 3 | 1 3 1 G-3 G-2
addNote(b, 3, 0); // Bass D
addNote(b, 1, 3); b+=Q;
addNote(b, 1, 3); b+=E;
addNote(b, 1, 3); b+=E;

addNote(b, 1, 1); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 1, 1); b+=Q; // Hold F chord root? No melody
addNote(b, 2, 3); b+=E;
addNote(b, 2, 2); b+=E;

// Bridge (D-0 2 3)
addNote(b, 3, 0); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 3); b+=E;

// Repeat Chorus Line
// B-3 3 3 | 1 3 1 G-3 G-2
addNote(b, 3, 0); // Bass
addNote(b, 1, 3); b+=Q;
addNote(b, 1, 3); b+=E;
addNote(b, 1, 3); b+=E;

addNote(b, 1, 1); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 1, 1); b+=Q; 
addNote(b, 2, 3); b+=E;
addNote(b, 2, 2); b+=E;

// G-(2 2 3) Optional
addNote(b, 2, 2); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 2, 3); b+=E;

// B-1 111
addNote(b, 1, 1); b+=Q;
addNote(b, 1, 1); b+=E;
addNote(b, 1, 1); b+=E;
addNote(b, 1, 1); b+=E;

// Bridge D-3 3
addNote(b, 3, 3); b+=E;
addNote(b, 3, 3); b+=E;

// B-1 G-0 2 3 2 0 D-3
addNote(b, 1, 1); b+=Q;
addNote(b, 2, 0); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 2, 3); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 2, 0); b+=E;
addNote(b, 3, 3); b+=E;

// G-0 0 0
addNote(b, 2, 0); b+=Q;
addNote(b, 2, 0); b+=E;
addNote(b, 2, 0); b+=E;

// D-3 3 2 0 2 3 0
addNote(b, 3, 3); b+=E;
addNote(b, 3, 3); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 0); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 3); b+=E;
addNote(b, 3, 0); b+=Q*2;

// Bridge (0 2 3)
addNote(b, 3, 0); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 3); b+=E;

// === PART 3: Octave Up (Ritenuto) ===
// B-8 888 G-10 10
addNote(b, 1, 8); b+=Q;
addNote(b, 1, 8); b+=E;
addNote(b, 1, 8); b+=E;
addNote(b, 1, 8); b+=E;
addNote(b, 2, 10); b+=E;
addNote(b, 2, 10); b+=E;

// B-8 10 11 10 8 G-10 8
addNote(b, 1, 8); b+=E;
addNote(b, 1, 10); b+=E;
addNote(b, 1, 11); b+=Q;
addNote(b, 1, 10); b+=E;
addNote(b, 1, 8); b+=E;
addNote(b, 2, 10); b+=E;
addNote(b, 1, 8); b+=E;

// B-8 G-10 10 10
addNote(b, 1, 8); b+=Q;
addNote(b, 2, 10); b+=E;
addNote(b, 2, 10); b+=Q;
addNote(b, 2, 10); b+=Q;

// G-9 7 9 10 7
addNote(b, 2, 9); b+=E;
addNote(b, 2, 7); b+=E;
addNote(b, 2, 9); b+=E;
addNote(b, 2, 10); b+=E;
addNote(b, 2, 7); b+=Q*2;

// Final Dm Chord (Barre 5th Fret)
addChord(b, [[0,5], [1,6], [2,7], [3,7], [4,5]]);
b+=4.0;

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    let elapsed = currentTime - startTime;
    
    // Ritenuto Logic: Slow down time calculation near end
    // If we are past a certain beat, map elapsed time to a slower curve
    // For simplicity in this engine, we just let it play at constant BPM
    // The "slowing down" is effectively baked into longer durations if we programmed it that way, 
    // but here we will just keep steady Adagio.
    
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 2.5, null, null);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#66a3ff';
    ctx.font = "16px 'Courier New'";
    ctx.fillStyle = '#ffffff';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 100; // Slow scroll
    
    ctx.font = "20px 'Cinzel'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ffffff'; 
            let txt = note.fret;
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#002244';
            ctx.fill();
            ctx.strokeStyle = '#ffffff'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#ffffff'; 
            ctx.fillText(txt, x - 6, y + 3);
        }
    });

    // Ripples
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 40);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${n.life * 0.5})`;
        ctx.lineWidth = 2;
        ctx.stroke();

        n.life -= 0.02; // Slow fade
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setReverb(y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 10
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JANA GANA MANA // ANTHEM ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Rozha+One&family=Courier+New:wght@700&display=swap');

    :root {
        --saffron: #FF9933;
        --white: #FFFFFF;
        --green: #138808;
        --chakra: #000080; /* Navy Blue */
        --bg: #fdfcf0; /* Cream/Paper */
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Rozha One', serif;
        color: var(--chakra);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(253, 252, 240, 0.95);
        z-index: 10;
        transition: opacity 0.8s;
    }

    h1 {
        font-size: 4rem;
        margin: 0;
        background: linear-gradient(to bottom, var(--saffron), var(--green));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 2px 10px rgba(0,0,0,0.1);
        text-align: center;
        line-height: 1.2;
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.2rem;
        color: var(--chakra);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 30px;
        left: 30px;
        font-family: 'Courier New', monospace;
        font-size: 16px;
        pointer-events: none;
        z-index: 5;
        color: var(--chakra);
        border-left: 4px solid var(--saffron);
        padding-left: 15px;
    }
    
    .chakra-wheel {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        width: 300px; height: 300px;
        border: 2px solid var(--chakra);
        border-radius: 50%;
        opacity: 0.05;
        z-index: 0;
    }
    .spoke {
        position: absolute;
        top: 50%; left: 50%;
        width: 100%; height: 2px;
        background: var(--chakra);
        transform-origin: 0 0;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>JANA GANA MANA</h1>
    <p>[ CLICK TO BEGIN ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = REVERB // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: NYLON STRING<br>
    BPM: 52 (Anthem)
</div>

<div class="chakra-wheel" id="wheel">
    <!-- JS will populate spokes -->
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * JANA GANA MANA ENGINE
 * Nylon Guitar Physics + Anthem Tab
 */

// Populate Chakra
const wheel = document.getElementById('wheel');
for(let i=0; i<24; i++) {
    const spoke = document.createElement('div');
    spoke.className = 'spoke';
    spoke.style.transform = `rotate(${i * 15}deg)`;
    wheel.appendChild(spoke);
}

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 52, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.6; 

        // Cathedral Reverb
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(3.0, 3.0); 
        
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.4;

        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // Nylon String Tone
    playString: (stringIdx, fret, time, duration = 2.0, slideTo = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Nylon: Sine dominant with subtle Triangle
        osc1.type = 'sine'; 
        osc2.type = 'triangle'; 
        
        let targetFreq = freq;
        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter: Warm pluck
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(2000, t);
        filter.frequency.exponentialRampToValueAtTime(800, t + 0.1); 
        filter.Q.value = 0;

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.6, t + 0.02); // Finger pluck attack
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.7;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.3;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setReverb: (val) => {
        if(AudioEngine.reverbGain) {
            AudioEngine.reverbGain.gain.setTargetAtTime(val, AudioEngine.ctx.currentTime, 0.1);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}
function addChord(beat, notes) {
    notes.forEach(n => addNote(beat, n[0], n[1]));
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; // Quarter note (The beat)
const E = 0.5; // Eighth note

// === JANA GANA MANA ===
// Key: C Major (Tab is in C relative to open strings/frets shown)
// Timing: 4/4 roughly, but lyrical phrasing is key.

// Phrase 1: "Jana Gana Mana Adhinayaka Jaya He"
// e---0-2-2-2---2-2-2---2-2-0-2-3---2---2-2-0---0-0---0
// B-3
// D-0
// A-4 2 0 0
// E 3

// e-0 (beat 1)
addNote(b, 0, 0); addNote(b, 1, 3); addNote(b, 3, 0); b+=Q;
// e-2 2 2 (Jana Gana)
addNote(b, 0, 2); b+=Q;
addNote(b, 0, 2); b+=Q;
addNote(b, 0, 2); b+=Q;

// e-2 2 2 (Mana Adhi)
addNote(b, 0, 2); addNote(b, 4, 4); b+=Q; // Bass C# (A-4)
addNote(b, 0, 2); b+=Q;
addNote(b, 0, 2); b+=Q;

// e-2 2 0 2 3 (Nayaka)
addNote(b, 0, 2); addNote(b, 4, 2); b+=Q; // Bass B
addNote(b, 0, 2); b+=E;
addNote(b, 0, 0); b+=E;
addNote(b, 0, 2); b+=E;
addNote(b, 0, 3); b+=E;

// e-2 (Jaya)
addNote(b, 0, 2); addNote(b, 5, 3); b+=Q; // Bass G
addNote(b, 0, 2); b+=E;
addNote(b, 0, 2); b+=E;

// e-0 0 0 0 (He)
addNote(b, 0, 0); addNote(b, 4, 0); b+=Q; // Bass A
addNote(b, 0, 0); b+=E;
addNote(b, 0, 0); b+=E;
addNote(b, 0, 0); addNote(b, 4, 0); b+=Q; 

// Phrase 2: "Bharata Bhagya Vidhata"
// e-5 5 5 5 5 4 5 5 5 4 7 5 3 3 3 3 3 2 0 3 2
// B-3 3 3 3
// G-0 3
// D-5 0
// A-5 4 2 0 0
// E 3

// e-5 5 5 5 (Bharata)
addNote(b, 0, 5); addNote(b, 1, 3); addNote(b, 4, 5); b+=Q; // Bass D
addNote(b, 0, 5); b+=Q;
addNote(b, 0, 5); b+=Q;
addNote(b, 0, 5); b+=Q;

// e-5 4 5 (Bhagya)
addNote(b, 0, 5); addNote(b, 1, 3); addNote(b, 4, 4); b+=Q; // Bass C#
addNote(b, 0, 4); b+=E;
addNote(b, 0, 5); b+=Q; // Hold?

// e-5 5 4 7 5 (Vidhata)
addNote(b, 0, 5); addNote(b, 1, 3); addNote(b, 4, 2); b+=Q; // Bass B
addNote(b, 0, 5); b+=E;
addNote(b, 0, 4); b+=E;
addNote(b, 0, 7); b+=E;
addNote(b, 0, 5); b+=E;

// e-3 3 3 3 (Punjab Sindhu)
// G-0
// E-3
addNote(b, 0, 3); addNote(b, 1, 3); addNote(b, 2, 0); addNote(b, 5, 3); b+=Q;
addNote(b, 0, 3); b+=Q;
addNote(b, 0, 3); b+=Q;
addNote(b, 0, 3); b+=Q;

// e-3 2 0 3 2 (Gujarata Maratha)
// G-3
// D-5
// A-0
addNote(b, 0, 3); addNote(b, 1, 3); addNote(b, 2, 3); addNote(b, 3, 5); b+=Q;
addNote(b, 0, 2); b+=E;
addNote(b, 0, 0); b+=E;
addNote(b, 0, 3); b+=E;
addNote(b, 0, 2); addNote(b, 1, 3); addNote(b, 3, 0); b+=Q; // D Bass

b+=1.0; // Breath

// Phrase 3: "Dravida Utkala Banga"
// e-2 2 2 2 2 0 5 5 5 3 3 2 2 2 0 0 0 0 0
// B-3 1 3 3 3 3 3 3 2 2 3
// G-2 2 0 2 2
// D-0 0 2 0 0
// A 3 0 0
// E 3 3

// e-2 2 2 2 (Dravida)
addNote(b, 0, 2); addNote(b, 1, 3); addNote(b, 2, 2); addNote(b, 3, 0); b+=Q;
addNote(b, 0, 2); b+=Q;
addNote(b, 0, 2); b+=Q;
addNote(b, 0, 2); b+=Q;

// e-2 0 5 5 5 (Utkala)
addNote(b, 0, 2); addNote(b, 1, 1); addNote(b, 2, 2); addNote(b, 3, 0); b+=Q;
addNote(b, 0, 0); b+=E;
addNote(b, 0, 5); addNote(b, 1, 3); addNote(b, 5, 3); b+=Q;
addNote(b, 0, 5); b+=E;
addNote(b, 0, 5); b+=E;

// e-3 3 2 2 2 (Banga)
addNote(b, 0, 3); addNote(b, 1, 3); addNote(b, 2, 0); addNote(b, 3, 2); addNote(b, 4, 3); b+=Q; // C chord
addNote(b, 0, 3); b+=E; // Tab shows 3-3 split?
// "3 3 2"
addNote(b, 0, 3); b+=Q;
addNote(b, 0, 2); addNote(b, 1, 3); addNote(b, 2, 2); addNote(b, 3, 0); b+=Q; // D
addNote(b, 0, 2); b+=E;
addNote(b, 0, 2); b+=E;

// e-0 0 0 0 0 (Vindhya...)
addNote(b, 0, 0); addNote(b, 1, 2); addNote(b, 2, 2); addNote(b, 4, 0); b+=Q;
addNote(b, 0, 0); b+=E;
addNote(b, 0, 0); b+=E;
addNote(b, 0, 0); b+=Q;
addNote(b, 0, 0); addNote(b, 1, 3); addNote(b, 3, 0); b+=Q; // End phrase

b+=1.0;

// Phrase 4: "Jaya He, Jaya He, Jaya He"
// e-2 2 2 2 2 2 2 2 0 2 3
// B-3 1 3 3
// G-2 2 0 0
// D-0 0
// A 3
// E 3

// e-2 (repeated)
addNote(b, 0, 2); addNote(b, 1, 3); addNote(b, 2, 2); addNote(b, 3, 0); b+=Q;
for(let i=0; i<7; i++) {
    addNote(b, 0, 2); b+=E;
}

// e-0 2 3
addNote(b, 0, 0); addNote(b, 1, 1); addNote(b, 2, 2); addNote(b, 3, 0); b+=Q;
addNote(b, 0, 2); b+=E;
addNote(b, 0, 3); addNote(b, 1, 3); addNote(b, 2, 0); addNote(b, 4, 3); addNote(b, 5, 3); b+=Q*2; // G/C

// Phrase 5: "Jaya Jaya Jaya Jaya He"
// e-2 3 5 5 5 3 2 0 3 2
// B-3 2 3 3
// G-2 2
// D-0 0
// A 4 1
// E

// e-2 3 5 (Jaya)
addNote(b, 0, 2); addNote(b, 1, 3); addNote(b, 2, 2); addNote(b, 3, 0); b+=Q;
addNote(b, 0, 3); b+=E;
addNote(b, 0, 5); addNote(b, 4, 4); b+=Q; // C#dim?

// e-5 5 3 (Jaya)
addNote(b, 0, 5); b+=E;
addNote(b, 0, 5); b+=E;
addNote(b, 0, 3); addNote(b, 1, 2); addNote(b, 4, 1); b+=Q; // Bb?

// e-2 0 3 2 (Jaya He)
addNote(b, 0, 2); b+=E;
addNote(b, 0, 0); b+=E;
addNote(b, 0, 3); addNote(b, 1, 3); addNote(b, 2, 2); addNote(b, 3, 0); b+=Q;
addNote(b, 0, 2); addNote(b, 1, 3); b+=Q*2;

// Ending
// e-2 2 2 0 0 0 0 0
// B-3 2 2 3
// G-2 2
// D-0 0
// A 0 0
// E

addNote(b, 0, 2); addNote(b, 1, 3); addNote(b, 2, 2); addNote(b, 3, 0); b+=Q;
addNote(b, 0, 2); b+=E;
addNote(b, 0, 2); b+=E;

addNote(b, 0, 0); addNote(b, 1, 2); addNote(b, 2, 2); addNote(b, 4, 0); b+=Q;
addNote(b, 0, 0); b+=E;
addNote(b, 0, 0); b+=E;
addNote(b, 0, 0); b+=Q;
addNote(b, 0, 0); addNote(b, 1, 3); addNote(b, 3, 0); b+=Q*3; // Final Chord

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 2.0, note.target);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#000080';
    ctx.font = "16px 'Courier New'";
    ctx.fillStyle = '#138808';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#FF9933';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 80; 
    
    ctx.font = "20px 'Rozha One'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#FF9933'; // Saffron
            let txt = note.fret;
            if(note.target) txt += '/';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#000080'; // Navy
            ctx.fill();
            ctx.strokeStyle = '#138808'; // Green
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#fff'; 
            ctx.fillText(txt, x - 6, y + 6);
        }
    });

    // Ripples
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 60);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 153, 51, ${n.life})`;
        ctx.lineWidth = 3;
        ctx.stroke();

        n.life -= 0.01; // Slow fade for reverence
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setReverb(y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 11
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SODA POP // K-POP ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Modak&family=Varela+Round&display=swap');

    :root {
        --bg: #ffecf2; /* Pastel Pink */
        --bubble: #00f0ff; /* Cyan */
        --pop: #ff0055; /* Hot Pink */
        --fizz: #ccff00; /* Lime */
        --text: #2d3436;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Modak', cursive;
        color: var(--text);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(255, 236, 242, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 6rem;
        margin: 0;
        color: var(--pop);
        text-shadow: 4px 4px 0px var(--bubble);
        letter-spacing: 2px;
        text-align: center;
        line-height: 0.9;
        transform: rotate(-3deg);
    }

    p {
        font-family: 'Varela Round', sans-serif;
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.5rem;
        color: var(--text);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 30px;
        left: 30px;
        font-family: 'Varela Round', sans-serif;
        font-size: 16px;
        pointer-events: none;
        z-index: 5;
        color: var(--pop);
        background: rgba(255,255,255,0.8);
        padding: 10px;
        border-radius: 20px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    
    .bubble-decoration {
        position: absolute;
        border-radius: 50%;
        background: var(--bubble);
        opacity: 0.5;
        z-index: 0;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>SODA POP<br><span style="font-size: 3rem; color: var(--fizz);">K-POP ENGINE</span></h1>
    <p>Click to Open!</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = FIZZ (FILTER) // SPACE = PAUSE</p>
</div>

<div id="hud">
    GENRE: K-POP / FUTURE BASS<br>
    BPM: 128
</div>

<!-- Decor -->
<div class="bubble-decoration" style="top:10%; left:10%; width:100px; height:100px;"></div>
<div class="bubble-decoration" style="bottom:20%; right:10%; width:150px; height:150px; background:var(--fizz);"></div>

<canvas id="canvas"></canvas>

<script>
/**
 * K-POP SODA ENGINE
 * Polished Production + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 128, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    filter: null,
    drumBus: null,
    synthBus: null,
    bassBus: null,
    
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.6; 

        // Global "Fizz" Filter (Highpass/Lowpass sweep)
        AudioEngine.filter = AudioEngine.ctx.createBiquadFilter();
        AudioEngine.filter.type = 'lowpass';
        AudioEngine.filter.frequency.value = 20000;
        AudioEngine.filter.Q.value = 1.0;

        // Busses
        AudioEngine.drumBus = AudioEngine.ctx.createGain();
        AudioEngine.synthBus = AudioEngine.ctx.createGain();
        AudioEngine.bassBus = AudioEngine.ctx.createGain();

        // Master Chain
        AudioEngine.drumBus.connect(AudioEngine.master);
        AudioEngine.synthBus.connect(AudioEngine.filter);
        AudioEngine.bassBus.connect(AudioEngine.filter);
        AudioEngine.filter.connect(AudioEngine.master);
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        
        // K-Pop Polish (Reverb)
        const verb = AudioEngine.ctx.createConvolver();
        verb.buffer = await AudioEngine.createImpulse(1.5, 2.0); // Tight, bright room
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.2;
        AudioEngine.synthBus.connect(verbMix);
        verbMix.connect(verb);
        verb.connect(AudioEngine.master);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = length - i;
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // --- INSTRUMENTS ---

    playKick: (time) => {
        const t = time;
        // Punchy K-Pop Kick
        const osc = AudioEngine.ctx.createOscillator();
        const gain = AudioEngine.ctx.createGain();
        
        osc.frequency.setValueAtTime(180, t);
        osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
        
        gain.gain.setValueAtTime(1.0, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        
        osc.connect(gain);
        gain.connect(AudioEngine.drumBus);
        
        osc.start(t);
        osc.stop(t + 0.3);

        // Sidechain
        AudioEngine.synthBus.gain.cancelScheduledValues(t);
        AudioEngine.synthBus.gain.setValueAtTime(0.3, t); 
        AudioEngine.synthBus.gain.linearRampToValueAtTime(1.0, t + 0.1);
        
        AudioEngine.bassBus.gain.cancelScheduledValues(t);
        AudioEngine.bassBus.gain.setValueAtTime(0.0, t); 
        AudioEngine.bassBus.gain.linearRampToValueAtTime(0.8, t + 0.15);
        
        visualKick();
    },

    playSnare: (time, type='snap') => {
        const t = time;
        // K-Pop Snare is often a layered Snap/Clap/Snare
        
        // Noise (Crisp)
        const bufSize = AudioEngine.ctx.sampleRate * 0.1;
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = AudioEngine.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 2000; // High snap
        
        const noiseEnv = AudioEngine.ctx.createGain();
        noiseEnv.gain.setValueAtTime(0.6, t);
        noiseEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseEnv);
        noiseEnv.connect(AudioEngine.drumBus);
        noise.start(t);
        
        if (type === 'snare') {
            // Add body for snare sections
            const osc = AudioEngine.ctx.createOscillator();
            osc.frequency.setValueAtTime(250, t);
            osc.frequency.exponentialRampToValueAtTime(150, t + 0.1);
            const oscEnv = AudioEngine.ctx.createGain();
            oscEnv.gain.setValueAtTime(0.5, t);
            oscEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            osc.connect(oscEnv);
            oscEnv.connect(AudioEngine.drumBus);
            osc.start(t);
        }
    },

    playHat: (time) => {
        // Trap Hi-Hat (Tight)
        const t = time;
        const bufSize = AudioEngine.ctx.sampleRate * 0.05;
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = AudioEngine.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 10000; // Sizzle
        
        const env = AudioEngine.ctx.createGain();
        env.gain.setValueAtTime(0.3, t);
        env.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(env);
        env.connect(AudioEngine.drumBus);
        
        noise.start(t);
    },

    playBass: (freq, time, duration) => {
        const t = time;
        // 808 Style Bass
        const osc = AudioEngine.ctx.createOscillator();
        osc.type = 'sine'; // Pure sub
        osc.frequency.value = freq;
        
        // Add a bit of square for texture
        const osc2 = AudioEngine.ctx.createOscillator();
        osc2.type = 'square';
        osc2.frequency.value = freq;
        
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.8, t + 0.01);
        amp.gain.setValueAtTime(0.8, t + duration - 0.05);
        amp.gain.linearRampToValueAtTime(0, t + duration);
        
        const amp2 = AudioEngine.ctx.createGain();
        amp2.gain.value = 0.2; // Lower vol for square
        
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;

        osc.connect(amp);
        osc2.connect(filter); filter.connect(amp2); amp2.connect(amp);
        
        amp.connect(AudioEngine.bassBus);
        
        osc.start(t); osc.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    // Glassy Synth Pluck (Guitar Tab Simulation)
    playString: (stringIdx, fret, time, duration = 0.5, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // K-Pop Tone: Bright, Clean, Digital
        osc1.type = 'square'; 
        osc2.type = 'sine'; 
        
        // Pitch Logic
        let targetFreq = freq;
        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Envelope (Pluck)
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.5, t + 0.005); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Filter (FM-ish)
        const nFilter = AudioEngine.ctx.createBiquadFilter();
        nFilter.type = 'lowpass';
        nFilter.frequency.setValueAtTime(4000, t);
        nFilter.frequency.exponentialRampToValueAtTime(500, t + 0.2); 
        nFilter.Q.value = 3; // Resonance for "Pop" sound

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.3;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.7;

        osc1.connect(osc1Gain); osc1Gain.connect(nFilter);
        osc2.connect(osc2Gain); osc2Gain.connect(nFilter);
        nFilter.connect(amp);
        amp.connect(AudioEngine.synthBus);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setFilter: (val) => {
        if(AudioEngine.filter) {
            // Fizz control
            const freq = 200 + (val * 19800);
            AudioEngine.filter.frequency.setTargetAtTime(freq, AudioEngine.ctx.currentTime, 0.1);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
const DRUMS = [];
const BASS = [];

function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}
function addChord(beat, notes) {
    notes.forEach(n => addNote(beat, n[0], n[1]));
}
function addDrum(beat, type) {
    DRUMS.push({ beat, type });
}
function addBass(beat, freq, dur) {
    BASS.push({ beat, freq, dur });
}

// -- BUILD THE SONG --
let b = 0.0;
const E = 0.5; // 8th note
const S = 0.25; // 16th note

// === INTRO ===
// C G F G F
// C (x3555x) G (355433) F (133211)
// Rhythm: Stabs / Pop feel
// [Intro] C G F C G F C G F
// e:---------
// B:---------
// G:---------
// D:---------
// A:---3-----
// E:-------3-
// Let's use power chords for the synths
function addIntro() {
    // C
    addChord(b, [[4,3], [3,5]]); b+=1.0;
    // G
    addChord(b, [[5,3], [4,5]]); b+=1.0;
    // F
    addChord(b, [[5,1], [4,3]]); b+=1.0;
    // C
    addChord(b, [[4,3], [3,5]]); b+=1.0;
    
    // Hey hey part (Drum hits)
    addDrum(b-1.0, 'snare'); // Snap
    addDrum(b-0.5, 'snare'); // Snap
}

addIntro();
addIntro(); // x2

// === VERSE 1 ===
// C G F C
// Bass pulse
// Rhythm: 1 . 2 . 3 . 4 .
// Kick on 1, 3
// Melody on Synth
b += 1.0;

function addVerseLine(rootBass) {
    // Bass 8ths
    for(let i=0; i<8; i++) {
        addBass(b + i*E, rootBass, S);
    }
    // Drums (Soft)
    addDrum(b, 'kick');
    addDrum(b+1.0, 'snare'); // snap
    addDrum(b+2.0, 'kick');
    addDrum(b+3.0, 'snare'); // snap
    // Hats
    for(let i=0; i<8; i++) addDrum(b + i*E, 'hat');
    
    b += 4.0;
}

// C (130.81 Hz - C3, let's go lower C2 65.41)
addVerseLine(65.41);
// G (49.00 Hz - G1)
addVerseLine(49.00);
// F (43.65 Hz - F1)
addVerseLine(43.65);
// C
addVerseLine(65.41);

// "Got a feeling..." (Repeat progression)
addVerseLine(65.41);
addVerseLine(49.00);
addVerseLine(43.65);
addVerseLine(65.41);

// === PRE-CHORUS (BUILD) ===
// F Am G
// Snare roll build up
// Melody chords
// F
addChord(b, [[5,1], [4,3], [3,2]]); 
addBass(b, 43.65, 2.0);
addDrum(b, 'kick'); addDrum(b+1.0, 'kick');
b += 2.0;

// Am (A-0 D-2 G-2)
addChord(b, [[4,0], [3,2], [2,2]]);
addBass(b, 55.00, 1.0); // A1
addDrum(b, 'kick'); 
b += 1.0;

// G
addChord(b, [[5,3], [4,5], [3,4]]);
addBass(b, 49.00, 1.0);
addDrum(b, 'kick');
b += 1.0;

// F again
addChord(b, [[5,1], [4,3], [3,2]]); 
addBass(b, 43.65, 2.0);
addDrum(b, 'kick'); addDrum(b+0.5, 'kick'); addDrum(b+1.0, 'kick'); addDrum(b+1.5, 'kick');
b += 2.0;

// "So refreshing... My little soda pop" (Silence/Fill)
addDrum(b, 'snare'); addDrum(b+0.25, 'snare'); addDrum(b+0.5, 'snare');
b += 2.0;

// === CHORUS (DROP) ===
// C G F
// Full K-Pop Energy
// Melody: High C-0 (E string 8th fret) G-2 (G-string 12)
// Let's play chords rhythmically
// Rhythm: 1 & (2) & 3 & (4) &

function addChorusBar(chord, bassFreq) {
    const start = b;
    // Chords (Syncopated)
    addChord(start, chord);
    addChord(start+0.75, chord);
    addChord(start+1.5, chord);
    addChord(start+2.25, chord);
    addChord(start+3.0, chord);
    
    // Bass (Sidechain pulse)
    addBass(start, bassFreq, 0.2);
    addBass(start+0.5, bassFreq, 0.2);
    addBass(start+1.0, bassFreq, 0.2);
    addBass(start+1.5, bassFreq, 0.2);
    addBass(start+2.0, bassFreq, 0.2);
    addBass(start+2.5, bassFreq, 0.2);
    addBass(start+3.0, bassFreq, 0.2);
    addBass(start+3.5, bassFreq, 0.2);
    
    // Drums (4 on floor)
    for(let i=0; i<4; i++) {
        addDrum(start + i*1.0, 'kick');
        addDrum(start + i*1.0 + 0.5, 'hat');
    }
    addDrum(start+1.0, 'snare'); // Snare
    addDrum(start+3.0, 'snare');
    
    b += 4.0;
}

const C_Major = [[4,3], [3,5], [2,5]];
const G_Major = [[5,3], [4,5], [3,4]];
const F_Major = [[5,1], [4,3], [3,2]];

// C
addChorusBar(C_Major, 65.41);
// G / F Split? Tab says G F
// Let's do 2 beats G, 2 beats F
// Manual split for drop variation
// G part
addChord(b, G_Major); 
addBass(b, 49.00, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, G_Major); 
addDrum(b, 'snare');
b += 1.0;

// F part
addChord(b, F_Major);
addBass(b, 43.65, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, F_Major);
addDrum(b, 'snare');
b += 1.0;

// C
addChorusBar(C_Major, 65.41);

// G / F split
addChord(b, G_Major); 
addBass(b, 49.00, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, G_Major); 
addDrum(b, 'snare');
b += 1.0;

addChord(b, F_Major);
addBass(b, 43.65, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, F_Major);
addDrum(b, 'snare');
b += 1.0;

// === KEY CHANGE OUTRO (C#) ===
// "Gotta drink every drop"
// Shift everything up 1 semitone
// C# (x4666x) G# (466544) F# (244322)
b += 1.0; // Pause

const Cs_Major = [[4,4], [3,6], [2,6]];
const Gs_Major = [[5,4], [4,6], [3,5]];
const Fs_Major = [[5,2], [4,4], [3,3]];

addChorusBar(Cs_Major, 69.30); // C#2
// G# F# Split
addChord(b, Gs_Major); addDrum(b, 'kick'); b+=1.0;
addChord(b, Gs_Major); addDrum(b, 'snare'); b+=1.0;
addChord(b, Fs_Major); addDrum(b, 'kick'); b+=1.0;
addChord(b, Fs_Major); addDrum(b, 'snare'); b+=1.0;

// Final chord C#
addChord(b, Cs_Major);
b += 4.0;

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;
let nextDrumIdx = 0;
let nextBassIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
        nextDrumIdx = 0;
        nextBassIdx = 0;
    }

    // Schedule Melody
    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 0.4, note.target, note.type);
            triggerVisual(note);
            nextNoteIdx++;
        } else { break; }
    }
    
    // Schedule Drums
    while (nextDrumIdx < DRUMS.length) {
        const drum = DRUMS[nextDrumIdx];
        if (drum.beat <= currentBeat + 0.1) {
            const playTime = startTime + (drum.beat * (60 / CONFIG.BPM));
            if(drum.type === 'kick') AudioEngine.playKick(playTime);
            if(drum.type === 'snare') AudioEngine.playSnare(playTime, 'snare');
            if(drum.type === 'hat') AudioEngine.playHat(playTime, false);
            nextDrumIdx++;
        } else { break; }
    }
    
    // Schedule Bass
    while (nextBassIdx < BASS.length) {
        const bass = BASS[nextBassIdx];
        if (bass.beat <= currentBeat + 0.1) {
            const playTime = startTime + (bass.beat * (60 / CONFIG.BPM));
            AudioEngine.playBass(bass.freq, playTime, bass.dur * (60/CONFIG.BPM));
            nextBassIdx++;
        } else { break; }
    }

    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
let kickPulse = 0;
const activeNotes = [];
const bubbles = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function visualKick() {
    kickPulse = 1.0;
    // Spawn bubbles on kick
    for(let i=0; i<5; i++) {
        bubbles.push({
            x: Math.random() * w,
            y: h + 50,
            vy: 2 + Math.random() * 5,
            size: 5 + Math.random() * 20,
            color: Math.random() > 0.5 ? '#00f0ff' : '#ccff00'
        });
    }
}

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 
    
    // Fizz Bubbles
    for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
        ctx.fillStyle = b.color;
        ctx.fill();
        b.y -= b.vy;
        if (b.y < -50) bubbles.splice(i, 1);
    }
    
    // Shake screen on kick
    const shake = kickPulse * 5;
    const dx = (Math.random() - 0.5) * shake;
    const dy = (Math.random() - 0.5) * shake;
    
    ctx.save();
    ctx.translate(dx, dy);

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#ff0055';
    ctx.font = "16px 'Varela Round'";
    ctx.fillStyle = '#00f0ff';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = `rgba(0, 240, 255, ${0.5 + kickPulse*0.5})`;
    ctx.lineWidth = 4 + kickPulse * 4;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 180; 
    
    ctx.font = "20px 'Modak'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ccff00'; 
            let txt = note.fret;
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14 + kickPulse*2, 0, Math.PI*2);
            ctx.fillStyle = '#ffecf2';
            ctx.fill();
            ctx.strokeStyle = '#ff0055'; 
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.fillStyle = '#2d3436'; 
            ctx.fillText(txt, x - 6, y + 6);
        }
    });

    // Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 80);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 0, 85, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.08;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }
    
    ctx.restore();
    
    // Decay Kick
    kickPulse *= 0.9;

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.filter.frequency.setTargetAtTime(200 + ((1-y) * 19800), AudioEngine.ctx.currentTime, 0.1);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 12
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ALONE // SUPER ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Courier+New:wght@700&display=swap');

    :root {
        --bg: #050505;
        --white: #ffffff;
        --pink: #ff00ff;
        --cyan: #00ffff;
        --grid: #1a1a1a;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Fredoka One', cursive;
        color: var(--white);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(5, 5, 5, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 6rem;
        margin: 0;
        color: var(--white);
        text-shadow: 5px 5px 0px var(--pink), -5px -5px 0px var(--cyan);
        letter-spacing: 5px;
        text-align: center;
        line-height: 0.9;
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.5rem;
        color: var(--cyan);
        text-shadow: 0 0 10px var(--cyan);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 30px;
        left: 30px;
        font-family: 'Courier New', monospace;
        font-size: 16px;
        pointer-events: none;
        z-index: 5;
        color: var(--white);
        text-shadow: 0 0 5px var(--white);
    }
    
    .mello-head {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        width: 200px; height: 200px;
        border: 10px solid white;
        border-radius: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0.1;
        z-index: 0;
    }
    .eyes {
        display: flex; gap: 40px;
        font-size: 80px;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>ALONE<br><span style="font-size: 2rem; color: var(--cyan);">SUPER ENGINE</span></h1>
    <p>[ CLICK TO DROP ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = FILTER // SPACE = PAUSE</p>
</div>

<div id="hud">
    BPM: 142<br>
    DSP: SUPERSAW + SIDECHAIN
</div>

<div class="mello-head">
    <div class="eyes">X X</div>
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * MARSHMELLO SUPER ENGINE
 * Full Production Simulation
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 142, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    filter: null,
    comp: null, // Sidechain compressor
    drumBus: null,
    synthBus: null,
    bassBus: null,
    
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.6; // Headroom

        // Global Filter (Mouse Y Control)
        AudioEngine.filter = AudioEngine.ctx.createBiquadFilter();
        AudioEngine.filter.type = 'lowpass';
        AudioEngine.filter.frequency.value = 20000;
        AudioEngine.filter.Q.value = 1.0;

        // Busses
        AudioEngine.drumBus = AudioEngine.ctx.createGain();
        AudioEngine.synthBus = AudioEngine.ctx.createGain();
        AudioEngine.bassBus = AudioEngine.ctx.createGain();

        // Sidechain Logic (Volume ducking on synth/bass when kick hits)
        // We simulate this manually in the sequencer rather than complex routing

        // Master Chain
        AudioEngine.drumBus.connect(AudioEngine.master);
        AudioEngine.synthBus.connect(AudioEngine.filter);
        AudioEngine.bassBus.connect(AudioEngine.filter);
        AudioEngine.filter.connect(AudioEngine.master);
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        
        // Add some Reverb to synth bus
        const verb = AudioEngine.ctx.createConvolver();
        verb.buffer = await AudioEngine.createImpulse(2.0, 2.0);
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.3;
        AudioEngine.synthBus.connect(verbMix);
        verbMix.connect(verb);
        verb.connect(AudioEngine.master);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = length - i;
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // --- INSTRUMENTS ---

    playKick: (time) => {
        const t = time;
        const osc = AudioEngine.ctx.createOscillator();
        const gain = AudioEngine.ctx.createGain();
        
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
        
        gain.gain.setValueAtTime(1.0, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        
        osc.connect(gain);
        gain.connect(AudioEngine.drumBus);
        
        osc.start(t);
        osc.stop(t + 0.5);

        // Trigger Sidechain Ducking
        AudioEngine.synthBus.gain.cancelScheduledValues(t);
        AudioEngine.synthBus.gain.setValueAtTime(0.2, t); // Duck
        AudioEngine.synthBus.gain.linearRampToValueAtTime(1.0, t + 0.1); // Return
        
        AudioEngine.bassBus.gain.cancelScheduledValues(t);
        AudioEngine.bassBus.gain.setValueAtTime(0.0, t); // Hard duck bass
        AudioEngine.bassBus.gain.linearRampToValueAtTime(0.8, t + 0.15);
        
        visualKick();
    },

    playSnare: (time) => {
        const t = time;
        // Noise
        const bufSize = AudioEngine.ctx.sampleRate * 0.2;
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = AudioEngine.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 1000;
        
        const noiseEnv = AudioEngine.ctx.createGain();
        noiseEnv.gain.setValueAtTime(0.7, t);
        noiseEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
        
        // Tone
        const osc = AudioEngine.ctx.createOscillator();
        osc.frequency.setValueAtTime(200, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
        const oscEnv = AudioEngine.ctx.createGain();
        oscEnv.gain.setValueAtTime(0.5, t);
        oscEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseEnv);
        noiseEnv.connect(AudioEngine.drumBus);
        
        osc.connect(oscEnv);
        oscEnv.connect(AudioEngine.drumBus);
        
        noise.start(t);
        osc.start(t);
    },

    playHat: (time, open = false) => {
        const t = time;
        const bufSize = AudioEngine.ctx.sampleRate * (open ? 0.3 : 0.05);
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = AudioEngine.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 8000;
        
        const env = AudioEngine.ctx.createGain();
        env.gain.setValueAtTime(open ? 0.4 : 0.2, t);
        env.gain.exponentialRampToValueAtTime(0.001, t + (open ? 0.2 : 0.05));
        
        noise.connect(noiseFilter);
        noiseFilter.connect(env);
        env.connect(AudioEngine.drumBus);
        
        noise.start(t);
    },

    playBass: (freq, time, duration) => {
        const t = time;
        const osc = AudioEngine.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(100, t);
        filter.frequency.linearRampToValueAtTime(600, t + 0.05); // Pluck
        filter.frequency.linearRampToValueAtTime(100, t + duration);
        
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.8, t + 0.02);
        amp.gain.setValueAtTime(0.8, t + duration - 0.05);
        amp.gain.linearRampToValueAtTime(0, t + duration);
        
        osc.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.bassBus);
        
        osc.start(t);
        osc.stop(t + duration);
    },

    // SuperSaw Pluck (Melody)
    playString: (stringIdx, fret, time, duration = 0.5, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        // SuperSaw: 3 Oscillators
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        const osc3 = AudioEngine.ctx.createOscillator();
        
        osc1.type = 'sawtooth';
        osc2.type = 'sawtooth'; 
        osc3.type = 'sawtooth';
        
        osc1.frequency.value = freq;
        osc2.frequency.value = freq;
        osc3.frequency.value = freq;
        
        osc2.detune.value = 15; // Wide
        osc3.detune.value = -15; // Wide

        // Filter (Bright Pluck)
        const nFilter = AudioEngine.ctx.createBiquadFilter();
        nFilter.type = 'lowpass';
        nFilter.frequency.setValueAtTime(8000, t);
        nFilter.frequency.exponentialRampToValueAtTime(400, t + 0.3); // Short decay
        nFilter.Q.value = 2;

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.4, t + 0.005); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix
        osc1.connect(nFilter);
        osc2.connect(nFilter);
        osc3.connect(nFilter);
        nFilter.connect(amp);
        amp.connect(AudioEngine.synthBus);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
        osc3.start(t); osc3.stop(t + duration);
    },

    setFilter: (val) => {
        if(AudioEngine.filter) {
            const freq = 50 + (val * 19950);
            AudioEngine.filter.frequency.setTargetAtTime(freq, AudioEngine.ctx.currentTime, 0.1);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
const DRUMS = [];
const BASS = [];

function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}
function addDrum(beat, type) { // kick, snare, hat, hat_open
    DRUMS.push({ beat, type });
}
function addBass(beat, freq, dur) {
    BASS.push({ beat, freq, dur });
}

// -- BUILD THE SONG --
let b = 0.0;
const E = 0.5; // 8th note
const S = 0.25; // 16th note

// === INTRO (Build Up) ===
// Simple Melody Arpeggios
// No Drums yet, just filter sweep logic (manual via mouse usually, but code handles audio)

// G-3 3 3 3/5 5 5 5 5/7...
function addIntro() {
    // G chord
    for(let i=0; i<3; i++) { addNote(b, 5, 3); b+=E; addNote(b, 3, 0); b+=E; }
    addNote(b, 5, 3, 'slide', 5); b+=E; addNote(b, 3, 0); b+=E;
    
    // A chord
    for(let i=0; i<3; i++) { addNote(b, 5, 5); b+=E; addNote(b, 3, 4); b+=E; }
    addNote(b, 5, 5, 'slide', 7); b+=E; addNote(b, 3, 4); b+=E; 
    
    // B chord
    for(let i=0; i<3; i++) { addNote(b, 5, 7); b+=E; addNote(b, 4, 5); b+=E; }
    addNote(b, 5, 7); b+=E; addNote(b, 4, 4); b+=E;
    
    // Ending lick
    addNote(b, 4, 5); b+=E; addNote(b, 3, 4); b+=E;
    addNote(b, 4, 5); b+=E; addNote(b, 3, 4); b+=E;
    addNote(b, 4, 5); b+=E; addNote(b, 3, 4); b+=E;
    // Drum Roll build up
    addDrum(b, 'snare'); addDrum(b+S, 'snare'); addDrum(b+E, 'snare'); addDrum(b+E+S, 'snare');
    addNote(b, 4, 4); b+=E; addNote(b, 3, 2); b+=E;
}

addIntro();

// === DROP 1 ===
// Full Drums + Bass + Melody
// Kick on every beat (4 on the floor)
// Snare on 2 and 4
// Hats on off-beats

function addDropBar(bassNote) {
    const start = b;
    // Drums
    addDrum(start, 'kick'); addDrum(start+E, 'hat');
    addDrum(start+1.0, 'kick'); addDrum(start+1.0, 'snare'); addDrum(start+1.0+E, 'hat');
    addDrum(start+2.0, 'kick'); addDrum(start+2.0+E, 'hat');
    addDrum(start+3.0, 'kick'); addDrum(start+3.0, 'snare'); addDrum(start+3.0+E, 'hat_open');
    
    // Bass (Sidechained, playing offbeat pulses)
    // & 2 & 4
    // Or simple root notes? Let's do offbeat pulse.
    addBass(start+E, bassNote, E);
    addBass(start+1.0+E, bassNote, E);
    addBass(start+2.0+E, bassNote, E);
    addBass(start+3.0+E, bassNote, E);
}

// Phrase 1 Melody (G chord)
// Melody: E-2 5 0-2-0~
addDropBar(98.00); // G2 bass
addNote(b, 0, 2); b+=0.75;
addNote(b, 0, 5); b+=0.25;
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 0); b+=1.0; // ~
addNote(b, 1, 3); b+=0.5;
addNote(b, 1, 3); b+=0.5;

// Phrase 2 (D chord - 73.42 Hz)
addDropBar(73.42);
addNote(b, 0, 3); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 3); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 1, 3); b+=1.0;

// Phrase 3 (Bm chord - 61.74 Hz)
addDropBar(61.74);
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 1, 3); b+=0.5;
addNote(b, 1, 3); b+=0.5;
addNote(b, 2, 0); b+=0.5;
addNote(b, 4, 2); b+=1.5;

// Phrase 4 (C? No it loops to start usually or A)
// e-5 0-2-0~
addDropBar(110.00); // A2
addNote(b, 0, 5); b+=0.5;
addNote(b, 0, 0); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 0); b+=1.0;
addNote(b, 2, 0); b+=0.5;
addNote(b, 4, 2); b+=1.0;

// === BREAKDOWN ===
// Wrist Thump section -> Simulated with Kick + Rim
// e-3-0-2-0 ...
// No bass, just melody + percussion
function addPercBeat() {
    addDrum(b, 'kick');
    addDrum(b+1.0, 'hat'); // Simulating click
    addDrum(b+2.0, 'kick');
    addDrum(b+3.0, 'hat');
}

addPercBeat();
addNote(b, 0, 3); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 0); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 2); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 0); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 0); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 2); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 0); addNote(b, 1, 3); b+=1.0; // Rest

addPercBeat();
addNote(b, 0, 3); addNote(b, 1, 3); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 3); b+=0.5;
addNote(b, 0, 2); b+=0.5;
addNote(b, 0, 3, 'slide', 5); b+=0.5; 
addNote(b, 0, 3); b+=0.5;
addNote(b, 0, 0); b+=0.5;

// === DROP 2 (FULL POWER) ===
// Repeat Drop Logic 2x
for(let k=0; k<2; k++) {
    addDropBar(98.00);
    addNote(b, 0, 2); b+=0.75;
    addNote(b, 0, 5); b+=0.25;
    addNote(b, 0, 0); b+=0.5;
    addNote(b, 0, 2); b+=0.5;
    addNote(b, 0, 0); b+=1.0;
    addNote(b, 1, 3); b+=0.5;
    addNote(b, 1, 3); b+=0.5;

    addDropBar(73.42);
    addNote(b, 0, 3); b+=0.5;
    addNote(b, 0, 2); b+=0.5;
    addNote(b, 0, 3); b+=0.5;
    addNote(b, 0, 2); b+=0.5;
    addNote(b, 0, 0); b+=0.5;
    addNote(b, 0, 2); b+=0.5;
    addNote(b, 1, 3); b+=1.0; 

    addDropBar(61.74);
    addNote(b, 0, 0); b+=0.5;
    addNote(b, 0, 2); b+=0.5;
    addNote(b, 1, 3); b+=0.5;
    addNote(b, 1, 3); b+=0.5;
    addNote(b, 2, 0); b+=0.5;
    addNote(b, 4, 2); b+=1.5;

    addDropBar(110.00);
    addNote(b, 0, 5); b+=0.5;
    addNote(b, 0, 0); b+=0.5;
    addNote(b, 0, 2); b+=0.5;
    addNote(b, 0, 0); b+=1.0;
    addNote(b, 2, 0); b+=0.5;
    addNote(b, 4, 2); b+=1.0;
}

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;
let nextDrumIdx = 0;
let nextBassIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
        nextDrumIdx = 0;
        nextBassIdx = 0;
    }

    // Schedule Melody
    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 0.4, note.target, note.type);
            triggerVisual(note);
            nextNoteIdx++;
        } else { break; }
    }
    
    // Schedule Drums
    while (nextDrumIdx < DRUMS.length) {
        const drum = DRUMS[nextDrumIdx];
        if (drum.beat <= currentBeat + 0.1) {
            const playTime = startTime + (drum.beat * (60 / CONFIG.BPM));
            if(drum.type === 'kick') AudioEngine.playKick(playTime);
            if(drum.type === 'snare') AudioEngine.playSnare(playTime);
            if(drum.type === 'hat') AudioEngine.playHat(playTime, false);
            if(drum.type === 'hat_open') AudioEngine.playHat(playTime, true);
            nextDrumIdx++;
        } else { break; }
    }
    
    // Schedule Bass
    while (nextBassIdx < BASS.length) {
        const bass = BASS[nextBassIdx];
        if (bass.beat <= currentBeat + 0.1) {
            const playTime = startTime + (bass.beat * (60 / CONFIG.BPM));
            AudioEngine.playBass(bass.freq, playTime, bass.dur * (60/CONFIG.BPM));
            nextBassIdx++;
        } else { break; }
    }

    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
let kickPulse = 0;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function visualKick() {
    kickPulse = 1.0;
}

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 
    
    // Shake screen on kick
    const shake = kickPulse * 10;
    const dx = (Math.random() - 0.5) * shake;
    const dy = (Math.random() - 0.5) * shake;
    
    ctx.save();
    ctx.translate(dx, dy);

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333';
    ctx.font = "16px 'Courier New'";
    ctx.fillStyle = '#00ffff';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = `rgba(255, 105, 180, ${0.5 + kickPulse*0.5})`;
    ctx.lineWidth = 4 + kickPulse * 4;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 180; 
    
    ctx.font = "20px 'Fredoka One'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ff69b4'; 
            let txt = note.fret;
            if(note.target) txt += '/';
            if(note.type === 'x') txt = 'X';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14 + kickPulse*2, 0, Math.PI*2);
            ctx.fillStyle = '#111';
            ctx.fill();
            ctx.strokeStyle = '#ff69b4'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#fff'; 
            ctx.fillText(txt, x - 6, y + 6);
        }
    });

    // Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 80);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(0, 255, 255, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.08;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }
    
    ctx.restore();
    
    // Decay Kick
    kickPulse *= 0.9;

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setFilter(1 - y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 13
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MESSAGE IN A BOTTLE // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Share+Tech+Mono&display=swap');

    :root {
        --bg: #051010;
        --neon: #00ffaa;
        --hot: #0088ff;
        --dim: #051a1a;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Share Tech Mono', monospace;
        color: var(--neon);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
        filter: drop-shadow(0 0 10px var(--hot));
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(5, 16, 16, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-family: 'Orbitron', sans-serif;
        font-size: 4rem;
        margin: 0;
        color: #fff;
        text-shadow: 0 0 20px var(--hot), 0 0 40px var(--neon);
        letter-spacing: 5px;
        font-style: italic;
    }

    p {
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.2rem;
        color: var(--hot);
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: #fff;
        text-shadow: 0 0 5px #fff;
    }

    /* Tube glow animation */
    @keyframes pulse {
        0% { opacity: 0.8; }
        50% { opacity: 1; text-shadow: 0 0 30px var(--hot); }
        100% { opacity: 0.8; }
    }
    .tube-glow { animation: pulse 2s infinite; }
</style>
</head>
<body>

<div id="overlay">
    <h1 class="tube-glow">THE POLICE</h1>
    <p>[ CLICK TO SEND SOS ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = CHORUS/FLANGE // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: CHORUS CLEAN<br>
    BPM: 150
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * MESSAGE IN A BOTTLE ENGINE
 * Chorus Physics + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 150, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    drive: null,
    driveGain: null,
    reverb: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.4;

        // DISTORTION CHAIN (Clean Crunch)
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(50); // Low Gain
        AudioEngine.drive.oversample = '4x';
        
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 0.6; 

        // Reverb (Short Room)
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(1.0, 3.0);
        
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.15;

        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(verbMix);
        verbMix.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playString: (stringIdx, fret, time, duration = 1.0, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Andy Summers Tone: Bright + Chorus
        osc1.type = 'sawtooth'; 
        osc2.type = 'sine'; // Add body
        
        // Chorus Effect (Detune)
        // Mouse Y controls this via setDistortion (repurposed for Chorus depth)
        const detuneAmount = AudioEngine.driveGain.gain.value * 15; 
        osc2.detune.value = detuneAmount; 
        
        // Pitch Logic
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter (Bright but not harsh)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 4000; 
        filter.Q.value = 0.5;

        // Envelope (Plucky)
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.7, t + 0.01); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Palm Mute Logic
        if(bendType === 'pm') {
            amp.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            filter.frequency.value = 800;
        }

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setDistortion: (val) => {
        // Map 0-1 to Gain (Chorus Depth/Drive)
        // 0.6 to 1.2
        if(AudioEngine.driveGain) {
            AudioEngine.driveGain.gain.setTargetAtTime(0.6 + (val * 0.6), AudioEngine.ctx.currentTime, 0.1);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null, bend = null) {
    TAB.push({ beat, string, fret, type, target, bend });
}
function addChord(beat, notes, type='pluck') {
    notes.forEach(n => addNote(beat, n[0], n[1], type));
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// === MAIN RIFF (C#add9 -> Aadd9 -> Badd9 -> F#add9) ===
// Pattern: Root - 5th - 9th (The Police Arpeggio)
// 8th notes
// Bar 1: C# (A4 D6 G8) -> A (E5 A7 D9 - wait, tab says A Open A-0 D-2 G-4? No tab says:
// C#add9: A-4 D-6 G-8
// Aadd9: A-0 D-2 G-4
// Badd9: A-2 D-4 G-6
// F#add9: E-2 A-4 D-6/7 slide

function addMainRiff(startBeat) {
    let t = startBeat;
    
    // C#add9 (A-4 D-6 G-8)
    addNote(t, 4, 4); t += E; // A-4
    addNote(t, 3, 6); t += E; // D-6
    addNote(t, 2, 8); t += E; // G-8
    
    // Aadd9 (A-0 D-2 G-4)
    addNote(t, 4, 0); t += E;
    addNote(t, 3, 2); t += E;
    addNote(t, 2, 4); t += E;
    
    // Badd9 (A-2 D-4 G-6)
    addNote(t, 4, 2); t += E;
    addNote(t, 3, 4); t += E;
    addNote(t, 2, 6); t += E;
    
    // F#add9 (E-2 A-4 D-6 slide 7)
    addNote(t, 5, 2); t += E;
    addNote(t, 4, 4); t += E;
    addNote(t, 3, 6, 'slide', 7); t += E; // Slide to 7
}

// Intro x2 (Tab says x10, let's do 4 for brevity then verse)
for(let i=0; i<4; i++) {
    addMainRiff(b);
    b += 6.0; // Each riff is 12 eighth notes? 
    // Wait, the riff is:
    // 1 & 2 & 3 & | 1 & 2 & 3 & | 1 & 2 & 3 & | 1 & 2 & 3 &
    // C# (3 notes) | A (3 notes) | B (3 notes) | F# (3 notes) = 12 notes = 6 beats?
    // Time signature is 4/4 but the phrasing is polymetric/syncopated.
    // 1.5 beats per chord group?
    // Let's check logic:
    // C#: 0, 0.5, 1.0
    // A: 1.5, 2.0, 2.5
    // B: 3.0, 3.5, 4.0
    // F#: 4.5, 5.0, 5.5
    // Total 6.0 beats.
    // Yes.
}

// === VERSE 1 ===
// "Just a castaway..." (Riff continues x10 total in song)
// Let's do 4 more
for(let i=0; i<4; i++) {
    addMainRiff(b);
    b += 6.0;
}

// === CHORUS (SOS) ===
// "I'll send an SOS to the world"
// A5 D5 F#m F#m/E ?
// Tab: 
// E|------------------------------||
// B|-----------------------7---9-o||
// G|-6--6--6--6--6--6--6---7---9--||
// D|-7--7--7--7--7--7--7---7---9--||
// A|-7--7--7--7--7--7--7---5---7-o||
// E|-5--5--5--5--5--5--5----------||
// PM A5 (577xxx) then D5 (x577xx) then E5 (x799xx)
// Rhythm: 8th notes PM on A5 (7 times), then Half note D5, Quarter note E5?
// Let's follow tab:
// A5 (E-5 A-7 D-7 G-6)
// 7 hits PM
for(let k=0; k<2; k++) { // x2
    for(let i=0; i<7; i++) {
        addChord(b, [[5,5], [4,7], [3,7], [2,6]], 'pm');
        b += E;
    }
    // D5 (A-5 D-7 G-7 B-7)
    addChord(b, [[4,5], [3,7], [2,7], [1,7]]); 
    b += 2.0; // Half
    // E5 (A-7 D-9 G-9 B-9)
    addChord(b, [[4,7], [3,9], [2,9], [1,9]]);
    b += 1.0; // Quarter
    b += 1.0; // Rest
}

// === VERSE 2 ===
// "I hope that someone gets my..."
// Tab: F#m (244222) PM x 8?
// Tab:
// G|-2--2...
// D|-4--4...
// A|-4--4...
// E|-2--2...
// This is F#m. 16 hits?
// "I hope that someone gets my" x3
for(let k=0; k<3; k++) {
    for(let i=0; i<16; i++) {
        addChord(b, [[5,2], [4,4], [3,4], [2,2]], 'pm');
        b += E;
    }
}

// "Message in a bottle"
// C#m A (x6)
// Tab:
// e|-4----5----4----5...
// B|-5----5----5----5...
// G|-6----6----6----6...
// D|-6----7----6----7...
// A|-4----7----4----7...
// E|------5---------5...
// Chords: C#m (x46654) -> A (577655)
// Half notes
for(let i=0; i<3; i++) {
    addChord(b, [[4,4], [3,6], [2,6], [1,5], [0,4]]); // C#m
    b += 2.0;
    addChord(b, [[5,5], [4,7], [3,7], [2,6], [1,5]]); // A
    b += 2.0;
}
// End on F#m
addChord(b, [[5,2], [4,4], [3,4], [2,2], [1,2], [0,2]]); 
b += 4.0;

// === OUTRO ===
// "Sending out an SOS"
// Main Riff fade out
// Play 4 times
for(let i=0; i<4; i++) {
    addMainRiff(b);
    b += 6.0;
}


// Loop Logic
const LOOP_LENGTH = b + 4;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 1.5, note.target, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#444';
    ctx.font = "16px 'Share Tech Mono'";
    ctx.fillStyle = '#00ffaa';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#0088ff';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 150; // Fast scroll
    
    ctx.font = "20px 'Orbitron'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#00ffaa'; 
            let txt = note.fret;
            if(note.bend) txt += '*';
            if(note.target) txt += '/';
            if(note.bend === 'pm') txt = 'x';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#051010';
            ctx.fill();
            ctx.strokeStyle = '#00ffaa'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#fff'; 
            ctx.fillText(txt, x - 10, y + 2);
        }
    });

    // Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 20 + ((1 - n.life) * 60);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(0, 136, 255, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.05;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setDistortion(1 - y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 14
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PURPLE HAZE // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Share+Tech+Mono&display=swap');

    :root {
        --bg: #1a0526; /* Deep Purple */
        --neon: #b026ff; /* Bright Purple */
        --haze: #800080;
        --smoke: #dcd0ff;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Share Tech Mono', monospace;
        color: var(--smoke);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
        filter: drop-shadow(0 0 15px var(--neon));
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(26, 5, 38, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-family: 'Creepster', cursive;
        font-size: 6rem;
        margin: 0;
        color: var(--neon);
        text-shadow: 4px 4px 0px #000;
        letter-spacing: 5px;
        transform: rotate(-2deg);
    }

    p {
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.2rem;
        color: var(--smoke);
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--neon);
        text-shadow: 0 0 5px var(--neon);
    }

    /* Haze animation */
    @keyframes haze {
        0% { box-shadow: inset 0 0 50px var(--bg); }
        50% { box-shadow: inset 0 0 150px var(--neon); }
        100% { box-shadow: inset 0 0 50px var(--bg); }
    }
    body::after {
        content: '';
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        animation: haze 4s infinite;
        z-index: 2;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>PURPLE HAZE</h1>
    <p>[ CLICK TO KISS THE SKY ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = FUZZ AMOUNT // SPACE = PAUSE</p>
</div>

<div id="hud">
    FX: FUZZ FACE DISTORTION<br>
    BPM: 124
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * PURPLE HAZE ENGINE
 * Fuzz Physics + Hendrix Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 124, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    drive: null,
    driveGain: null,
    reverb: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.35;

        // FUZZ CHAIN (High Gain Clipping)
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(800); // Extreme Gain
        AudioEngine.drive.oversample = '4x';
        
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 0.8; 

        // Psychedelic Reverb (Large Hall)
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(2.0, 2.5);
        
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.3;

        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(verbMix);
        verbMix.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playString: (stringIdx, fret, time, duration = 1.0, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Hendrix Fuzz Tone: Square dominant + Sawtooth
        osc1.type = 'square'; 
        osc2.type = 'sawtooth';
        osc2.detune.value = 10; // Phasing effect
        
        // Pitch Logic
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
        } else if (bendType) {
            let interval = 0;
            if(bendType.includes('b')) interval = 2; // Whole step default
            if(bendType.includes('7b')) interval = 2;
            if(bendType.includes('8b')) interval = 1; // Half step for blues usually, but lets stick to whole
            
            if(bendType.includes('pb')) { 
                // Pre-bend logic not fully implemented, treating as bend up for chaos
                targetFreq = freq * Math.pow(2, interval/12);
                osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
                osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
            } else if(bendType.includes('b')) { 
                targetFreq = freq * Math.pow(2, interval/12);
                osc1.frequency.setValueAtTime(freq, t);
                osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.3);
                osc2.frequency.setValueAtTime(freq, t);
                osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.3);
            } else {
                osc1.frequency.value = freq;
                osc2.frequency.value = freq;
            }
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter (Wah-like envelope)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.Q.value = 1.0;
        filter.frequency.setValueAtTime(800, t);
        filter.frequency.linearRampToValueAtTime(2500, t + 0.1); // Wah open

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.6, t + 0.02); 
        amp.gain.exponentialRampToValueAtTime(0.4, t + 0.1); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setDistortion: (val) => {
        if(AudioEngine.drive) {
            AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(200 + val * 800);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null, bend = null) {
    TAB.push({ beat, string, fret, type, target, bend });
}
function addChord(beat, notes, type='pluck') {
    notes.forEach(n => addNote(beat, n[0], n[1], type));
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// === INTRO (The Tritone Stabs) ===
// E|-6-----------6-----------|--6------------6------------|
// D|-------8-----------8-----|---------8------------8-----|
// Bb (E-6) and Bb (D-8). Octaves. 
// Rhythm: 1 . 2 . 3 . 4 .
// Staccato hits.

function addIntroStabs() {
    addNote(b, 5, 6); // Low E 6
    b += 1.0;
    addNote(b, 3, 8); // D 8
    b += 1.0;
    addNote(b, 5, 6); 
    b += 1.0;
    addNote(b, 3, 8); 
    b += 1.0;
}

addIntroStabs(); // Bar 1
addIntroStabs(); // Bar 2

// === INTRO SOLO (The Lick) ===
// Bar 3:
// B|----------8b~------------|
// G|-------7-----------------|
// D|---/9--------7~-------(7)|--5---------------------|
// A|-------------------------|-----5-----5/7~---------|
// E|-------------------------|--------0---------------|

// Slide into D-9
addNote(b, 3, 7, 'slide', 9); b += E;
// G-7
addNote(b, 2, 7); b += E;
// B-8 bend
addNote(b, 1, 8, 'pluck', null, 'b'); b += Q;
// D-7 vibrato
addNote(b, 3, 7, 'pluck', null, 'vib'); b += Q;

// Bar 4:
// D-5
addNote(b, 3, 5); b += E;
// A-5
addNote(b, 4, 5); b += E;
// A-5 slide 7
addNote(b, 4, 5, 'slide', 7); b += E;
// Low E-0
addNote(b, 5, 0); b += Q;

b += 0.5;

// === PART 2 OF INTRO SOLO ===
// Slide D-9, G-7, B-8b
addNote(b, 3, 7, 'slide', 9); b += E;
addNote(b, 2, 7); b += E;
addNote(b, 1, 8, 'pluck', null, 'b'); b += Q;
// D-7
addNote(b, 3, 7); b += Q;

// Bar 6: D-7 slide 5, A-5, A-5 slide 7, E-0
addNote(b, 3, 7, 'slide', 5); b += E;
addNote(b, 4, 5); b += E;
addNote(b, 4, 5, 'slide', 7); b += E;
addNote(b, 5, 0); b += E;

// Bar 7: Double stop bends
// D-5-7-7b-5
addNote(b, 3, 5); b += S;
addNote(b, 3, 7); b += S;
addNote(b, 3, 7, 'pluck', null, 'b'); b += S;
addNote(b, 3, 5); b += E;

// Bar 8:
// D-5 A-0 E-0-3~
addNote(b, 3, 5); b += E;
addNote(b, 4, 0); b += E;
addNote(b, 5, 0); b += E;
addNote(b, 5, 3, 'pluck', null, 'vib'); b += Q;

b += 1.0;

// === MAIN RIFF (The Hendrix Chord E7#9) ===
// E7#9: E-0 A-7 D-6 G-7 B-8
// G: 355433
// A: 577655
// Rhythm: E7#9 (Hit Hit Hit Hit) -> G (Hit Hit) -> A (Hit Hit Hit)

const E7s9 = [[5,0], [4,7], [3,6], [2,7], [1,8]];
const G_Barre = [[5,3], [4,5], [3,5], [2,4], [1,3]];
const A_Barre = [[5,5], [4,7], [3,7], [2,6], [1,5]];

function addMainRiff() {
    // E7#9 Phrase
    addChord(b, E7s9); b += 0.75; // Dotted 8th
    addChord(b, E7s9); b += 0.25; // 16th
    addChord(b, E7s9); b += 0.5;  // 8th
    addChord(b, E7s9); b += 0.5;
    
    // G
    addChord(b, G_Barre); b += 0.5;
    addChord(b, G_Barre); b += 0.5; // Staccato
    
    // A
    addChord(b, A_Barre); b += 0.25;
    addChord(b, A_Barre); b += 0.25;
    
    // Lick: A string 5-7-5 (hammer on pull off sim)
    addNote(b, 4, 5); b += S;
    addNote(b, 4, 7); b += S;
    addNote(b, 4, 5); b += E;
    
    // Loop
    addChord(b, E7s9); b += 0.75;
    addChord(b, E7s9); b += 0.25;
    addChord(b, E7s9); b += 0.5;
    
    // G -> A
    addChord(b, G_Barre); b += 0.5;
    addChord(b, A_Barre); b += 0.5;
    
    // Slide out on A string
    addNote(b, 4, 7, 'slide', 0); b += 1.5;
}

// Play Riff 2 times
addMainRiff();
addMainRiff();

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 1.5, note.target, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#552255';
    ctx.font = "16px 'Share Tech Mono'";
    ctx.fillStyle = '#b026ff';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#b026ff';
    ctx.lineWidth = 3;
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#b026ff';
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Notes
    const pixelsPerBeat = 130; 
    
    ctx.font = "22px 'Creepster'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#b026ff'; 
            let txt = note.fret;
            if(note.bend) txt += '~';
            if(note.target) txt += '/';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 16, 0, Math.PI*2);
            ctx.fillStyle = '#1a0526';
            ctx.fill();
            ctx.strokeStyle = '#b026ff'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#dcd0ff'; 
            ctx.fillText(txt, x - 8, y + 6);
        }
    });

    // Psychedelic Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 20 + ((1 - n.life) * 80);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(176, 38, 255, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.05;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setDistortion(1 - y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 15
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BLACK MAGIC WOMAN // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Rye&family=Share+Tech+Mono&display=swap');

    :root {
        --bg: #0f0505;
        --ink: #ffcc00; /* Gold */
        --accent: #ff3300; /* Red */
        --mystic: #8a2be2; /* Purple */
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Rye', cursive;
        color: var(--ink);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
        filter: drop-shadow(0 0 10px var(--accent));
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(15, 5, 5, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 5rem;
        margin: 0;
        color: var(--accent);
        text-shadow: 2px 2px 0px var(--ink);
        letter-spacing: 3px;
    }

    p {
        font-family: 'Share Tech Mono', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--mystic);
        text-transform: uppercase;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Share Tech Mono', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--ink);
        text-shadow: 0 0 5px var(--accent);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>SANTANA</h1>
    <p>[ CLICK TO CAST A SPELL ]</p>
    <p style="font-size: 0.8rem; color: #aaa; margin-top: 2rem;">MOUSE Y = SUSTAIN / FEEDBACK // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: LATIN LEAD (NECK PICKUP)<br>
    BPM: RUBATO / 120
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * BLACK MAGIC WOMAN ENGINE
 * Sustain Physics + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 120, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    drive: null,
    driveGain: null,
    reverb: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.4;

        // SANTANA TONE CHAIN (Smooth Sustain)
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(150); // Warm clipping
        AudioEngine.drive.oversample = '4x';
        
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 0.7; 

        // Hall Reverb
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(2.0, 2.5);
        
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.3;

        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(verbMix);
        verbMix.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            // Soft sigmoid for singing quality
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playString: (stringIdx, fret, time, duration = 2.5, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Santana Tone: Triangle (Body) + Sawtooth (Edge)
        osc1.type = 'triangle'; 
        osc2.type = 'sawtooth'; 
        
        // Pitch Logic
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
        } else if (bendType) {
            let interval = 0;
            if(bendType.includes('b')) interval = 2; // Whole step default
            if(bendType.includes('15b17')) interval = 2;
            if(bendType.includes('13b15')) interval = 2;
            if(bendType.includes('19b20')) interval = 1;
            
            if(bendType.includes('r')) { 
                // Bend and Release
                // e.g. 12b14r12
                const bentFreq = freq * Math.pow(2, interval/12);
                osc1.frequency.setValueAtTime(freq, t);
                osc1.frequency.linearRampToValueAtTime(bentFreq, t + 0.2);
                osc1.frequency.linearRampToValueAtTime(freq, t + 0.4);
                
                osc2.frequency.setValueAtTime(freq, t);
                osc2.frequency.linearRampToValueAtTime(bentFreq, t + 0.2);
                osc2.frequency.linearRampToValueAtTime(freq, t + 0.4);
            } else if(bendType.includes('b')) { 
                // Bend up and hold/vibrato
                targetFreq = freq * Math.pow(2, interval/12);
                osc1.frequency.setValueAtTime(freq, t);
                osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.3);
                osc2.frequency.setValueAtTime(freq, t);
                osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.3);
            } else {
                osc1.frequency.value = freq;
                osc2.frequency.value = freq;
            }
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }
        
        // Vibrato (Santana Shake)
        if(duration > 1.0) {
            const vib = AudioEngine.ctx.createOscillator();
            vib.frequency.value = 5; 
            const vibGain = AudioEngine.ctx.createGain();
            vibGain.gain.value = freq * 0.015; 
            vib.connect(vibGain);
            vibGain.connect(osc1.frequency);
            vibGain.connect(osc2.frequency);
            vib.start(t + 0.3); // Delay vibrato onset
            vib.stop(t+duration);
        }

        // Filter (Tone knob rolled back slightly)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1500; 
        filter.Q.value = 1.0;

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.6, t + 0.05); // Smooth attack
        amp.gain.exponentialRampToValueAtTime(0.4, t + 0.5); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.7;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.3;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setSustain: (val) => {
        if(AudioEngine.driveGain) {
            // More drive = more sustain
            AudioEngine.driveGain.gain.setTargetAtTime(0.7 + (val * 0.5), AudioEngine.ctx.currentTime, 0.1);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null, bend = null) {
    TAB.push({ beat, string, fret, type, target, bend });
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// === INTRO PHRASE 1 (The Classic Melody) ===
// D minor pentatonic/dorian feel
// B-8p6~
addNote(b, 1, 8); b+=S;
addNote(b, 1, 6); b+=Q*1.5; // ~

// G-7/9\7~
addNote(b, 2, 7, 'slide', 9); b+=E;
addNote(b, 2, 9, 'slide', 7); b+=Q;

// B-6h8p6~
addNote(b, 1, 6); b+=S;
addNote(b, 1, 8); b+=S;
addNote(b, 1, 6); b+=Q;

// B-8
addNote(b, 1, 8); b+=Q;

// Run: B-10 8 6\5~ 8 6 5/3~ 10 8 6\5~
addNote(b, 1, 10); b+=E;
addNote(b, 1, 8); b+=E;
addNote(b, 1, 6, 'slide', 5); b+=Q;

addNote(b, 1, 8); b+=E;
addNote(b, 1, 6); b+=E;
addNote(b, 1, 5, 'slide', 3); b+=Q;

addNote(b, 1, 10); b+=E;
addNote(b, 1, 8); b+=E;
addNote(b, 1, 6, 'slide', 5); b+=Q;

// B-8 6 5
addNote(b, 1, 8); b+=E;
addNote(b, 1, 6); b+=E;
addNote(b, 1, 5); b+=Q;

// === PHRASE 2 (Dm Arpeggio) ===
// E-10 B-10 G-10 D-12 A-12 E-10 (Sweep up)
// Tab shows:
// E --------10
// B ------10
// G ----10
// D --12
// A 12
// E 10
addNote(b, 5, 10); b+=S;
addNote(b, 4, 12); b+=S;
addNote(b, 3, 12); b+=S;
addNote(b, 2, 10); b+=S;
addNote(b, 1, 10); b+=S;
addNote(b, 0, 10); b+=Q;

b+=1.0;

// === PHRASE 3 (Bends) ===
// B-13b15 13 13b15 10 13b15~~~~
addNote(b, 1, 13, 'pluck', null, '13b15'); b+=Q;
addNote(b, 1, 13); b+=E;
addNote(b, 1, 13, 'pluck', null, '13b15'); b+=E;
addNote(b, 1, 10); b+=E;
addNote(b, 1, 13, 'pluck', null, '13b15'); b+=Q*2; // Hold

// B-13b15~ 13 10
addNote(b, 1, 13, 'pluck', null, '13b15'); b+=Q;
addNote(b, 0, 10); b+=E; // Tab shows high E 10 actually
addNote(b, 1, 13); b+=E;
addNote(b, 1, 10); b+=Q;

// G-12b14r12p10\9~
addNote(b, 2, 12, 'pluck', null, '12b14r'); b+=Q;
addNote(b, 2, 10); b+=S;
addNote(b, 2, 9); b+=Q;

b+=1.0;

// === PHRASE 4 ===
// B-10 13 e-12 13 12h13p12 B-13b15
addNote(b, 1, 10); b+=E;
addNote(b, 1, 13); b+=E;
addNote(b, 0, 12); b+=E;
addNote(b, 0, 13); b+=E;
addNote(b, 0, 12); b+=S;
addNote(b, 0, 13); b+=S;
addNote(b, 0, 12); b+=S;
addNote(b, 1, 13, 'pluck', null, '13b15'); b+=Q;

// B-13b15 e-10 B-13p10
addNote(b, 1, 13, 'pluck', null, '13b15'); b+=E;
addNote(b, 0, 10); b+=E;
addNote(b, 1, 13); b+=S;
addNote(b, 1, 10); b+=S;

// G-12b14r12p10h12
addNote(b, 2, 12, 'pluck', null, '12b14r'); b+=E;
addNote(b, 2, 10); b+=S;
addNote(b, 2, 12); b+=E;

b+=1.0;

// === PHRASE 5 (The Climb) ===
// B-13 e-12 13 13/15~
addNote(b, 1, 13); b+=E;
addNote(b, 0, 12); b+=E;
addNote(b, 0, 13); b+=E;
addNote(b, 0, 13, 'slide', 15); b+=Q;

// e-15b17r15p13 13~
addNote(b, 0, 15, 'pluck', null, '15b17r'); b+=E;
addNote(b, 0, 13); b+=E;
addNote(b, 0, 13); b+=Q;

// e-19b20~ \ 10
// B-15
addNote(b, 1, 15); b+=E;
addNote(b, 0, 19, 'pluck', null, '19b20'); b+=Q;
addNote(b, 0, 19, 'slide', 10); b+=Q;

// G-12b14r12p10 10h12 D-12
addNote(b, 2, 12, 'pluck', null, '12b14r'); b+=E;
addNote(b, 2, 10); b+=S;
addNote(b, 2, 10); b+=S;
addNote(b, 2, 12); b+=S;
addNote(b, 3, 12); b+=E;

b+=1.0;

// === OUTRO (The Riff) ===
// D-10h12p10 10 A-12
addNote(b, 3, 10); b+=S;
addNote(b, 3, 12); b+=S;
addNote(b, 3, 10); b+=S;
addNote(b, 3, 10); b+=E;
addNote(b, 4, 12); b+=E;

// A-12p10\8 10 8 E-10 8/10\
addNote(b, 4, 12); b+=S;
addNote(b, 4, 10); b+=S;
addNote(b, 4, 8); b+=E;
addNote(b, 4, 10); b+=E;
addNote(b, 4, 8); b+=E;
addNote(b, 5, 10); b+=E;
addNote(b, 5, 8, 'slide', 10); b+=E;
addNote(b, 5, 10, 'slide', 3); b+=Q; // Slide out

// Chord Stabs at end
// Dm chord: E-10 A-12 D-12 G-10 B-10 e-10
// Tab just shows slide down on D, G, B strings at 10/12
addNote(b, 3, 12, 'slide', 5); 
addNote(b, 2, 10, 'slide', 5);
addNote(b, 1, 10, 'slide', 5);
addNote(b, 0, 10, 'slide', 5);
b+=2.0;


const LOOP_LENGTH = b + 4;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 2.5, note.target, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#555';
    ctx.font = "16px 'Share Tech Mono'";
    ctx.fillStyle = '#ffcc00';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#ff3300';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 100; 
    
    ctx.font = "20px 'Rye'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ffcc00'; 
            let txt = note.fret;
            if(note.bend) txt += 'b';
            if(note.target) txt += '/';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#0f0505';
            ctx.fill();
            ctx.strokeStyle = '#ffcc00'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#ffcc00'; 
            ctx.fillText(txt, x - 8, y + 4);
        }
    });

    // Mystic Ripples
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 60);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(138, 43, 226, ${n.life})`;
        ctx.lineWidth = 3;
        ctx.stroke();

        n.life -= 0.02;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setSustain(1 - y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 16
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SANTERIA // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Courier+New:wght@700&display=swap');

    :root {
        --bg: #fffbe6;
        --ink: #2c3e50;
        --accent: #e67e22;
        --green: #27ae60;
        --red: #c0392b;
        --yellow: #f1c40f;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Permanent Marker', cursive;
        color: var(--ink);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(255, 251, 230, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 5rem;
        margin: 0;
        color: var(--ink);
        text-shadow: 3px 3px 0px var(--yellow);
        transform: rotate(-2deg);
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--accent);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--ink);
    }
    
    .rasta-stripe {
        height: 5px;
        width: 100%;
        position: absolute;
        bottom: 0;
        background: linear-gradient(90deg, var(--green) 33%, var(--yellow) 33%, var(--yellow) 66%, var(--red) 66%);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>SUBLIME</h1>
    <p>[ CLICK TO SKANK ]</p>
    <p style="font-size: 0.8rem; color: #7f8c8d; margin-top: 2rem;">MOUSE Y = REVERB // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: SKA CLEAN / LEAD DRIVE<br>
    BPM: 90
</div>
<div class="rasta-stripe"></div>

<canvas id="canvas"></canvas>

<script>
/**
 * SANTERIA ENGINE
 * Ska Physics + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 90, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    drive: null,
    driveGain: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.5;

        // Drive logic (Clean by default, cranked for solo)
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(0); // Start clean
        AudioEngine.drive.oversample = '4x';
        
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 1.0; 

        // Spring Reverb
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(1.5, 4.0); // Twangy spring
        
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.2;

        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 0;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            if (k === 0) {
                curve[i] = x;
            } else {
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        // Simulate spring chirp
        for (let i = 0; i < length; i++) {
            const n = length - i;
            const chirp = Math.sin(i * 0.1) * 0.5; 
            L[i] = ((Math.random() * 2 - 1) + chirp) * Math.pow(1 - i / length, decay);
            R[i] = ((Math.random() * 2 - 1) - chirp) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playString: (stringIdx, fret, time, duration = 1.0, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Ska/Reggae Tone: Bright, thin, punchy
        osc1.type = 'triangle'; // Body
        osc2.type = 'sawtooth'; // Bite
        
        // Pitch Logic
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
        } else if (bendType) {
             // Bends logic (same as before)
            let interval = 0;
            if(bendType.includes('b')) interval = bendType.includes('11b') ? 1 : 2; // Heuristic
            if(bendType.includes('half')) interval = 1;
            
            if(bendType.includes('b')) { 
                targetFreq = freq * Math.pow(2, interval/12);
                osc1.frequency.setValueAtTime(freq, t);
                osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
                osc2.frequency.setValueAtTime(freq, t);
                osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
            } else {
                osc1.frequency.value = freq;
                osc2.frequency.value = freq;
            }
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter (Bright for ska chords, Warm for solo)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        
        // If solo range (high frets/strings), create sustain
        // If rhythm (low strings/chords), make it staccato
        const isSolo = fret > 7 || bendType; 
        
        if (isSolo) {
            filter.frequency.value = 3000;
            duration = 1.5; // Sustain
        } else {
            filter.frequency.value = 5000; // Bright chords
            duration = 0.15; // Staccato (Reggae chop)
        }

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.5, t + 0.01); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Dead Note / Mute
        if (bendType === 'x') {
            filter.frequency.value = 800;
            amp.gain.setValueAtTime(0.3, t);
            amp.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
        }

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.3;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.7; // More saw for ska

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setTone: (mode) => {
        if (mode === 'solo') {
            AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(150); // Overdrive
            AudioEngine.driveGain.gain.setTargetAtTime(0.8, AudioEngine.ctx.currentTime, 0.1);
        } else {
            AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(0); // Clean
            AudioEngine.driveGain.gain.setTargetAtTime(1.0, AudioEngine.ctx.currentTime, 0.1);
        }
    },
    
    setReverb: (val) => {
        if(AudioEngine.reverbGain) AudioEngine.reverbGain.gain.setTargetAtTime(val, AudioEngine.ctx.currentTime, 0.1);
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null, bend = null) {
    TAB.push({ beat, string, fret, type, target, bend });
}
function addChord(beat, notes, type='pluck') {
    notes.forEach(n => addNote(beat, n[0], n[1], type, null, type==='x'?'x':null));
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// === INTRO ===
// Clean Tone
// E maj arpeggio stuff
// e--------------------------------------------------
// g------9---------9----------------5--------5-------
// d----9---9---------9-9--------------6--------6-6---
// a--7-------7--7--------7------6-------6----------6-
// Timing is loose, let's approximate 8th notes

// Phrase 1 (E)
addNote(b, 4, 7); b+=E; // A-7
addNote(b, 3, 9); b+=E; // D-9
addNote(b, 2, 9); b+=E; // G-9
addNote(b, 3, 9); b+=E; // D-9
addNote(b, 4, 7); b+=E; // A-7
addNote(b, 4, 7); b+=E; // A-7
addNote(b, 2, 9); b+=E; // G-9
addNote(b, 3, 9); b+=E; // D-9
// Phrase 2 (G#?)
// A-6 D-6 G-5
// d--------------6--------6-6---
// a------6-------6----------6-
// e--4------------4----------
addNote(b, 5, 4); b+=E; // E-4
addNote(b, 4, 6); b+=E; // A-6
addNote(b, 2, 5); b+=E; // G-5
addNote(b, 3, 6); b+=E; // D-6
addNote(b, 5, 4); b+=E; // E-4
addNote(b, 3, 6); b+=E; // D-6
addNote(b, 3, 6); b+=E; // D-6
addNote(b, 4, 6); b+=E; // A-6

// Phrase 3 (C#m)
// e------------------------------------
// b-----------5------5-----------------
// g-----6----------4--------------8---8
// d---6---6------6-------------9----9--
// a-4-------4----------------9---------
// e------------------------7-----------
// C#m arpeggio
addNote(b, 4, 4); b+=E; // A-4
addNote(b, 3, 6); b+=E; // D-6
addNote(b, 2, 6); b+=E; // G-6
addNote(b, 3, 6); b+=E; // D-6
addNote(b, 4, 4); b+=E; // A-4
addNote(b, 1, 5); b+=E; // B-5
// B major arpeggio
addNote(b, 3, 6); b+=E; // D-6? Tab says 6 on D for next part? No wait g-4 b-5. That's B major (D#-F#-B)
addNote(b, 2, 4); b+=E; // G-4
addNote(b, 1, 5); b+=E; // B-5
// B power chord run?
// e--7--
// a--9--
// d--9--
// g--8--
addNote(b, 5, 7); b+=E; // E-7
addNote(b, 4, 9); b+=E; // A-9
addNote(b, 3, 9); b+=E; // D-9
addNote(b, 2, 8); b+=E; // G-8
addNote(b, 2, 8); b+=E; // G-8
addNote(b, 3, 9); b+=E; // D-9

b += 1.0; // Breath

// === VERSE 1 ===
// Upstrokes Reggae Style (x-x-x-x...)
// E (x7999x) -> G# (466544) -> C#m (x46654) -> B (799877)
// Pattern: Mute down, Chord up.
// & 2 & 4
const E_chord = [[4,7], [3,9], [2,9], [1,9]];
const Gs_chord = [[5,4], [4,6], [3,5], [2,4]]; // Using simplified voicing
const Csm_chord = [[4,6], [3,6], [2,5], [1,4]];
const B_chord = [[5,7], [4,9], [3,8], [2,7]];

function addReggaeBar(chord) {
    addChord(b, chord, 'x'); b+=E; // 1 (Mute)
    addChord(b, chord); b+=E;      // & (Up)
    addChord(b, chord, 'x'); b+=E; // 2 (Mute)
    addChord(b, chord); b+=E;      // & (Up)
    addChord(b, chord, 'x'); b+=E; // 3
    addChord(b, chord); b+=E;      // &
    addChord(b, chord, 'x'); b+=E; // 4
    addChord(b, chord); b+=E;      // &
}

// Verse x2
for(let k=0; k<2; k++) {
    addReggaeBar(E_chord);
    addReggaeBar(Gs_chord);
    addReggaeBar(Csm_chord);
    addReggaeBar(B_chord);
}

// === CHORUS ===
// A -> B -> E -> C#m (with slides)
// A (577655) -> B (799877)
// Riff: A... B... E walkdown
// Tab:
// e--5----7-----------------4/5----7
// b---5----7---------------5---5-----7
// g----6/---8----9---8----6-----6/----8
// d-------------9---8----6
function addChorusRiff() {
    // A (sweep)
    addNote(b, 0, 5); b+=S;
    addNote(b, 1, 5); b+=S;
    addNote(b, 2, 6, 'slide', 8); b+=E; // Slide up
    
    // B (sweep)
    addNote(b, 0, 7); b+=S;
    addNote(b, 1, 7); b+=S;
    addNote(b, 2, 8); b+=E; 
    
    // Walkdown (E -> D# -> C#m -> B)
    // g-9 d-9 (E)
    // g-8 d-8 (Eb)
    // g-6 d-6 (C#m)
    addNote(b, 2, 9); addNote(b, 3, 9); b+=E;
    addNote(b, 2, 8); addNote(b, 3, 8); b+=E;
    addNote(b, 2, 6); addNote(b, 3, 6); b+=E;
    
    // A fill (4/5 slide)
    addNote(b, 0, 4, 'slide', 5); b+=S;
    addNote(b, 1, 5); b+=S;
    addNote(b, 2, 6); b+=E;
}

addChorusRiff();
addChorusRiff();

// === SOLO ===
// Drive ON
addNote(b, 5, 0, 'switch_drive'); // Fake note to trigger tone switch logic if we had it in sequencer
// Note: We'll handle tone switch in visual/scheduler

// Phrase 1
// g-------------9-11b11-9-8-8p6-8b--6 6p4-4
b += 1.0;
addNote(b, 4, 7); b+=S; // A-7 pickup
addNote(b, 4, 9, 'slide', 11); b+=S; // h11
addNote(b, 2, 9); b+=S;
addNote(b, 2, 11, 'pluck', null, 'b'); b+=S; // 11b
addNote(b, 2, 9); b+=S;
addNote(b, 2, 8); b+=S;
addNote(b, 2, 8); b+=S; // p6 sim
addNote(b, 2, 6); b+=S;
addNote(b, 2, 8, 'pluck', null, 'b'); b+=S;
addNote(b, 2, 6); b+=S;
addNote(b, 2, 6); b+=S; // p4 sim
addNote(b, 2, 4); b+=E;

// Phrase 2: Fast run
// d-4h2-2 a-4 e-2-3-4 a-4-5-6 d-4-5-6 g-5
addNote(b, 3, 4); b+=S;
addNote(b, 3, 2); b+=S;
addNote(b, 4, 4); b+=S;
addNote(b, 5, 2); b+=S;
addNote(b, 5, 3); b+=S;
addNote(b, 5, 4); b+=S;
addNote(b, 4, 4); b+=S;
addNote(b, 4, 5); b+=S;
addNote(b, 4, 6); b+=S;
addNote(b, 3, 4); b+=S;
addNote(b, 3, 5); b+=S;
addNote(b, 3, 6); b+=S;
addNote(b, 1, 5); b+=Q;

// Phrase 3: High E bends
// b-12b e-12-9 b-12-9 g-11-9 ...
b += 1.0;
addNote(b, 1, 12, 'pluck', null, 'b'); b+=S;
addNote(b, 0, 12); b+=S;
addNote(b, 0, 9); b+=S;
addNote(b, 1, 12); b+=S;
addNote(b, 1, 9); b+=S;
addNote(b, 2, 11); b+=S;
addNote(b, 2, 9); b+=S;
addNote(b, 2, 8); b+=S; // h9p8
addNote(b, 2, 9); b+=S;
addNote(b, 2, 8); b+=S;
addNote(b, 3, 9); b+=S;
addNote(b, 3, 9); b+=S;

// Phrase 4: D string run
// d-10 10 a-10h11 11 ...
addNote(b, 3, 10); b+=S;
addNote(b, 3, 10); b+=S;
addNote(b, 4, 10); b+=S;
addNote(b, 4, 11); b+=S;

// End Solo - Clean Tone
addNote(b, 5, 0, 'switch_clean'); 

// Verse x2 again
for(let k=0; k<2; k++) {
    addReggaeBar(E_chord);
    addReggaeBar(Gs_chord);
    addReggaeBar(Csm_chord);
    addReggaeBar(B_chord);
}


// Loop Logic
const LOOP_LENGTH = b + 4;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            // TONE SWITCHING LOGIC
            if(note.type === 'switch_drive') {
                AudioEngine.setTone('solo');
                nextNoteIdx++;
                continue;
            }
            if(note.type === 'switch_clean') {
                AudioEngine.setTone('clean');
                nextNoteIdx++;
                continue;
            }

            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 1.0, note.target, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#95a5a6';
    ctx.font = "16px 'Courier New'";
    ctx.fillStyle = '#2c3e50';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#e67e22';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 120; 
    
    ctx.font = "20px 'Permanent Marker'";
    TAB.forEach(note => {
        if(note.type.includes('switch')) return;

        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#27ae60'; 
            let txt = note.fret;
            if(note.bend === 'x') txt = 'x';
            else if(note.bend) txt += 'b';
            if(note.target) txt += '/';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#f1c40f';
            ctx.fill();
            ctx.strokeStyle = '#c0392b'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#2c3e50'; 
            ctx.fillText(txt, x - 10, y + 2);
        }
    });

    // Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 20 + ((1 - n.life) * 60);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(230, 126, 34, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.05;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setReverb(y * 0.5);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 17
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SMOKE ON THE WATER // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Share+Tech+Mono&display=swap');

    :root {
        --bg: #100505;
        --neon: #ffaa00;
        --hot: #ff3300;
        --dim: #2e1a1a;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Share Tech Mono', monospace;
        color: var(--neon);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
        filter: drop-shadow(0 0 10px var(--hot));
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(16, 5, 5, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-family: 'Orbitron', sans-serif;
        font-size: 4rem;
        margin: 0;
        color: #fff;
        text-shadow: 0 0 20px var(--hot), 0 0 40px var(--neon);
        letter-spacing: 5px;
        font-style: italic;
    }

    p {
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.2rem;
        color: var(--hot);
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: #fff;
        text-shadow: 0 0 5px #fff;
    }

    /* Tube glow animation */
    @keyframes pulse {
        0% { opacity: 0.8; }
        50% { opacity: 1; text-shadow: 0 0 30px var(--hot); }
        100% { opacity: 0.8; }
    }
    .tube-glow { animation: pulse 2s infinite; }
</style>
</head>
<body>

<div id="overlay">
    <h1 class="tube-glow">DEEP PURPLE</h1>
    <p>[ CLICK TO BURN ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = GAIN // SPACE = PAUSE</p>
</div>

<div id="hud">
    AMP: BRITISH STACK<br>
    BPM: 114
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * SMOKE ON THE WATER ENGINE
 * Distortion Physics + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 114, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    drive: null,
    driveGain: null,
    reverb: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.35;

        // DISTORTION CHAIN (Classic Rock Crunch)
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(150); // Moderate Gain
        AudioEngine.drive.oversample = '4x';
        
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 0.8; 

        // Stadium Reverb
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(1.5, 2.0);
        
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.2;

        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(verbMix);
        verbMix.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playString: (stringIdx, fret, time, duration = 1.0, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Classic Rock Tone: Sawtooth dominant for bite
        osc1.type = 'sawtooth'; 
        osc2.type = 'sawtooth';
        osc2.detune.value = 5; // Chorus effect for width
        
        // Pitch Logic (Bends/Slides)
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
        } else if (bendType) {
            // Handle bends
            let interval = 0;
            if(bendType.includes('full') || bendType.includes('15') || bendType.includes('13')) interval = 2; // Whole step
            if(bendType.includes('half') || bendType.includes('11.5')) interval = 1; // Half step
            
            if(bendType.includes('pb')) { // Pre-bend
                const startFreq = freq * Math.pow(2, interval/12);
                if(bendType.includes('r')) { // Release
                    osc1.frequency.setValueAtTime(startFreq, t);
                    osc1.frequency.linearRampToValueAtTime(freq, t + 0.2);
                    osc2.frequency.setValueAtTime(startFreq, t);
                    osc2.frequency.linearRampToValueAtTime(freq, t + 0.2);
                } else {
                    osc1.frequency.value = startFreq;
                    osc2.frequency.value = startFreq;
                }
            } else if(bendType.includes('b')) { // Bend up
                targetFreq = freq * Math.pow(2, interval/12);
                osc1.frequency.setValueAtTime(freq, t);
                osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.3);
                osc2.frequency.setValueAtTime(freq, t);
                osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.3);
            } else {
                osc1.frequency.value = freq;
                osc2.frequency.value = freq;
            }
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter (Cab Sim)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2800; // Warm crunch
        filter.Q.value = 0.5;

        // Envelope (Sustain)
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.6, t + 0.02); 
        amp.gain.exponentialRampToValueAtTime(0.4, t + 0.1); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Palm Mute Logic
        if(bendType === 'pm') {
            amp.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            filter.frequency.value = 600;
        }

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setDistortion: (val) => {
        if(AudioEngine.drive) {
            AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(val * 400);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null, bend = null) {
    TAB.push({ beat, string, fret, type, target, bend });
}
function addChord(beat, notes, type='pluck') {
    notes.forEach(n => addNote(beat, n[0], n[1], type));
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// === INTRO RIFF (The 0-3-5) ===
// Played on D(3) and G(2) strings in tab, but positions are D5/A5 etc.
// Tab: D|5 G|3+5?
// Actually Tab says:
// e|----------------|
// B|----------------|
// G|-----3---5------|
// D|-5---3---5----5-|
// A|-5------------5-|
// This is power chords (fourths/fifths)

// Pattern: G5 (A5/D5) -> Bb5 (D3/G3) -> C5 (D5/G5)
// Timing: 1 . 2 . 3 . 4 .
// 0(G) - 3(Bb) - 5(C)
// 0(G) - 3(Bb) - 6(Db)-5(C)
// 0(G) - 3(Bb) - 5(C) - 3(Bb) - 0(G)

function addRiff(startBeat) {
    let t = startBeat;
    // Phrase 1: 0 - 3 - 5
    addChord(t, [[4,5], [3,5]]); // G5 (A5, D5 in tab? Wait tab says D5 and A5. That's G5 chord)
    // Actually the tab says:
    // D|-5
    // A|-5
    // That is G (D string 5) and D (A string 5). That's a G5.
    // AND G string... 
    // Let's stick to the visual tab provided.
    // Hit 1: A-5, D-5. (G5 Power Chord)
    addChord(t, [[4,5], [3,5]]); 
    t += 1.0;
    
    // Hit 2: D-3, G-3. (Bb5)
    addChord(t, [[3,3], [2,3]]);
    t += 1.0;
    
    // Hit 3: D-5, G-5. (C5)
    addChord(t, [[3,5], [2,5]]);
    t += 2.0; // Rest
    
    // Phrase 2: 0 - 3 - 6 - 5
    t = startBeat + 4.0;
    addChord(t, [[4,5], [3,5]]); 
    t += 1.0;
    addChord(t, [[3,3], [2,3]]);
    t += 1.0;
    addChord(t, [[3,6], [2,6]]); // Db
    t += 0.5;
    addChord(t, [[3,5], [2,5]]); // C
    t += 1.5;

    // Phrase 3: 0 - 3 - 5 - 3 - 0
    t = startBeat + 8.0;
    addChord(t, [[4,5], [3,5]]);
    t += 1.0;
    addChord(t, [[3,3], [2,3]]);
    t += 1.0;
    addChord(t, [[3,5], [2,5]]);
    t += 1.5;
    addChord(t, [[3,3], [2,3]]);
    t += 0.5;
    addChord(t, [[4,5], [3,5]]); // End on G
}

// Sequence the Riff 4 times (Intro)
addRiff(b); b += 12;
addRiff(b); b += 12;
// Tab says x5... let's do 2 loops then verse
// Last riff has slide down
addChord(b-0.5, [[4,5], [3,5]], 'slide'); // Slide down effect

// === VERSE ===
// Palm muted G (Low E string 3) and D (A string 5)
// "We all came out to Montreux..."
// e|-----------------|
// A|---5-------5-----|
// E|-3-------3-------|
// PM 8th notes
for(let i=0; i<16; i++) {
    // E-3
    addNote(b, 5, 3, 'pluck', null, 'pm');
    b += 0.5;
    // A-5
    addNote(b, 4, 5, 'pluck', null, 'pm');
    b += 0.5;
}

// === CHORUS ===
// C5 (A3/D5) -> G5 (E3/A5, but tab says E4/A6? G#?)
// Tab: 
// D|----5-------|-------6----|
// A|-3----------|----6-------|
// This is C5 -> Eb5? (A6 is Eb).
// Smoke on the Water Chorus is C5 -> Ab5 -> G5?
// "Smooooke on the water"
// C5 (x355xx) -> G#5? No Ab is fret 4 on E string. Tab says E-4, A-6. That is Ab5.
// So C5 -> Ab5 -> G5.
// Provided tab: 
// Bar 1: A-3, D-5 (C5).
// Bar 2: E-4, A-6, D-6 (Ab5).
// Bar 3: E-3 (G5).

addChord(b, [[4,3], [3,5]]); // C5
b += 4.0;
addChord(b, [[5,4], [4,6], [3,6]]); // Ab5
b += 4.0;
addNote(b, 5, 3); // G
b += 4.0;

// === SOLO (Guitar 1) ===
// Starts approx beat 64
b += 4.0; 

// Phrase 1: G-12~~
addNote(b, 2, 12, 'pluck', null, 'vib');
b += 2.0;

// B-13pb15 (13)r13 p11
addNote(b, 1, 13, 'pluck', null, 'pb15r');
b += 1.0;
addNote(b, 1, 11);
b += 1.0;

// B-11b11.5
addNote(b, 1, 11, 'pluck', null, 'b11.5');
b += 2.0;

// G-10 G-12 B-11 B-11b13 r 11 10
addNote(b, 2, 10); b += 0.5;
addNote(b, 2, 12); b += 0.5;
addNote(b, 1, 11); b += 0.5;
addNote(b, 1, 11, 'pluck', null, 'b13'); b += 0.5;
addNote(b, 1, 11); b += 0.5;
addNote(b, 1, 10); b += 1.5;

// Phrase 2: G-12 14 12h14p12\10 12 10 8 10
addNote(b, 2, 12); b+=0.25;
addNote(b, 2, 14); b+=0.25;
addNote(b, 2, 12); b+=0.25; // h/p/slide sim
addNote(b, 2, 10); b+=0.25;
addNote(b, 2, 12); b+=0.25;
addNote(b, 2, 10); b+=0.25;
addNote(b, 2, 8); b+=0.25;
addNote(b, 2, 10); b+=2.0;

// Phrase 3: Double stops / Bends
// G-10pb12 B-8...
addNote(b, 2, 10, 'pluck', null, 'pb12'); 
addNote(b, 1, 8);
b += 4.0;

// Phrase 4: Fast run
// B-11 (11)pb13 ...
addNote(b, 1, 11); b+=0.5;
addNote(b, 1, 11, 'pluck', null, 'pb13'); b+=0.5;
addNote(b, 0, 8); // High E 8
b+=0.5;
addNote(b, 0, 11); // High E 11
b+=2.0;


// Loop Logic
const LOOP_LENGTH = b + 4;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 1.5, note.target, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#444';
    ctx.font = "16px 'Share Tech Mono'";
    ctx.fillStyle = '#ffaa00';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#ff3300';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 120;
    
    ctx.font = "20px 'Orbitron'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ffaa00'; 
            let txt = note.fret;
            if(note.bend) txt += '*';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#100505';
            ctx.fill();
            ctx.strokeStyle = '#ffaa00'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#fff'; 
            ctx.fillText(txt, x - 10, y + 2);
        }
    });

    // Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 20 + ((1 - n.life) * 60);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 51, 0, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.05;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setDistortion(1 - y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 18
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SO LONELY // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Rock+Salt&family=Share+Tech+Mono&display=swap');

    :root {
        --bg: #111;
        --ink: #eee;
        --accent: #ff0055;
        --yellow: #ffee00;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Rock Salt', cursive;
        color: var(--ink);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(17, 17, 17, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 5rem;
        margin: 0;
        color: var(--accent);
        text-shadow: 4px 4px 0px #fff;
        transform: rotate(-3deg);
    }

    p {
        font-family: 'Share Tech Mono', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--yellow);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Share Tech Mono', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--ink);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>THE POLICE</h1>
    <p>[ CLICK TO PUNK ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = DRIVE // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: PUNK DISTORTION<br>
    BPM: 150 (Driving 8ths)
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * SO LONELY CHORUS ENGINE
 * Punk Physics + Downstrokes
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 150, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    drive: null,
    driveGain: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.4;

        // Punk Distortion (Aggressive Clipping)
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(400); // High gain start
        AudioEngine.drive.oversample = '4x';
        
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 0.8; 

        // Small Room Reverb (Tight)
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(0.8, 6.0);
        
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.15;

        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 0;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playString: (stringIdx, fret, time, duration = 0.2, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Punk Tone: Bridge Pickup Sawtooth
        osc1.type = 'sawtooth'; 
        osc2.type = 'square'; // Add some hollow mids
        
        osc1.frequency.value = freq;
        osc2.frequency.value = freq;

        // Filter (Open up for aggressive strumming)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        
        // Palm mute logic
        if (bendType === 'pm') {
            filter.frequency.value = 600; // Muffled
            duration = 0.1; // Short
        } else {
            filter.frequency.value = 4000; // Open
        }

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.7, t + 0.005); // Very fast attack (Pick)
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.8;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.2;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setTone: (val) => {
        // Map 0-1 to Drive
        if(AudioEngine.drive) {
             AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(100 + val * 800);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addChord(beat, notes, type='downstroke') {
    // notes: [[string, fret], ...]
    // type can be 'pm' for palm mute
    notes.forEach((n, i) => {
        // Slight strum delay for realism
        const delay = i * 0.005; 
        TAB.push({ 
            beat: beat + (type.includes('stroke') ? delay : 0), 
            string: n[0], 
            fret: n[1], 
            type: type === 'pm' ? 'pluck' : 'pluck', 
            bend: type === 'pm' ? 'pm' : null 
        });
    });
}

// -- BUILD THE CHORUS --
// Progression: C - G - Am - F (Barre Chords)
// Rhythm: 1 & 2 & 3 & 4 & (All Downstrokes)
// 150 BPM

// Barre Shapes (E-shape and A-shape)
// C (x35553) - A string root
const C_Barre = [[4,3], [3,5], [2,5], [1,5], [0,3]]; // A string root C
// Wait, tab provided says E string root C (8th fret) or maybe open C?
// Tab provided:
// e|---3--
// B|---5--
// G|---5--
// D|---5--
// A|---3--
// E|------
// That is C major starting on A string 3rd fret. Correct.

// G (355433) - E string root
// Tab provided:
// e|---3--
// B|---3--
// G|---4--
// D|---5--
// A|---5--
// E|---3--
const G_Barre = [[5,3], [4,5], [3,5], [2,4], [1,3], [0,3]];

// Am (577555) - E string root
// Tab provided:
// e|---5--
// B|---5--
// G|---5--
// D|---7--
// A|---7--
// E|---5--
const Am_Barre = [[5,5], [4,7], [3,7], [2,5], [1,5], [0,5]];

// F (133211) - E string root
// Tab provided:
// e|---1--
// B|---1--
// G|---2--
// D|---3--
// A|---3--
// E|---1--
const F_Barre = [[5,1], [4,3], [3,3], [2,2], [1,1], [0,1]];

let b = 0.0;
const EIGHTH = 0.5;

// Pattern: 8 downstrokes per chord (1 bar)
// Andy Summers Dynamic: PM first, then open up.

function addPunkBar(chord, intensity) {
    for(let i=0; i<8; i++) {
        // First 4 hits might be PM if intensity is low
        let type = (intensity === 'low' && i < 4) ? 'pm' : 'downstroke';
        addChord(b, chord, type);
        b += EIGHTH;
    }
}

// Loop 1: Start driving, slight PM
addPunkBar(C_Barre, 'low');
addPunkBar(G_Barre, 'low');
addPunkBar(Am_Barre, 'low');
addPunkBar(F_Barre, 'low');

// Loop 2: Full Open Scream
addPunkBar(C_Barre, 'high');
addPunkBar(G_Barre, 'high');
addPunkBar(Am_Barre, 'high');
addPunkBar(F_Barre, 'high');

// Loop 3: Keep screaming
addPunkBar(C_Barre, 'high');
addPunkBar(G_Barre, 'high');
addPunkBar(Am_Barre, 'high');
addPunkBar(F_Barre, 'high');

// Loop 4: Finish strong
addPunkBar(C_Barre, 'high');
addPunkBar(G_Barre, 'high');
addPunkBar(Am_Barre, 'high');
addPunkBar(F_Barre, 'high');

// End on C
addChord(b, C_Barre, 'downstroke');
b += 4.0;

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 0.3, null, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333';
    ctx.font = "16px 'Share Tech Mono'";
    ctx.fillStyle = '#ff0055';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#ffee00';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 150; 
    
    ctx.font = "20px 'Rock Salt'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ff0055'; 
            let txt = note.fret;
            if(note.bend === 'pm') txt = 'x';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#111';
            ctx.fill();
            ctx.strokeStyle = '#ff0055'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#fff'; 
            ctx.fillText(txt, x - 10, y + 2);
        }
    });

    // Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 20 + ((1 - n.life) * 60);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 238, 0, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.08; // Fast fade for punk speed
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setTone(1 - y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 19
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TENDER SURRENDER // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Rajdhani:wght@600&display=swap');

    :root {
        --bg: #000000;
        --ink: #00ff00; /* Vai Green */
        --accent: #ff00ff; /* Vai Pink */
        --white: #ffffff;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Rajdhani', sans-serif;
        color: var(--white);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-family: 'Orbitron', sans-serif;
        font-size: 5rem;
        margin: 0;
        color: var(--ink);
        text-shadow: 0 0 20px var(--ink);
        letter-spacing: 5px;
        transform: skewX(-10deg);
    }

    p {
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--accent);
        text-transform: uppercase;
        letter-spacing: 3px;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--ink);
        text-shadow: 0 0 5px var(--ink);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>STEVE VAI</h1>
    <p>[ CLICK TO SURRENDER ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = WAH / WHAMMY // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: LIQUID LEAD + DELAY<br>
    BPM: FREE (Expressive)
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * TENDER SURRENDER ENGINE
 * High Gain Physics + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 85, // Base tempo, but phrasing is loose
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    drive: null,
    driveGain: null,
    delay: null,
    delayGain: null,
    wah: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.3;

        // LEAD TONE CHAIN:
        // Source -> Wah -> Drive -> Master -> Delay -> Dest
        
        // Wah Filter (Bandpass)
        AudioEngine.wah = AudioEngine.ctx.createBiquadFilter();
        AudioEngine.wah.type = 'bandpass';
        AudioEngine.wah.frequency.value = 1200;
        AudioEngine.wah.Q.value = 1.5;

        // Smooth High Gain Distortion
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(600); // Saturation
        AudioEngine.drive.oversample = '4x';
        
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 0.8; 

        // Stereo Delay (Ping Pong ish)
        AudioEngine.delay = AudioEngine.ctx.createDelay();
        AudioEngine.delay.delayTime.value = 0.4; // 400ms
        
        AudioEngine.delayGain = AudioEngine.ctx.createGain();
        AudioEngine.delayGain.gain.value = 0.3;
        
        const delayFeedback = AudioEngine.ctx.createGain();
        delayFeedback.gain.value = 0.4;

        // Routing
        // Guitar Input (Simulated later) -> Wah -> DriveGain -> Drive -> Master
        AudioEngine.wah.connect(AudioEngine.driveGain);
        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        
        // Delay Send
        AudioEngine.master.connect(AudioEngine.delay);
        AudioEngine.delay.connect(delayFeedback);
        delayFeedback.connect(AudioEngine.delay); // Feedback loop
        AudioEngine.delay.connect(AudioEngine.delayGain);
        AudioEngine.delayGain.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            // Sigmoid for smooth lead compression
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    playString: (stringIdx, fret, time, duration = 1.0, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Vai Tone: Sawtooth + Pulse (Harmonics)
        osc1.type = 'sawtooth'; 
        osc2.type = 'square'; 
        
        // Pitch Logic
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.2);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
            
            // Vibrato (Whammy Bar) logic
            // If bendType is 'vib' or 'whammy'
            if (bendType === 'vib') {
               const vib = AudioEngine.ctx.createOscillator();
               vib.frequency.value = 6; 
               const vibGain = AudioEngine.ctx.createGain();
               vibGain.gain.value = freq * 0.02; // Heavy vibrato
               vib.connect(vibGain);
               vibGain.connect(osc1.frequency);
               vibGain.connect(osc2.frequency);
               vib.start(t);
               vib.stop(t+duration);
            }
        }

        // Note Envelope
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.7, t + 0.01); 
        amp.gain.exponentialRampToValueAtTime(0.5, t + 0.2); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.6;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.4;

        osc1.connect(osc1Gain); osc1Gain.connect(AudioEngine.wah);
        osc2.connect(osc2Gain); osc2Gain.connect(AudioEngine.wah);
        // Connect Gain nodes to Wah, but wait, Wah is global.
        // Let's connect to amp first then Wah.
        // Osc -> Mix -> Amp -> Wah -> Drive...
        
        // Re-routing for polyphony safety (creating per-note amp, connecting to global wah)
        osc1Gain.disconnect(); osc2Gain.disconnect();
        osc1.disconnect(); osc2.disconnect();
        
        osc1.connect(osc1Gain); osc1Gain.connect(amp);
        osc2.connect(osc2Gain); osc2Gain.connect(amp);
        amp.connect(AudioEngine.wah); // Connect to global effects chain

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setEffect: (val) => {
        // Map 0-1 to Wah Frequency (Up) or Whammy Dive (Down)?
        // Let's do Wah sweep for now
        if(AudioEngine.wah) {
            const minF = 300;
            const maxF = 3000;
            AudioEngine.wah.frequency.setTargetAtTime(minF + (val * (maxF-minF)), AudioEngine.ctx.currentTime, 0.1);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null, bend = null) {
    TAB.push({ beat, string, fret, type, target, bend });
}
function addChord(beat, notes) {
    notes.forEach(n => addNote(beat, n[0], n[1]));
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// === INTRO (Octaves) ===
// Octave melody: A-7/G-9 -> ...
// 7-x-9-x-x-x (E)
// e|-----------------10-------------------------|
// B|------8--10--12------/--12--\--10--\--8-----|
// G|---9-------------7--------------------------|
// D|------5--7---9-------/--9---\--7---\--5--5--|
// A|---7----------------------------------------|
// E|--------------------------------------------|
// Rhythm: Octaves sliding.
// A-7/G-9
addNote(b, 4, 7); addNote(b, 2, 9); b += E;
// D-5/B-8
addNote(b, 3, 5); addNote(b, 1, 8); b += S;
// D-7/B-10
addNote(b, 3, 7); addNote(b, 1, 10); b += S;
// D-9/B-12
addNote(b, 3, 9); addNote(b, 1, 12); b += E;
// G-7/e-10
addNote(b, 2, 7); addNote(b, 0, 10); b += E;
// Slide up D-9/B-12 -> 12/15? Tab says /12
// Actually tab says: / 12 \ 10 \ 8
// D-9/B-12 slide 12/15?
// Let's just play the target notes for engine stability
addNote(b, 3, 9, 'slide', 12); addNote(b, 1, 12, 'slide', 15); b += E; // Slide up
addNote(b, 3, 9, 'slide', 7); addNote(b, 1, 12, 'slide', 10); b += E; // Slide down
addNote(b, 3, 7, 'slide', 5); addNote(b, 1, 10, 'slide', 8); b += Q; // Slide down

// === LICK 2 ===
// |------------5h7p5--------|
// |--8--/--10---------5-----|
// |-------------------------|
// |--5--/--7----------------|
// Octaves D-5/B-8 slide 7/10
addNote(b, 3, 5, 'slide', 7); addNote(b, 1, 8, 'slide', 10); b += Q;
// High E 5 h7 p5
addNote(b, 0, 5); b += S;
addNote(b, 0, 7); b += S;
addNote(b, 0, 5); b += S;
// B-5
addNote(b, 1, 5); b += Q;

// === LICK 3 ===
// |------5-7----------|
// |------5h7--5-------|
// |---5----------5h7--|
addNote(b, 3, 5); b += S; // D-5
addNote(b, 2, 5, 'slide', 7); addNote(b, 1, 5, 'slide', 7); b += E; // Double stop hammer?
addNote(b, 2, 5); b += E;
addNote(b, 3, 5, 'slide', 7); b += Q;

b += 1.0;

// === MAIN THEME ===
// Octaves A-5 -> /9 \7 5
// B-12 \ 10 8 10
addNote(b, 4, 5); b += E; // A-5
// Slide A-9 / B-12
addNote(b, 3, 9); addNote(b, 1, 12); b += E;
// Slide down 7/10
addNote(b, 3, 7); addNote(b, 1, 10); b += E;
// 5/8
addNote(b, 3, 5); addNote(b, 1, 8); b += E;
// 5/7 10
addNote(b, 3, 7); addNote(b, 1, 10); b += E;
// G-7/12 Slide
addNote(b, 2, 7, 'slide', 12); b += Q;
// G-9
addNote(b, 2, 9, 'pluck', null, 'vib'); b += Q*2;

// === ENDING THUNDER EFFECT ===
// Low E Rumble + Whammy Bar Dive
b += 2.0;
addNote(b, 5, 0, 'pluck', null, 'vib'); // Low E
addNote(b, 5, 0); b += S;
addNote(b, 5, 0); b += S;
addNote(b, 5, 0); b += S;
// Dive logic handled by user Mouse Y usually, but we can sim it
// Slide to -12 (octave down)
addNote(b, 5, 0, 'slide', -12); b += 4.0;


const LOOP_LENGTH = b + 4;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 2.5, note.target, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#333';
    ctx.font = "16px 'Rajdhani'";
    ctx.fillStyle = '#00ff00';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#ff00ff';
    ctx.lineWidth = 3;
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#ff00ff';
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Notes
    const pixelsPerBeat = 100; 
    
    ctx.font = "20px 'Orbitron'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#00ff00'; 
            let txt = note.fret;
            if(note.target) txt += '/';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#000';
            ctx.fill();
            ctx.strokeStyle = '#00ff00'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillText(txt, x - 6, y + 4);
        }
    });

    // Neon Ripples
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 60);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 0, 255, ${n.life})`;
        ctx.lineWidth = 3;
        ctx.stroke();

        n.life -= 0.02;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setEffect(1 - y); // Control Wah
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 20
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SODA POP // K-POP ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Modak&family=Varela+Round&display=swap');

    :root {
        --bg: #ffecf2; /* Pastel Pink */
        --bubble: #00f0ff; /* Cyan */
        --pop: #ff0055; /* Hot Pink */
        --fizz: #ccff00; /* Lime */
        --text: #2d3436;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Modak', cursive;
        color: var(--text);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(255, 236, 242, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 6rem;
        margin: 0;
        color: var(--pop);
        text-shadow: 4px 4px 0px var(--bubble);
        letter-spacing: 2px;
        text-align: center;
        line-height: 0.9;
        transform: rotate(-3deg);
    }

    p {
        font-family: 'Varela Round', sans-serif;
        font-weight: bold;
        margin-top: 20px;
        font-size: 1.5rem;
        color: var(--text);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 30px;
        left: 30px;
        font-family: 'Varela Round', sans-serif;
        font-size: 16px;
        pointer-events: none;
        z-index: 5;
        color: var(--pop);
        background: rgba(255,255,255,0.8);
        padding: 10px;
        border-radius: 20px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    
    .bubble-decoration {
        position: absolute;
        border-radius: 50%;
        background: var(--bubble);
        opacity: 0.5;
        z-index: 0;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>SODA POP<br><span style="font-size: 3rem; color: var(--fizz);">K-POP ENGINE</span></h1>
    <p>Click to Open!</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = FIZZ (FILTER) // SPACE = PAUSE</p>
</div>

<div id="hud">
    GENRE: K-POP / FUTURE BASS<br>
    BPM: 128
</div>

<!-- Decor -->
<div class="bubble-decoration" style="top:10%; left:10%; width:100px; height:100px;"></div>
<div class="bubble-decoration" style="bottom:20%; right:10%; width:150px; height:150px; background:var(--fizz);"></div>

<canvas id="canvas"></canvas>

<script>
/**
 * K-POP SODA ENGINE
 * Polished Production + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 128, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    filter: null,
    drumBus: null,
    synthBus: null,
    bassBus: null,
    
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.6; 

        // Global "Fizz" Filter (Highpass/Lowpass sweep)
        AudioEngine.filter = AudioEngine.ctx.createBiquadFilter();
        AudioEngine.filter.type = 'lowpass';
        AudioEngine.filter.frequency.value = 20000;
        AudioEngine.filter.Q.value = 1.0;

        // Busses
        AudioEngine.drumBus = AudioEngine.ctx.createGain();
        AudioEngine.synthBus = AudioEngine.ctx.createGain();
        AudioEngine.bassBus = AudioEngine.ctx.createGain();

        // Master Chain
        AudioEngine.drumBus.connect(AudioEngine.master);
        AudioEngine.synthBus.connect(AudioEngine.filter);
        AudioEngine.bassBus.connect(AudioEngine.filter);
        AudioEngine.filter.connect(AudioEngine.master);
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        
        // K-Pop Polish (Reverb)
        const verb = AudioEngine.ctx.createConvolver();
        verb.buffer = await AudioEngine.createImpulse(1.5, 2.0); // Tight, bright room
        const verbMix = AudioEngine.ctx.createGain();
        verbMix.gain.value = 0.2;
        AudioEngine.synthBus.connect(verbMix);
        verbMix.connect(verb);
        verb.connect(AudioEngine.master);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = length - i;
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // --- INSTRUMENTS ---

    playKick: (time) => {
        const t = time;
        // Punchy K-Pop Kick
        const osc = AudioEngine.ctx.createOscillator();
        const gain = AudioEngine.ctx.createGain();
        
        osc.frequency.setValueAtTime(180, t);
        osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
        
        gain.gain.setValueAtTime(1.0, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        
        osc.connect(gain);
        gain.connect(AudioEngine.drumBus);
        
        osc.start(t);
        osc.stop(t + 0.3);

        // Sidechain
        AudioEngine.synthBus.gain.cancelScheduledValues(t);
        AudioEngine.synthBus.gain.setValueAtTime(0.3, t); 
        AudioEngine.synthBus.gain.linearRampToValueAtTime(1.0, t + 0.1);
        
        AudioEngine.bassBus.gain.cancelScheduledValues(t);
        AudioEngine.bassBus.gain.setValueAtTime(0.0, t); 
        AudioEngine.bassBus.gain.linearRampToValueAtTime(0.8, t + 0.15);
        
        visualKick();
    },

    playSnare: (time, type='snap') => {
        const t = time;
        // K-Pop Snare is often a layered Snap/Clap/Snare
        
        // Noise (Crisp)
        const bufSize = AudioEngine.ctx.sampleRate * 0.1;
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = AudioEngine.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 2000; // High snap
        
        const noiseEnv = AudioEngine.ctx.createGain();
        noiseEnv.gain.setValueAtTime(0.6, t);
        noiseEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseEnv);
        noiseEnv.connect(AudioEngine.drumBus);
        noise.start(t);
        
        if (type === 'snare') {
            // Add body for snare sections
            const osc = AudioEngine.ctx.createOscillator();
            osc.frequency.setValueAtTime(250, t);
            osc.frequency.exponentialRampToValueAtTime(150, t + 0.1);
            const oscEnv = AudioEngine.ctx.createGain();
            oscEnv.gain.setValueAtTime(0.5, t);
            oscEnv.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            osc.connect(oscEnv);
            oscEnv.connect(AudioEngine.drumBus);
            osc.start(t);
        }
    },

    playHat: (time) => {
        // Trap Hi-Hat (Tight)
        const t = time;
        const bufSize = AudioEngine.ctx.sampleRate * 0.05;
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        
        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = AudioEngine.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 10000; // Sizzle
        
        const env = AudioEngine.ctx.createGain();
        env.gain.setValueAtTime(0.3, t);
        env.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(env);
        env.connect(AudioEngine.drumBus);
        
        noise.start(t);
    },

    playBass: (freq, time, duration) => {
        const t = time;
        // 808 Style Bass
        const osc = AudioEngine.ctx.createOscillator();
        osc.type = 'sine'; // Pure sub
        osc.frequency.value = freq;
        
        // Add a bit of square for texture
        const osc2 = AudioEngine.ctx.createOscillator();
        osc2.type = 'square';
        osc2.frequency.value = freq;
        
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.8, t + 0.01);
        amp.gain.setValueAtTime(0.8, t + duration - 0.05);
        amp.gain.linearRampToValueAtTime(0, t + duration);
        
        const amp2 = AudioEngine.ctx.createGain();
        amp2.gain.value = 0.2; // Lower vol for square
        
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;

        osc.connect(amp);
        osc2.connect(filter); filter.connect(amp2); amp2.connect(amp);
        
        amp.connect(AudioEngine.bassBus);
        
        osc.start(t); osc.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    // Glassy Synth Pluck (Guitar Tab Simulation)
    playString: (stringIdx, fret, time, duration = 0.5, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // K-Pop Tone: Bright, Clean, Digital
        osc1.type = 'square'; 
        osc2.type = 'sine'; 
        
        // Pitch Logic
        let targetFreq = freq;
        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.1);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Envelope (Pluck)
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.5, t + 0.005); 
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Filter (FM-ish)
        const nFilter = AudioEngine.ctx.createBiquadFilter();
        nFilter.type = 'lowpass';
        nFilter.frequency.setValueAtTime(4000, t);
        nFilter.frequency.exponentialRampToValueAtTime(500, t + 0.2); 
        nFilter.Q.value = 3; // Resonance for "Pop" sound

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.3;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.7;

        osc1.connect(osc1Gain); osc1Gain.connect(nFilter);
        osc2.connect(osc2Gain); osc2Gain.connect(nFilter);
        nFilter.connect(amp);
        amp.connect(AudioEngine.synthBus);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setFilter: (val) => {
        if(AudioEngine.filter) {
            // Fizz control
            const freq = 200 + (val * 19800);
            AudioEngine.filter.frequency.setTargetAtTime(freq, AudioEngine.ctx.currentTime, 0.1);
        }
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
const DRUMS = [];
const BASS = [];

function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}
function addChord(beat, notes) {
    notes.forEach(n => addNote(beat, n[0], n[1]));
}
function addDrum(beat, type) {
    DRUMS.push({ beat, type });
}
function addBass(beat, freq, dur) {
    BASS.push({ beat, freq, dur });
}

// -- BUILD THE SONG --
let b = 0.0;
const E = 0.5; // 8th note
const S = 0.25; // 16th note

// === INTRO ===
// C G F G F
// C (x3555x) G (355433) F (133211)
// Rhythm: Stabs / Pop feel
// [Intro] C G F C G F C G F
// e:---------
// B:---------
// G:---------
// D:---------
// A:---3-----
// E:-------3-
// Let's use power chords for the synths
function addIntro() {
    // C
    addChord(b, [[4,3], [3,5]]); b+=1.0;
    // G
    addChord(b, [[5,3], [4,5]]); b+=1.0;
    // F
    addChord(b, [[5,1], [4,3]]); b+=1.0;
    // C
    addChord(b, [[4,3], [3,5]]); b+=1.0;
    
    // Hey hey part (Drum hits)
    addDrum(b-1.0, 'snare'); // Snap
    addDrum(b-0.5, 'snare'); // Snap
}

addIntro();
addIntro(); // x2

// === VERSE 1 ===
// C G F C
// Bass pulse
// Rhythm: 1 . 2 . 3 . 4 .
// Kick on 1, 3
// Melody on Synth
b += 1.0;

function addVerseLine(rootBass) {
    // Bass 8ths
    for(let i=0; i<8; i++) {
        addBass(b + i*E, rootBass, S);
    }
    // Drums (Soft)
    addDrum(b, 'kick');
    addDrum(b+1.0, 'snare'); // snap
    addDrum(b+2.0, 'kick');
    addDrum(b+3.0, 'snare'); // snap
    // Hats
    for(let i=0; i<8; i++) addDrum(b + i*E, 'hat');
    
    b += 4.0;
}

// C (130.81 Hz - C3, let's go lower C2 65.41)
addVerseLine(65.41);
// G (49.00 Hz - G1)
addVerseLine(49.00);
// F (43.65 Hz - F1)
addVerseLine(43.65);
// C
addVerseLine(65.41);

// "Got a feeling..." (Repeat progression)
addVerseLine(65.41);
addVerseLine(49.00);
addVerseLine(43.65);
addVerseLine(65.41);

// === PRE-CHORUS (BUILD) ===
// F Am G
// Snare roll build up
// Melody chords
// F
addChord(b, [[5,1], [4,3], [3,2]]); 
addBass(b, 43.65, 2.0);
addDrum(b, 'kick'); addDrum(b+1.0, 'kick');
b += 2.0;

// Am (A-0 D-2 G-2)
addChord(b, [[4,0], [3,2], [2,2]]);
addBass(b, 55.00, 1.0); // A1
addDrum(b, 'kick'); 
b += 1.0;

// G
addChord(b, [[5,3], [4,5], [3,4]]);
addBass(b, 49.00, 1.0);
addDrum(b, 'kick');
b += 1.0;

// F again
addChord(b, [[5,1], [4,3], [3,2]]); 
addBass(b, 43.65, 2.0);
addDrum(b, 'kick'); addDrum(b+0.5, 'kick'); addDrum(b+1.0, 'kick'); addDrum(b+1.5, 'kick');
b += 2.0;

// "So refreshing... My little soda pop" (Silence/Fill)
addDrum(b, 'snare'); addDrum(b+0.25, 'snare'); addDrum(b+0.5, 'snare');
b += 2.0;

// === CHORUS (DROP) ===
// C G F
// Full K-Pop Energy
// Melody: High C-0 (E string 8th fret) G-2 (G-string 12)
// Let's play chords rhythmically
// Rhythm: 1 & (2) & 3 & (4) &

function addChorusBar(chord, bassFreq) {
    const start = b;
    // Chords (Syncopated)
    addChord(start, chord);
    addChord(start+0.75, chord);
    addChord(start+1.5, chord);
    addChord(start+2.25, chord);
    addChord(start+3.0, chord);
    
    // Bass (Sidechain pulse)
    addBass(start, bassFreq, 0.2);
    addBass(start+0.5, bassFreq, 0.2);
    addBass(start+1.0, bassFreq, 0.2);
    addBass(start+1.5, bassFreq, 0.2);
    addBass(start+2.0, bassFreq, 0.2);
    addBass(start+2.5, bassFreq, 0.2);
    addBass(start+3.0, bassFreq, 0.2);
    addBass(start+3.5, bassFreq, 0.2);
    
    // Drums (4 on floor)
    for(let i=0; i<4; i++) {
        addDrum(start + i*1.0, 'kick');
        addDrum(start + i*1.0 + 0.5, 'hat');
    }
    addDrum(start+1.0, 'snare'); // Snare
    addDrum(start+3.0, 'snare');
    
    b += 4.0;
}

const C_Major = [[4,3], [3,5], [2,5]];
const G_Major = [[5,3], [4,5], [3,4]];
const F_Major = [[5,1], [4,3], [3,2]];

// C
addChorusBar(C_Major, 65.41);
// G / F Split? Tab says G F
// Let's do 2 beats G, 2 beats F
// Manual split for drop variation
// G part
addChord(b, G_Major); 
addBass(b, 49.00, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, G_Major); 
addDrum(b, 'snare');
b += 1.0;

// F part
addChord(b, F_Major);
addBass(b, 43.65, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, F_Major);
addDrum(b, 'snare');
b += 1.0;

// C
addChorusBar(C_Major, 65.41);

// G / F split
addChord(b, G_Major); 
addBass(b, 49.00, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, G_Major); 
addDrum(b, 'snare');
b += 1.0;

addChord(b, F_Major);
addBass(b, 43.65, 0.4);
addDrum(b, 'kick');
b += 1.0;
addChord(b, F_Major);
addDrum(b, 'snare');
b += 1.0;

// === KEY CHANGE OUTRO (C#) ===
// "Gotta drink every drop"
// Shift everything up 1 semitone
// C# (x4666x) G# (466544) F# (244322)
b += 1.0; // Pause

const Cs_Major = [[4,4], [3,6], [2,6]];
const Gs_Major = [[5,4], [4,6], [3,5]];
const Fs_Major = [[5,2], [4,4], [3,3]];

addChorusBar(Cs_Major, 69.30); // C#2
// G# F# Split
addChord(b, Gs_Major); addDrum(b, 'kick'); b+=1.0;
addChord(b, Gs_Major); addDrum(b, 'snare'); b+=1.0;
addChord(b, Fs_Major); addDrum(b, 'kick'); b+=1.0;
addChord(b, Fs_Major); addDrum(b, 'snare'); b+=1.0;

// Final chord C#
addChord(b, Cs_Major);
b += 4.0;

const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;
let nextDrumIdx = 0;
let nextBassIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
        nextDrumIdx = 0;
        nextBassIdx = 0;
    }

    // Schedule Melody
    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 0.4, note.target, note.type);
            triggerVisual(note);
            nextNoteIdx++;
        } else { break; }
    }
    
    // Schedule Drums
    while (nextDrumIdx < DRUMS.length) {
        const drum = DRUMS[nextDrumIdx];
        if (drum.beat <= currentBeat + 0.1) {
            const playTime = startTime + (drum.beat * (60 / CONFIG.BPM));
            if(drum.type === 'kick') AudioEngine.playKick(playTime);
            if(drum.type === 'snare') AudioEngine.playSnare(playTime, 'snare');
            if(drum.type === 'hat') AudioEngine.playHat(playTime, false);
            nextDrumIdx++;
        } else { break; }
    }
    
    // Schedule Bass
    while (nextBassIdx < BASS.length) {
        const bass = BASS[nextBassIdx];
        if (bass.beat <= currentBeat + 0.1) {
            const playTime = startTime + (bass.beat * (60 / CONFIG.BPM));
            AudioEngine.playBass(bass.freq, playTime, bass.dur * (60/CONFIG.BPM));
            nextBassIdx++;
        } else { break; }
    }

    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
let kickPulse = 0;
const activeNotes = [];
const bubbles = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function visualKick() {
    kickPulse = 1.0;
    // Spawn bubbles on kick
    for(let i=0; i<5; i++) {
        bubbles.push({
            x: Math.random() * w,
            y: h + 50,
            vy: 2 + Math.random() * 5,
            size: 5 + Math.random() * 20,
            color: Math.random() > 0.5 ? '#00f0ff' : '#ccff00'
        });
    }
}

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 
    
    // Fizz Bubbles
    for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
        ctx.fillStyle = b.color;
        ctx.fill();
        b.y -= b.vy;
        if (b.y < -50) bubbles.splice(i, 1);
    }
    
    // Shake screen on kick
    const shake = kickPulse * 5;
    const dx = (Math.random() - 0.5) * shake;
    const dy = (Math.random() - 0.5) * shake;
    
    ctx.save();
    ctx.translate(dx, dy);

    // Staff
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#ff0055';
    ctx.font = "16px 'Varela Round'";
    ctx.fillStyle = '#00f0ff';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = `rgba(0, 240, 255, ${0.5 + kickPulse*0.5})`;
    ctx.lineWidth = 4 + kickPulse * 4;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 180; 
    
    ctx.font = "20px 'Modak'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#ccff00'; 
            let txt = note.fret;
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14 + kickPulse*2, 0, Math.PI*2);
            ctx.fillStyle = '#ffecf2';
            ctx.fill();
            ctx.strokeStyle = '#ff0055'; 
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.fillStyle = '#2d3436'; 
            ctx.fillText(txt, x - 6, y + 6);
        }
    });

    // Explosions
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 80);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 0, 85, ${n.life})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        n.life -= 0.08;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }
    
    ctx.restore();
    
    // Decay Kick
    kickPulse *= 0.9;

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.filter.frequency.setTargetAtTime(200 + ((1-y) * 19800), AudioEngine.ctx.currentTime, 0.1);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 21
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>THUGZ MANSION // TAB ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Courier+New:wght@700&display=swap');

    :root {
        --paper: #fdf6e3;
        --ink: #2c3e50;
        --accent: #d35400;
        --string: #95a5a6;
    }

    body {
        margin: 0;
        background: var(--paper);
        overflow: hidden;
        font-family: 'Permanent Marker', cursive;
        color: var(--ink);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(253, 246, 227, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 4rem;
        margin: 0;
        transform: rotate(-2deg);
        text-shadow: 3px 3px 0px rgba(0,0,0,0.1);
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>Thugz Mansion</h1>
    <p>[ CLICK TO JAM ]</p>
    <p style="font-size: 0.8rem; color: #666; margin-top: 2rem;">MOUSE Y = REVERB // SPACE = PAUSE</p>
</div>

<div id="hud">
    TUNING: E A D G B E<br>
    BPM: 86
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * THUGZ MANSION TAB ENGINE
 * Acoustic Physics + Tab Parser
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 86,
    STRINGS: [64, 59, 55, 50, 45, 40], // MIDI notes for Open E A D G B E (High to Low order visually)
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], // High E to Low E
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.5;

        // Reverb Chain
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(3.0, 2.0);
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.3;

        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = length - i;
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // Guitar Tone: Sine + Triangle mix with filtered envelope
    playString: (stringIdx, fret, time, duration = 2.0, slideTo = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        // Calculate frequency: f = base * 2^(fret/12)
        // stringIdx 0 is High E, 5 is Low E
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        osc1.type = 'triangle'; // Body
        osc2.type = 'sine';     // Fundamental
        
        // Handling Slides
        if (slideTo !== null) {
            const targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.15); // Slide duration
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter Envelope (The "Pluck")
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 0.5;
        filter.frequency.setValueAtTime(freq * 4, t);
        filter.frequency.exponentialRampToValueAtTime(freq, t + 0.2);

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.4, t + 0.02); // Attack
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); // Release

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);

        osc1.start(t);
        osc1.stop(t + duration);
        osc2.start(t);
        osc2.stop(t + duration);
    },

    // Percussive "Dead Note" (The 'x' in tabs)
    playDeadNote: (time) => {
        const t = time;
        const bufSize = AudioEngine.ctx.sampleRate * 0.05; // Short burst
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;

        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 400; // Thud frequency

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0.3, t);
        amp.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

        noise.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);
        noise.start(t);
    },

    setReverb: (val) => {
        if(AudioEngine.reverbGain) AudioEngine.reverbGain.gain.setTargetAtTime(val, AudioEngine.ctx.currentTime, 0.1);
    }
};

// --- TAB DATA PARSER ---
// Format: { beat: float, string: 0-5 (High E to Low E), fret: int, type: 'pluck'|'slide'|'x', target: int }

const TAB = [];

function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}

function addChord(beat, notes) {
    // notes array: [[string, fret], [string, fret]...]
    notes.forEach(n => addNote(beat, n[0], n[1]));
}

// -- BUILD THE SONG --
// Pre-Intro
addNote(0.0, 2, 4, 'slide', 3); // G string slide 4->3
addNote(0.5, 2, 4, 'slide', 3); // Repeat

// Measure 1 (Ab)
addNote(1.0, 5, 4); // Low E, 4
addChord(1.5, [[1, 4], [2, 5], [3, 6]]); // B, G, D strings
addNote(2.0, 0, 0, 'x'); // Percussion
addChord(2.5, [[1, 4], [2, 5], [3, 6], [5, 4]]); // Chord + Bass
addNote(3.0, 5, 4); // Bass
addChord(3.5, [[1, 4], [2, 5], [3, 6]]);

// Measure 2 (Cm7)
addNote(4.0, 4, 1, 'slide', 3); // A string slide into 3
addChord(4.5, [[1, 4], [2, 3], [3, 5]]); // Chord
addNote(5.0, 0, 0, 'x');
addChord(5.5, [[1, 4], [2, 3], [3, 5], [4, 3]]); // Chord + Bass (A string)
addNote(6.0, 4, 3); // Bass A string
addChord(6.5, [[1, 4], [2, 3], [3, 5]]);

// Measure 3 (Walkup Bbm7 -> Cm7 -> C#maj7)
addChord(7.0, [[4, 1], [3, 3], [2, 1], [1, 2]]); // Bbm7
addChord(7.5, [[4, 3], [3, 5], [2, 3], [1, 4]]); // Cm7
addNote(8.0, 4, 3, 'slide', 4); // Slide Bass A string 3->4
addChord(8.0, [[3, 6], [2, 5], [1, 6]]); // C#maj7 chord
addNote(8.5, 0, 0, 'x');

// Measure 4 (Turnaround Bbm7 -> Cm7 -> Gdim6)
addChord(9.0, [[4, 1], [3, 3], [2, 1], [1, 2]]); // Bbm7
addChord(9.5, [[4, 3], [3, 5], [2, 3], [1, 4]]); // Cm7
addNote(10.0, 0, 3, 'slide', 6); // High E slide 3->6
addNote(10.25, 0, 6); // Catch note
addNote(10.5, 1, 5); // B string 5
addNote(11.0, 2, 6); // G string 6

// Loop Logic
const LOOP_LENGTH = 12.0;

// --- SEQUENCER ---
let currentBeat = -1.0; // Start with lead-in
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    // Calculate current beat based on time elapsed
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    // Loop
    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; // Reset tab pointer
        // Skip pre-intro on loop if desired, but for now loop whole thing
        // To skip pre-intro: nextNoteIdx = 2; startTime -= (beat_duration * 1.0);
    }

    // Schedule Lookahead (0.1s)
    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        
        // If note is within the play window
        if (note.beat <= currentBeat + 0.1) {
            // Schedule audio
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            
            if (note.type === 'x') {
                AudioEngine.playDeadNote(playTime);
            } else if (note.type === 'slide') {
                AudioEngine.playString(note.string, note.fret, playTime, 1.5, note.target);
            } else {
                AudioEngine.playString(note.string, note.fret, playTime, 1.5);
            }
            
            // Mark for Visuals
            triggerVisual(note);
            
            nextNoteIdx++;
        } else {
            break;
        }
    }

    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, // Hit line position
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; // Distance between strings
    const HIT_X = w * 0.2; // Where the notes hit

    // Draw Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#95a5a6';
    ctx.font = "20px 'Courier New'";
    ctx.fillStyle = '#7f8c8d';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        
        // String Line
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();

        // String Name
        ctx.fillText(name, 10, y + 5);
    });

    // Draw Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#d35400';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw Incoming Notes
    const pixelsPerBeat = 200; // Scroll speed
    
    // 1. Draw Future Notes
    ctx.font = "24px 'Permanent Marker'";
    TAB.forEach(note => {
        // Calculate relative position
        let noteBeat = note.beat;
        
        // Handle looping visual logic
        // If note is in the past relative to currentBeat, maybe it's coming up in next loop?
        // Simplification: Just draw based on distance from currentBeat
        
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; // Wrap visual approximation

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#2c3e50';
            let txt = note.type === 'x' ? 'x' : note.fret;
            if (note.type === 'slide') txt += '/';

            // Draw circle background
            ctx.beginPath();
            ctx.arc(x, y - 5, 12, 0, Math.PI*2);
            ctx.fillStyle = '#fdf6e3';
            ctx.fill();
            
            // Draw Text
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(txt, x - 6, y + 2);
        }
    });

    // 2. Draw Active Flashes (Notes that just hit)
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        // Expanding ring
        const radius = 15 + ((1 - n.life) * 30);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(211, 84, 0, ${n.life})`;
        ctx.lineWidth = 3;
        ctx.stroke();

        n.life -= 0.05;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    // Playhead Text
    ctx.font = "14px 'Courier New'";
    ctx.fillStyle = '#d35400';
    ctx.fillText("PLAYHEAD", HIT_X - 35, STAFF_Y - 110);

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
        togglePlay();
    }
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    // Map Y to Reverb Gain (0.0 to 1.0)
    // Top = Dry, Bottom = Wet
    AudioEngine.setReverb(y * 0.8);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        // Adjust start time to resume seamlessly would require tracking pause time
        // For simple tab player, restart is cleaner or just sync:
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); // Start render loop

</script>
</body>
</html>

PROGRAM 22
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TEARS IN HEAVEN // ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Courier+New:wght@700&display=swap');

    :root {
        --bg: #fdfcf0; /* Paper White */
        --ink: #5d4037; /* Brown Ink */
        --accent: #8d6e63; /* Light Brown */
        --gold: #d4af37;
    }

    body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
        font-family: 'Dancing Script', cursive;
        color: var(--ink);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(253, 252, 240, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 5rem;
        margin: 0;
        color: var(--ink);
        text-shadow: 1px 1px 0px var(--accent);
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
        color: var(--gold);
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
        color: var(--ink);
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>TEARS IN HEAVEN</h1>
    <p>[ CLICK TO START ]</p>
    <p style="font-size: 0.8rem; color: #888; margin-top: 2rem;">MOUSE Y = REVERB // SPACE = PAUSE</p>
</div>

<div id="hud">
    TONE: ACOUSTIC FINGERSTYLE<br>
    BPM: 95
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * TEARS IN HEAVEN ENGINE
 * Acoustic Physics + Tab
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 95, 
    STRINGS: [64, 59, 55, 50, 45, 40], 
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.6;

        // Warm Hall Reverb
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(2.0, 2.5);
        
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.3;

        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playString: (stringIdx, fret, time, duration = 2.0, slideTo = null, bendType = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Acoustic Tone: Triangle (Warmth) + Sine (Fundamental)
        osc1.type = 'triangle'; 
        osc2.type = 'sine'; 
        
        // Pitch Logic
        let targetFreq = freq;

        if (slideTo !== null) {
            targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter (Bright Attack, Warm Sustain)
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(3000, t);
        filter.frequency.exponentialRampToValueAtTime(1000, t + 0.1);
        filter.Q.value = 0.5;

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.5, t + 0.01); // Quick pluck
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); 

        // Mix
        const osc1Gain = AudioEngine.ctx.createGain(); osc1Gain.gain.value = 0.4;
        const osc2Gain = AudioEngine.ctx.createGain(); osc2Gain.gain.value = 0.6;

        osc1.connect(osc1Gain); osc1Gain.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
    },

    setReverb: (val) => {
        if(AudioEngine.reverbGain) AudioEngine.reverbGain.gain.setTargetAtTime(val, AudioEngine.ctx.currentTime, 0.1);
    }
};

// --- TAB DATA PARSER ---
const TAB = [];
function addNote(beat, string, fret, type = 'pluck', target = null, bend = null) {
    TAB.push({ beat, string, fret, type, target, bend });
}
function addChord(beat, notes) {
    notes.forEach(n => addNote(beat, n[0], n[1]));
}

// -- BUILD THE SONG --
let b = 0.0;
const Q = 1.0; 
const E = 0.5; 
const S = 0.25;

// === INTRO ===
// Guitar 1 (Pattern: G -> D/F# -> C/E -> D)
// Measure 1: G
// D-5 G-4 B-3 (G)
addNote(b, 3, 5); b+=E; // D-5
addNote(b, 2, 4); b+=E; // G-4
addNote(b, 1, 3); b+=E; // B-3
addNote(b, 2, 4); b+=E; // G-4
addNote(b, 3, 5); b+=E; // D-5
addNote(b, 1, 3); b+=E; // B-3
addNote(b, 3, 5); b+=E; // D-5
addNote(b, 1, 3); b+=E; // B-3

// Measure 2: D/F#
// D-4 G-2 B-3 (F# bass implied)
addNote(b, 3, 4); b+=E; // D-4
addNote(b, 2, 2); b+=E; // G-2
addNote(b, 1, 3); b+=E; // B-3
addNote(b, 2, 2); b+=E; // G-2
addNote(b, 3, 4); b+=E; // D-4
addNote(b, 1, 3); b+=E; // B-3
addNote(b, 3, 4); b+=E; // D-4
addNote(b, 1, 3); b+=E; // B-3

// Measure 3: C/E
// D-2 G-0 B-1
addNote(b, 3, 2); b+=E; // D-2
addNote(b, 2, 0); b+=E; // G-0
addNote(b, 1, 1); b+=E; // B-1
addNote(b, 2, 0); b+=E; // G-0
addNote(b, 3, 2); b+=E; // D-2
addNote(b, 1, 1); b+=E; // B-1
addNote(b, 3, 2); b+=E; // D-2
addNote(b, 1, 1); b+=E; // B-1

// Measure 4: D
// D-0 G-2 B-3
addNote(b, 3, 0); b+=E; // D-0
addNote(b, 2, 2); b+=E; // G-2
addNote(b, 1, 3); b+=E; // B-3
addNote(b, 2, 2); b+=E; // G-2
addNote(b, 3, 0); b+=E; // D-0
addNote(b, 1, 3); b+=E; // B-3
addNote(b, 3, 0); b+=E; // D-0
addNote(b, 1, 3); b+=E; // B-3

// REPEAT INTRO WITH VARIATION (Hammer on)
// G
addNote(b, 3, 5); b+=E;
addNote(b, 2, 4); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 2, 4); b+=E;
addNote(b, 3, 5); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 3, 5); b+=E;
addNote(b, 3, 0, 'slide', 4); b+=E; // 0h4 hammer on sim

// D/F#
addNote(b, 3, 4); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 3, 4); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 3, 4); b+=E;
addNote(b, 3, 4); b+=E;

// C/E
addNote(b, 3, 2); b+=E;
addNote(b, 2, 0); b+=E; // B string 1? No G-0
addNote(b, 2, 0); b+=E;
addNote(b, 2, 0); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 1, 1); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 2); b+=E;

// D (High voicing)
// D-0 G-2 B-3 E-2
addNote(b, 3, 0); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 0, 2); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 3, 0); b+=E;

// === VERSE 1 ===
// "Would you know my name..."
// Similar pattern but simpler
// G
addNote(b, 3, 5); b+=E;
addNote(b, 2, 4); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 2, 4); b+=E;
addNote(b, 3, 5); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 3, 5); b+=E;
addNote(b, 3, 5); b+=E;

// D/F#
addNote(b, 3, 4); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 3, 4); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 3, 4); b+=E;
addNote(b, 3, 4); b+=E;

// C/E
addNote(b, 3, 2); b+=E;
addNote(b, 2, 0); b+=E;
addNote(b, 1, 1); b+=E;
addNote(b, 2, 0); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 1, 1); b+=E;
addNote(b, 3, 2); b+=E;
addNote(b, 3, 2); b+=E;

// D
addNote(b, 3, 0); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 2, 2); b+=E;
addNote(b, 3, 0); b+=E;
addNote(b, 1, 3); b+=E;
addNote(b, 3, 0); b+=E;
addNote(b, 2, 0); b+=E;

// Loop Logic
const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; 
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; 
    }

    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        if (note.beat <= currentBeat + 0.1) {
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            AudioEngine.playString(note.string, note.fret, playTime, 1.5, note.target, note.bend);
            triggerVisual(note);
            nextNoteIdx++;
        } else {
            break;
        }
    }
    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, 
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; 
    const HIT_X = w * 0.2; 

    // Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#5d4037';
    ctx.font = "16px 'Courier New'";
    ctx.fillStyle = '#8d6e63';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
        ctx.fillText(name, 10, y + 5);
    });

    // Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#d4af37';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Notes
    const pixelsPerBeat = 100; 
    
    ctx.font = "20px 'Dancing Script'";
    TAB.forEach(note => {
        let noteBeat = note.beat;
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; 

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#5d4037'; 
            let txt = note.fret;
            if(note.target) txt += '/';
            
            ctx.beginPath();
            ctx.arc(x, y - 5, 14, 0, Math.PI*2);
            ctx.fillStyle = '#fdfcf0';
            ctx.fill();
            ctx.strokeStyle = '#5d4037'; 
            ctx.lineWidth = 1;
            ctx.stroke();
            
            ctx.fillText(txt, x - 6, y + 4);
        }
    });

    // Ripples
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        const radius = 15 + ((1 - n.life) * 40);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(141, 110, 99, ${n.life})`;
        ctx.lineWidth = 2;
        ctx.stroke();

        n.life -= 0.02;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePlay();
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    AudioEngine.setReverb(y);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); 

</script>
</body>
</html>

PROGRAM 23
___________________________________________________

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WONDERWALL // TAB ENGINE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Courier+New:wght@700&display=swap');

    :root {
        --paper: #fdf6e3;
        --ink: #2c3e50;
        --accent: #d35400;
        --string: #95a5a6;
    }

    body {
        margin: 0;
        background: var(--paper);
        overflow: hidden;
        font-family: 'Permanent Marker', cursive;
        color: var(--ink);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(253, 246, 227, 0.95);
        z-index: 10;
        transition: opacity 0.5s;
    }

    h1 {
        font-size: 4rem;
        margin: 0;
        transform: rotate(-2deg);
        text-shadow: 3px 3px 0px rgba(0,0,0,0.1);
    }

    p {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        margin-top: 10px;
        font-size: 1.2rem;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        pointer-events: none;
        z-index: 5;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>Wonderwall</h1>
    <p>[ CLICK TO JAM ]</p>
    <p style="font-size: 0.8rem; color: #666; margin-top: 2rem;">MOUSE Y = REVERB // SPACE = PAUSE</p>
</div>

<div id="hud">
    TUNING: E A D G B E<br>
    BPM: 87
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * WONDERWALL TAB ENGINE
 * Acoustic Physics + Tab Parser
 */

// --- CONFIGURATION ---
const CONFIG = {
    BPM: 87,
    STRINGS: [64, 59, 55, 50, 45, 40], // MIDI notes for Open E A D G B E (High to Low order visually)
    BASE_FREQS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], // High E to Low E
    STRING_NAMES: ['e', 'B', 'G', 'D', 'A', 'E']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    reverb: null,
    reverbGain: null,
    isPlaying: false,

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.5;

        // Reverb Chain
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(3.0, 2.0);
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.3;

        AudioEngine.master.connect(AudioEngine.ctx.destination);
        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = length - i;
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    // Guitar Tone: Sine + Triangle mix with filtered envelope
    playString: (stringIdx, fret, time, duration = 2.0, slideTo = null) => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        // Calculate frequency: f = base * 2^(fret/12)
        // stringIdx 0 is High E, 5 is Low E
        const baseFreq = CONFIG.BASE_FREQS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        osc1.type = 'triangle'; // Body
        osc2.type = 'sine';     // Fundamental
        
        // Handling Slides
        if (slideTo !== null) {
            const targetFreq = baseFreq * Math.pow(2, slideTo / 12);
            osc1.frequency.setValueAtTime(freq, t);
            osc1.frequency.linearRampToValueAtTime(targetFreq, t + 0.15); // Slide duration
            osc2.frequency.setValueAtTime(freq, t);
            osc2.frequency.linearRampToValueAtTime(targetFreq, t + 0.15);
        } else {
            osc1.frequency.value = freq;
            osc2.frequency.value = freq;
        }

        // Filter Envelope (The "Pluck")
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 0.5;
        filter.frequency.setValueAtTime(freq * 4, t);
        filter.frequency.exponentialRampToValueAtTime(freq, t + 0.2);

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.4, t + 0.02); // Attack
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration); // Release

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);

        osc1.start(t);
        osc1.stop(t + duration);
        osc2.start(t);
        osc2.stop(t + duration);
    },

    // Percussive "Dead Note" (The 'x' in tabs)
    playDeadNote: (time) => {
        const t = time;
        const bufSize = AudioEngine.ctx.sampleRate * 0.05; // Short burst
        const buffer = AudioEngine.ctx.createBuffer(1, bufSize, AudioEngine.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = AudioEngine.ctx.createBufferSource();
        noise.buffer = buffer;

        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 400; // Thud frequency

        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0.3, t);
        amp.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

        noise.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.master);
        noise.start(t);
    },

    setReverb: (val) => {
        if(AudioEngine.reverbGain) AudioEngine.reverbGain.gain.setTargetAtTime(val, AudioEngine.ctx.currentTime, 0.1);
    }
};

// --- TAB DATA PARSER ---
// Format: { beat: float, string: 0-5 (High E to Low E), fret: int, type: 'pluck'|'slide'|'x', target: int }

const TAB = [];

function addNote(beat, string, fret, type = 'pluck', target = null) {
    TAB.push({ beat, string, fret, type, target });
}

function addChord(beat, notes) {
    // notes array: [[string, fret], [string, fret]...]
    notes.forEach(n => addNote(beat, n[0], n[1]));
}

// --- WONDERWALL CHORD DEFINITIONS (Oasis Voicings) ---
// Em7: 022033
const Em7 = [[5, 0], [4, 2], [3, 2], [2, 0], [1, 3], [0, 3]];
// G: 320033
const G = [[5, 3], [4, 2], [3, 0], [2, 0], [1, 3], [0, 3]];
// Dsus4: xx0233
const Dsus4 = [[3, 0], [2, 2], [1, 3], [0, 3]];
// A7sus4: x02033
const A7sus4 = [[4, 0], [3, 2], [2, 0], [1, 3], [0, 3]];
// Cadd9: x32033
const Cadd9 = [[4, 3], [3, 2], [2, 0], [1, 3], [0, 3]];

// -- BUILD THE SONG --

// Helper for the strumming pattern (approximate)
// Rhythm: D . D U . U D U (Syncopated changes)
function addMeasure(startBeat, chord1, chord2) {
    // Chord 1 (beats 1-2)
    addChord(startBeat + 0.0, chord1); // Down
    addChord(startBeat + 1.0, chord1); // Down
    addChord(startBeat + 1.5, chord1); // Up
    
    // Chord change anticipated on 'and' of 2
    addChord(startBeat + 1.75, chord2); // Up (change)
    
    // Chord 2 (beats 3-4)
    addChord(startBeat + 2.5, chord2); // Up
    addChord(startBeat + 3.0, chord2); // Down
    addChord(startBeat + 3.5, chord2); // Up
}

// INTRO / VERSE PATTERN
// Em7 -> G -> Dsus4 -> A7sus4
let b = 0;

// Intro (x2)
addMeasure(b, Em7, G); b += 4;
addMeasure(b, Dsus4, A7sus4); b += 4;
addMeasure(b, Em7, G); b += 4;
addMeasure(b, Dsus4, A7sus4); b += 4;

// Verse 1 ("Today is gonna be the day...")
// Em7 G D A7sus4
addMeasure(b, Em7, G); b += 4;
addMeasure(b, Dsus4, A7sus4); b += 4;
addMeasure(b, Em7, G); b += 4;
addMeasure(b, Dsus4, A7sus4); b += 4;

// Verse 1 Cont. ("I don't believe that anybody...")
// Em7 G D A7sus4
addMeasure(b, Em7, G); b += 4;
addMeasure(b, Dsus4, A7sus4); b += 4;
// "C D A7sus4" turn
addChord(b + 0.0, Cadd9);
addChord(b + 1.0, Dsus4);
addChord(b + 2.0, A7sus4);
addChord(b + 3.0, A7sus4);
b += 4;

// Pre-Chorus ("And all the roads...")
// C D Em
addMeasure(b, Cadd9, Dsus4); b += 4;
addMeasure(b, Em7, Em7); b += 4; // Em hangs
// "And all the lights..."
// C D Em
addMeasure(b, Cadd9, Dsus4); b += 4;
addMeasure(b, Em7, Em7); b += 4;

// "There are many things..."
// C D G D/F# Em D A7sus4
addChord(b + 0.0, Cadd9);
addChord(b + 1.0, Dsus4);
addChord(b + 2.0, G);
// D/F# passing
addNote(b + 2.5, 5, 2); 
addChord(b + 3.0, Em7);
addChord(b + 3.5, Dsus4);
b += 4;

// "I don't know how..."
addMeasure(b, A7sus4, A7sus4); b += 4;

// Chorus ("Because maybe...")
// C Em G Em
addMeasure(b, Cadd9, Em7); b += 4;
addMeasure(b, G, Em7); b += 4;
// "You're gonna be the one..."
// C Em G Em
addMeasure(b, Cadd9, Em7); b += 4;
addMeasure(b, G, Em7); b += 4;

// Loop Logic
const LOOP_LENGTH = b;

// --- SEQUENCER ---
let currentBeat = -1.0; // Start with lead-in
let startTime = 0;
let nextNoteIdx = 0;

function scheduler() {
    if (!AudioEngine.isPlaying) return;

    const currentTime = AudioEngine.ctx.currentTime;
    // Calculate current beat based on time elapsed
    const elapsed = currentTime - startTime;
    currentBeat = (elapsed * (CONFIG.BPM / 60)); 

    // Loop
    if (currentBeat >= LOOP_LENGTH) {
        startTime = currentTime;
        currentBeat = 0;
        nextNoteIdx = 0; // Reset tab pointer
        // Skip pre-intro on loop if desired, but for now loop whole thing
        // To skip pre-intro: nextNoteIdx = 2; startTime -= (beat_duration * 1.0);
    }

    // Schedule Lookahead (0.1s)
    while (nextNoteIdx < TAB.length) {
        const note = TAB[nextNoteIdx];
        
        // If note is within the play window
        if (note.beat <= currentBeat + 0.1) {
            // Schedule audio
            const playTime = startTime + (note.beat * (60 / CONFIG.BPM));
            
            if (note.type === 'x') {
                AudioEngine.playDeadNote(playTime);
            } else if (note.type === 'slide') {
                AudioEngine.playString(note.string, note.fret, playTime, 1.5, note.target);
            } else {
                AudioEngine.playString(note.string, note.fret, playTime, 1.5);
            }
            
            // Mark for Visuals
            triggerVisual(note);
            
            nextNoteIdx++;
        } else {
            break;
        }
    }

    requestAnimationFrame(scheduler);
}

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const activeNotes = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(note) {
    activeNotes.push({
        ...note,
        x: w * 0.2, // Hit line position
        life: 1.0,
        born: Date.now()
    });
}

function draw() {
    ctx.clearRect(0, 0, w, h);

    const STAFF_Y = h / 2;
    const SPACING = 30; // Distance between strings
    const HIT_X = w * 0.2; // Where the notes hit

    // Draw Staff
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#95a5a6';
    ctx.font = "20px 'Courier New'";
    ctx.fillStyle = '#7f8c8d';
    
    CONFIG.STRING_NAMES.forEach((name, i) => {
        const y = STAFF_Y + (i * SPACING) - (2.5 * SPACING);
        
        // String Line
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();

        // String Name
        ctx.fillText(name, 10, y + 5);
    });

    // Draw Hit Line
    ctx.beginPath();
    ctx.moveTo(HIT_X, STAFF_Y - 100);
    ctx.lineTo(HIT_X, STAFF_Y + 100);
    ctx.strokeStyle = '#d35400';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw Incoming Notes
    const pixelsPerBeat = 200; // Scroll speed
    
    // 1. Draw Future Notes
    ctx.font = "24px 'Permanent Marker'";
    TAB.forEach(note => {
        // Calculate relative position
        let noteBeat = note.beat;
        
        // Handle looping visual logic
        // If note is in the past relative to currentBeat, maybe it's coming up in next loop?
        // Simplification: Just draw based on distance from currentBeat
        
        let dist = noteBeat - currentBeat;
        if (dist < -2) dist += LOOP_LENGTH; // Wrap visual approximation

        const x = HIT_X + (dist * pixelsPerBeat);
        
        if (x > 0 && x < w) {
            const y = STAFF_Y + (note.string * SPACING) - (2.5 * SPACING);
            
            ctx.fillStyle = '#2c3e50';
            let txt = note.type === 'x' ? 'x' : note.fret;
            if (note.type === 'slide') txt += '/';

            // Draw circle background
            ctx.beginPath();
            ctx.arc(x, y - 5, 12, 0, Math.PI*2);
            ctx.fillStyle = '#fdf6e3';
            ctx.fill();
            
            // Draw Text
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(txt, x - 6, y + 2);
        }
    });

    // 2. Draw Active Flashes (Notes that just hit)
    for (let i = activeNotes.length - 1; i >= 0; i--) {
        const n = activeNotes[i];
        const y = STAFF_Y + (n.string * SPACING) - (2.5 * SPACING);
        
        // Expanding ring
        const radius = 15 + ((1 - n.life) * 30);
        ctx.beginPath();
        ctx.arc(HIT_X, y - 5, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(211, 84, 0, ${n.life})`;
        ctx.lineWidth = 3;
        ctx.stroke();

        n.life -= 0.05;
        if(n.life <= 0) activeNotes.splice(i, 1);
    }

    // Playhead Text
    ctx.font = "14px 'Courier New'";
    ctx.fillStyle = '#d35400';
    ctx.fillText("PLAYHEAD", HIT_X - 35, STAFF_Y - 110);

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
        togglePlay();
    }
});

document.addEventListener('click', () => {
    if(!AudioEngine.ctx) {
        AudioEngine.init();
        togglePlay();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    const y = e.clientY / window.innerHeight;
    // Map Y to Reverb Gain (0.0 to 1.0)
    // Top = Dry, Bottom = Wet
    AudioEngine.setReverb(y * 0.8);
});

function togglePlay() {
    if (AudioEngine.isPlaying) {
        AudioEngine.isPlaying = false;
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        if (startTime === 0) startTime = AudioEngine.ctx.currentTime;
        // Adjust start time to resume seamlessly would require tracking pause time
        // For simple tab player, restart is cleaner or just sync:
        startTime = AudioEngine.ctx.currentTime - (currentBeat * (60/CONFIG.BPM));
        scheduler();
    }
}

draw(); // Start render loop

</script>
</body>
</html>

PROGRAM 24
___________________________________________________

