<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GEMINI // ETERNAL OPUS</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syncopate:wght@700&display=swap');

    :root {
        --void: #08080c;
        --star: #e2e2e2;
        --cyan: #00f0ff;
        --magenta: #ff0055;
        --gold: #ffd700;
    }

    body {
        margin: 0;
        background: var(--void);
        overflow: hidden;
        font-family: 'Space Mono', monospace;
        color: var(--star);
        user-select: none;
    }

    #canvas {
        display: block;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
    }

    #overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(8, 8, 12, 0.9);
        z-index: 10;
        transition: opacity 0.8s;
        backdrop-filter: blur(5px);
    }

    h1 {
        font-family: 'Syncopate', sans-serif;
        font-size: 4vw;
        margin: 0;
        text-transform: uppercase;
        background: linear-gradient(45deg, var(--cyan), var(--magenta));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: 10px;
        text-align: center;
    }

    p {
        font-weight: bold;
        margin-top: 20px;
        font-size: 1rem;
        color: var(--star);
        letter-spacing: 2px;
        opacity: 0.8;
    }

    .hidden {
        opacity: 0;
        pointer-events: none;
    }

    #hud {
        position: absolute;
        bottom: 30px;
        left: 30px;
        font-size: 12px;
        pointer-events: none;
        z-index: 5;
        color: var(--star);
        border-left: 2px solid var(--cyan);
        padding-left: 15px;
        line-height: 1.5;
    }

    #chord-display {
        font-size: 3rem;
        font-weight: 700;
        color: var(--gold);
        margin-bottom: 5px;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }
    
    #mode-display {
        color: var(--magenta);
        text-transform: uppercase;
    }
</style>
</head>
<body>

<div id="overlay">
    <h1>THE ETERNAL<br>IMPROVISER</h1>
    <p>[ CLICK TO INITIATE GENERATIVE CORE ]</p>
    <p style="font-size: 0.7rem; margin-top: 2rem; opacity: 0.5;">MOUSE Y CONTROLS INTENSITY // GENERATED IN REALTIME</p>
</div>

<div id="hud">
    <div id="chord-display">Em9</div>
    <div id="mode-display">PHASE: ATMOSPHERIC</div>
    <div>SCALE: E DORIAN</div>
</div>

<canvas id="canvas"></canvas>

<script>
/**
 * GEMINI ETERNAL OPUS
 * A self-composing generative guitar engine.
 */

// --- MUSIC THEORY KNOWLEDGE BASE ---
const THEORY = {
    // Strings: High E to Low E frequencies
    STRINGS: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41],
    
    // E Dorian / Minor Pentatonic Pool
    // Format: [String Index (0-5), Fret]
    SCALES: {
        'Em_Pent': [
            [5,0], [5,3], [5,5], [5,7], [5,10], [5,12],
            [4,0], [4,2], [4,5], [4,7], [4,10], [4,12], 
            [3,0], [3,2], [3,5], [3,7], [3,9],  [3,12],
            [2,0], [2,2], [2,4], [2,7], [2,9],  [2,12],
            [1,0], [1,3], [1,5], [1,8], [1,10], [1,12],
            [0,0], [0,3], [0,5], [0,7], [0,10], [0,12]
        ],
        'E_Dorian': [ // Adds F# and C# to Em
            [5,0], [5,2], [5,3], [5,5], [5,7], [5,9], [5,10], [5,12],
            [4,0], [4,2], [4,4], [4,5], [4,7], [4,9], [4,10], [4,12],
            [3,0], [3,2], [3,4], [3,5], [3,7], [3,9], [3,11], [3,12],
            [2,0], [2,2], [2,4], [2,5], [2,7], [2,9], [2,11], [2,12],
            [1,0], [1,2], [1,3], [1,5], [1,7], [1,8], [1,10], [1,12],
            [0,0], [0,2], [0,3], [0,5], [0,7], [0,9], [0,10], [0,12]
        ]
    },
    
    // Chord Shapes (String, Fret)
    CHORDS: {
        'Em9': [[5,0], [4,2], [3,4], [2,0], [1,3], [0,2]],
        'Cmaj7': [[4,3], [3,5], [2,4], [1,5], [0,3]],
        'Am7': [[5,5], [4,7], [3,5], [2,5], [1,5], [0,5]],
        'Dadd11': [[5,10], [4,12], [3,11], [2,0], [1,10], [0,10]], // Big barre
        'G': [[5,3], [4,2], [3,0], [2,0], [1,3], [0,3]]
    },
    
    PROGRESSION: ['Em9', 'Cmaj7', 'Am7', 'Dadd11', 'Em9', 'G', 'Cmaj7', 'Dadd11']
};

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    master: null,
    
    // FX Nodes
    drive: null,
    driveGain: null,
    reverb: null,
    reverbGain: null,
    delay: null,
    delayGain: null,
    
    // State
    isPlaying: false,
    intensity: 0.3, // 0.0 - 1.0 controlled by mouse

    init: async () => {
        const AC = window.AudioContext || window.webkitAudioContext;
        AudioEngine.ctx = new AC();
        
        AudioEngine.master = AudioEngine.ctx.createGain();
        AudioEngine.master.gain.value = 0.3;

        // 1. DYNAMIC DRIVE (Tube Screamer Emulation)
        AudioEngine.drive = AudioEngine.ctx.createWaveShaper();
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(50); // Start low
        AudioEngine.drive.oversample = '4x';
        AudioEngine.driveGain = AudioEngine.ctx.createGain();
        AudioEngine.driveGain.gain.value = 1.0;

        // 2. ATMOSPHERIC DELAY
        AudioEngine.delay = AudioEngine.ctx.createDelay();
        AudioEngine.delay.delayTime.value = 0.375; // Dotted 8th ish
        AudioEngine.delayGain = AudioEngine.ctx.createGain();
        AudioEngine.delayGain.gain.value = 0.3;
        const delayFb = AudioEngine.ctx.createGain();
        delayFb.gain.value = 0.4;

        // 3. COSMIC REVERB
        AudioEngine.reverb = AudioEngine.ctx.createConvolver();
        AudioEngine.reverb.buffer = await AudioEngine.createImpulse(3.0, 2.0);
        AudioEngine.reverbGain = AudioEngine.ctx.createGain();
        AudioEngine.reverbGain.gain.value = 0.4;

        // ROUTING
        // Signal -> Drive -> Master
        //        -> Delay -> Master
        //        -> Reverb -> Master
        
        AudioEngine.driveGain.connect(AudioEngine.drive);
        AudioEngine.drive.connect(AudioEngine.master);
        
        AudioEngine.master.connect(AudioEngine.ctx.destination);
        
        // Aux Sends from Master (Post-Drive)
        AudioEngine.master.connect(AudioEngine.delay);
        AudioEngine.delay.connect(delayFb);
        delayFb.connect(AudioEngine.delay);
        AudioEngine.delay.connect(AudioEngine.delayGain);
        AudioEngine.delayGain.connect(AudioEngine.ctx.destination);

        AudioEngine.master.connect(AudioEngine.reverbGain);
        AudioEngine.reverbGain.connect(AudioEngine.reverb);
        AudioEngine.reverb.connect(AudioEngine.ctx.destination);
    },

    makeDistortionCurve: (amount) => {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            let x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    },

    createImpulse: async (duration, decay) => {
        const rate = AudioEngine.ctx.sampleRate;
        const length = rate * duration;
        const impulse = AudioEngine.ctx.createBuffer(2, length, rate);
        const L = impulse.getChannelData(0);
        const R = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            L[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            R[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
        return impulse;
    },

    playNote: (stringIdx, fret, time, duration = 1.0, type = 'pluck') => {
        if (!AudioEngine.ctx) return;
        
        const t = time;
        const baseFreq = THEORY.STRINGS[stringIdx];
        const freq = baseFreq * Math.pow(2, fret / 12);
        
        const osc1 = AudioEngine.ctx.createOscillator();
        const osc2 = AudioEngine.ctx.createOscillator();
        
        // Tone Morphing: Sine (Clean) -> Sawtooth (Dirty) based on Intensity
        const intensity = AudioEngine.intensity;
        
        if (intensity < 0.4) {
            osc1.type = 'sine';
            osc2.type = 'triangle';
        } else if (intensity < 0.7) {
            osc1.type = 'triangle';
            osc2.type = 'sawtooth';
        } else {
            osc1.type = 'sawtooth';
            osc2.type = 'square';
        }
        
        osc1.frequency.value = freq;
        osc2.frequency.value = freq;
        osc2.detune.value = intensity * 10; // Detune widens with intensity

        // Filter Envelope (The "Pluck")
        const filter = AudioEngine.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        const cutoffStart = 500 + (intensity * 4000); // Brightness
        filter.frequency.setValueAtTime(cutoffStart, t);
        filter.frequency.exponentialRampToValueAtTime(cutoffStart * 0.2, t + 0.2);
        filter.Q.value = 1 + (intensity * 5);

        // Amplitude Envelope
        const amp = AudioEngine.ctx.createGain();
        amp.gain.setValueAtTime(0, t);
        amp.gain.linearRampToValueAtTime(0.6, t + 0.01);
        amp.gain.exponentialRampToValueAtTime(0.001, t + duration);

        // Mix
        const oscMix = AudioEngine.ctx.createGain();
        oscMix.gain.value = 0.5;

        osc1.connect(oscMix);
        osc2.connect(oscMix);
        oscMix.connect(filter);
        filter.connect(amp);
        amp.connect(AudioEngine.driveGain);

        osc1.start(t); osc1.stop(t + duration);
        osc2.start(t); osc2.stop(t + duration);
        
        // Visual Trigger
        triggerVisual(stringIdx, fret, intensity);
    },
    
    updateParams: () => {
        if (!AudioEngine.ctx) return;
        const t = AudioEngine.ctx.currentTime;
        const i = AudioEngine.intensity;
        
        // Morph FX based on intensity
        // Drive: 0 -> 400
        const driveAmount = i * 400;
        AudioEngine.drive.curve = AudioEngine.makeDistortionCurve(driveAmount);
        
        // Delay: More delay on high intensity
        AudioEngine.delayGain.gain.setTargetAtTime(0.2 + (i * 0.3), t, 0.1);
    }
};

// --- THE COMPOSER (GENERATIVE LOGIC) ---
const Composer = {
    BPM: 110,
    nextNoteTime: 0,
    currentBar: 0,
    currentChordIdx: 0,
    
    // Rhythm Patterns (in 16th notes)
    patterns: [
        [1, 0, 0, 1, 0, 0, 1, 0], // 3-3-2 (Polyrhythm)
        [1, 0, 1, 0, 1, 0, 1, 0], // Straight 8ths
        [1, 0, 0, 0, 1, 0, 0, 0], // Quarter notes
        [1, 1, 1, 1, 1, 1, 1, 1]  // Shred (16ths)
    ],

    scheduler: () => {
        if (!AudioEngine.isPlaying) return;
        
        // Schedule ahead
        while (Composer.nextNoteTime < AudioEngine.ctx.currentTime + 0.2) {
            Composer.composeBeat(Composer.nextNoteTime);
            Composer.nextNoteTime += (60 / Composer.BPM) / 4; // Advance by 16th note
        }
        setTimeout(Composer.scheduler, 25);
    },

    composeBeat: (t) => {
        // 1. Determine Context
        const sixteenth = Math.floor((t * (Composer.BPM/60) * 4)) % 16; // 0-15 in a bar
        const bar = Math.floor((t * (Composer.BPM/60) / 4));
        
        // New Bar? Change Chord
        if (bar !== Composer.currentBar) {
            Composer.currentBar = bar;
            Composer.currentChordIdx = (Composer.currentChordIdx + 1) % THEORY.PROGRESSION.length;
            const chordName = THEORY.PROGRESSION[Composer.currentChordIdx];
            
            // Play the chord on beat 1
            const notes = THEORY.CHORDS[chordName];
            notes.forEach((n, i) => {
                // Strum effect
                AudioEngine.playNote(n[0], n[1], t + (i*0.02), 3.0);
            });
            
            // UI Update
            document.getElementById('chord-display').innerText = chordName;
            const intensity = AudioEngine.intensity;
            const mode = intensity < 0.3 ? "ATMOSPHERIC" : intensity < 0.7 ? "GROOVING" : "MELTING";
            document.getElementById('mode-display').innerText = `PHASE: ${mode}`;
        }

        // 2. Determine Lead Line (Based on Intensity)
        // Higher intensity = higher probability of notes & faster divisions
        const intensity = AudioEngine.intensity;
        let patternIdx = 0;
        if (intensity > 0.3) patternIdx = 1;
        if (intensity > 0.6) patternIdx = 0; // Syncopated
        if (intensity > 0.85) patternIdx = 3; // Shred
        
        const pattern = Composer.patterns[patternIdx];
        const step = sixteenth % 8;
        
        if (pattern[step] === 1) {
            // Play a lead note?
            // Chance increases with intensity
            if (Math.random() < intensity + 0.2) {
                // Pick a note from Scale
                const scale = THEORY.SCALES['E_Dorian'];
                // Pick note range based on intensity (Higher intensity = Higher fretboard)
                const minIdx = Math.floor(intensity * 20);
                const maxIdx = Math.min(scale.length - 1, minIdx + 15);
                
                // Random walk or random pick
                const noteIdx = Math.floor(Math.random() * (maxIdx - minIdx + 1)) + minIdx;
                const n = scale[noteIdx];
                
                // Add humanization
                const humanTime = t + (Math.random() * 0.02);
                AudioEngine.playNote(n[0], n[1], humanTime, 0.5);
            }
        }
    }
};

// --- VISUAL ENGINE ---
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
let w, h;
const particles = [];

function resize() {
    w = cvs.width = window.innerWidth;
    h = cvs.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function triggerVisual(string, fret, intensity) {
    // Create a burst at a position mapped to string/fret
    const x = (fret / 15) * w * 0.8 + (w * 0.1);
    const y = (string / 6) * h * 0.6 + (h * 0.2);
    
    // Color based on intensity
    let hue = 180; // Cyan
    if (intensity > 0.5) hue = 320; // Pink
    if (intensity > 0.8) hue = 50; // Gold
    
    particles.push({
        x: x, y: y,
        vx: (Math.random() - 0.5) * 5,
        vy: (Math.random() - 0.5) * 5,
        life: 1.0,
        hue: hue,
        size: 5 + (intensity * 20)
    });
}

function draw() {
    // Trails
    ctx.fillStyle = 'rgba(8, 8, 12, 0.2)';
    ctx.fillRect(0, 0, w, h);
    
    // Draw Strings
    ctx.lineWidth = 1;
    for(let i=0; i<6; i++) {
        const y = (i / 6) * h * 0.6 + (h * 0.2);
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
    }

    // Draw Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
        ctx.fillStyle = `hsla(${p.hue}, 100%, 50%, ${p.life})`;
        ctx.fill();
        
        // Glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = `hsla(${p.hue}, 100%, 50%, 1)`;
        
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        
        if (p.life <= 0) particles.splice(i, 1);
    }
    ctx.shadowBlur = 0;

    requestAnimationFrame(draw);
}

// --- INPUTS ---
document.addEventListener('click', async () => {
    if (!AudioEngine.ctx) {
        await AudioEngine.init();
        AudioEngine.isPlaying = true;
        document.getElementById('overlay').classList.add('hidden');
        Composer.nextNoteTime = AudioEngine.ctx.currentTime + 0.1;
        Composer.scheduler();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!AudioEngine.ctx) return;
    // Map Y to Intensity (Bottom = 0, Top = 1)
    const y = 1 - (e.clientY / window.innerHeight);
    AudioEngine.intensity = Math.max(0.1, Math.min(1.0, y));
    AudioEngine.updateParams();
});

document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
        AudioEngine.isPlaying = !AudioEngine.isPlaying;
        if(AudioEngine.isPlaying) {
            Composer.nextNoteTime = AudioEngine.ctx.currentTime + 0.1;
            Composer.scheduler();
        }
    }
});

draw();

</script>
</body>
</html>